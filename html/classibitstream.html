<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Marked Graph Compression: ibitstream Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Marked Graph Compression
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classibitstream-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">ibitstream Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>deals with reading bit streams from binary files, this is the reverse of obitstream  
 <a href="classibitstream.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="bitstream_8h_source.html">bitstream.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac62c26004436d83f337f4aeba0895e20" id="r_ac62c26004436d83f337f4aeba0895e20"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibitstream.html#ac62c26004436d83f337f4aeba0895e20">read_chunk</a> ()</td></tr>
<tr class="memdesc:ac62c26004436d83f337f4aeba0895e20"><td class="mdescLeft">&#160;</td><td class="mdescRight">reads one chunk (4 bytes) from the input file and stores it in buffer  <br /></td></tr>
<tr class="separator:ac62c26004436d83f337f4aeba0895e20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fdcaecf10fefa6942dcd5286a2696e0" id="r_a2fdcaecf10fefa6942dcd5286a2696e0"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibitstream.html#a2fdcaecf10fefa6942dcd5286a2696e0">read_bits</a> (unsigned int k)</td></tr>
<tr class="memdesc:a2fdcaecf10fefa6942dcd5286a2696e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">read k bits from the input, interpret it as integer (first bit read is MSB) and return its value. Here, k must be in the range 1 &lt;= k &lt;= BIT_INT  <br /></td></tr>
<tr class="separator:a2fdcaecf10fefa6942dcd5286a2696e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bb7a698ab44c1e2fe21b4daa880bd6c" id="r_a4bb7a698ab44c1e2fe21b4daa880bd6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibitstream.html#a4bb7a698ab44c1e2fe21b4daa880bd6c">read_bits</a> (int k, <a class="el" href="classbit__pipe.html">bit_pipe</a> &amp;B)</td></tr>
<tr class="memdesc:a4bb7a698ab44c1e2fe21b4daa880bd6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">reads k bits from input and stores in the given <a class="el" href="classbit__pipe.html" title="A sequence of arbitrary number of bits.">bit_pipe</a>. \(k \geq 1\) is arbitrary. The bits are stored in the <a class="el" href="classbit__pipe.html" title="A sequence of arbitrary number of bits.">bit_pipe</a> so that can be interpreted as integer (e.g. mpz_class) so the LSB is located in the rightmost bit of the rightmost chunk (unlike the usual <a class="el" href="classbit__pipe.html" title="A sequence of arbitrary number of bits.">bit_pipe</a> situation). We assume that the B given here is an empty <a class="el" href="classbit__pipe.html" title="A sequence of arbitrary number of bits.">bit_pipe</a>  <br /></td></tr>
<tr class="separator:a4bb7a698ab44c1e2fe21b4daa880bd6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acec2e9efa21551ce8db784f5b0bbd1b5" id="r_acec2e9efa21551ce8db784f5b0bbd1b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibitstream.html#acec2e9efa21551ce8db784f5b0bbd1b5">read_bits_append</a> (int k, <a class="el" href="classbit__pipe.html">bit_pipe</a> &amp;B)</td></tr>
<tr class="memdesc:acec2e9efa21551ce8db784f5b0bbd1b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">similar to read_bits, but B does not have to be empty and the result will be appended to B (this is used in order to recursively implement read_bits)  <br /></td></tr>
<tr class="separator:acec2e9efa21551ce8db784f5b0bbd1b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a895239acf7179f6778388c39c97643e4" id="r_a895239acf7179f6778388c39c97643e4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibitstream.html#a895239acf7179f6778388c39c97643e4">read_bit</a> ()</td></tr>
<tr class="memdesc:a895239acf7179f6778388c39c97643e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">read one bit from input and return true if its value is 1 and false otherwise.  <br /></td></tr>
<tr class="separator:a895239acf7179f6778388c39c97643e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5f00b64072ed3ffe495b7712a71e3eb" id="r_af5f00b64072ed3ffe495b7712a71e3eb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibitstream.html#af5f00b64072ed3ffe495b7712a71e3eb">ibitstream</a> (string file_name)</td></tr>
<tr class="separator:af5f00b64072ed3ffe495b7712a71e3eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3e91ecc9ff17eef98d72d44aec02eca" id="r_ae3e91ecc9ff17eef98d72d44aec02eca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classibitstream.html">ibitstream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibitstream.html#ae3e91ecc9ff17eef98d72d44aec02eca">operator&gt;&gt;</a> (unsigned int &amp;n)</td></tr>
<tr class="memdesc:ae3e91ecc9ff17eef98d72d44aec02eca"><td class="mdescLeft">&#160;</td><td class="mdescRight">reads an unsigned int from the input using Elias delta decoding and saves it in the reference given  <br /></td></tr>
<tr class="separator:ae3e91ecc9ff17eef98d72d44aec02eca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0264d01fa1211c4bb73f5de2bc68adbc" id="r_a0264d01fa1211c4bb73f5de2bc68adbc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classibitstream.html">ibitstream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibitstream.html#a0264d01fa1211c4bb73f5de2bc68adbc">operator&gt;&gt;</a> (mpz_class &amp;n)</td></tr>
<tr class="memdesc:a0264d01fa1211c4bb73f5de2bc68adbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">reads a nonnegative mpz_class integer using Elias delta decoding and stores in the reference given  <br /></td></tr>
<tr class="separator:a0264d01fa1211c4bb73f5de2bc68adbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d1bfd02f98f6af2ac4d80034b23e26d" id="r_a4d1bfd02f98f6af2ac4d80034b23e26d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibitstream.html#a4d1bfd02f98f6af2ac4d80034b23e26d">bin_inter_decode</a> (vector&lt; int &gt; &amp;a, int b)</td></tr>
<tr class="memdesc:a4d1bfd02f98f6af2ac4d80034b23e26d"><td class="mdescLeft">&#160;</td><td class="mdescRight">uses binary interpolative coding algorithm to decode for an array of increasing nonnegative integers. Caution: we do not sort the decoding vector for efficiency purposes and return elements in the order they were encoded (mid point first left subinterval then subinterval)  <br /></td></tr>
<tr class="separator:a4d1bfd02f98f6af2ac4d80034b23e26d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97983c20903c908fafb26e250bf9e812" id="r_a97983c20903c908fafb26e250bf9e812"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibitstream.html#a97983c20903c908fafb26e250bf9e812">bin_inter_decode</a> (vector&lt; int &gt; &amp;a, int i, int j, int low, int high)</td></tr>
<tr class="memdesc:a97983c20903c908fafb26e250bf9e812"><td class="mdescLeft">&#160;</td><td class="mdescRight">using bit interpolative coding algorithm to decode for a subinterval of an array  <br /></td></tr>
<tr class="separator:a97983c20903c908fafb26e250bf9e812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7b59600e58571b802d6d0dadf92d37a" id="r_aa7b59600e58571b802d6d0dadf92d37a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibitstream.html#aa7b59600e58571b802d6d0dadf92d37a">close</a> ()</td></tr>
<tr class="memdesc:aa7b59600e58571b802d6d0dadf92d37a"><td class="mdescLeft">&#160;</td><td class="mdescRight">closes the session by closing the input file  <br /></td></tr>
<tr class="separator:aa7b59600e58571b802d6d0dadf92d37a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a3ea2cdd0cf97820f0e1520c42e364308" id="r_a3ea2cdd0cf97820f0e1520c42e364308"><td class="memItemLeft" align="right" valign="top">FILE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibitstream.html#a3ea2cdd0cf97820f0e1520c42e364308">f</a></td></tr>
<tr class="memdesc:a3ea2cdd0cf97820f0e1520c42e364308"><td class="mdescLeft">&#160;</td><td class="mdescRight">pointer to input binary file  <br /></td></tr>
<tr class="separator:a3ea2cdd0cf97820f0e1520c42e364308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73f0b24d3d4402369f1abbb43f7f70ef" id="r_a73f0b24d3d4402369f1abbb43f7f70ef"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibitstream.html#a73f0b24d3d4402369f1abbb43f7f70ef">buffer</a></td></tr>
<tr class="memdesc:a73f0b24d3d4402369f1abbb43f7f70ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">the last chunk read from the input  <br /></td></tr>
<tr class="separator:a73f0b24d3d4402369f1abbb43f7f70ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48cd41991b6c29ea5120b53873a72a70" id="r_a48cd41991b6c29ea5120b53873a72a70"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibitstream.html#a48cd41991b6c29ea5120b53873a72a70">head_mask</a></td></tr>
<tr class="memdesc:a48cd41991b6c29ea5120b53873a72a70"><td class="mdescLeft">&#160;</td><td class="mdescRight">the place of the head bit in buffer, represented in terms of mask. So if we are in the LSB, head_mask is one, if we are in two bit left of LSB, this is 4 so on. When this is zero, it means the buffer is expired and we should probably read one more chunk from the input file  <br /></td></tr>
<tr class="separator:a48cd41991b6c29ea5120b53873a72a70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b96359ac1534a5565e6e9b0cc53a0b3" id="r_a7b96359ac1534a5565e6e9b0cc53a0b3"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibitstream.html#a7b96359ac1534a5565e6e9b0cc53a0b3">head_place</a></td></tr>
<tr class="memdesc:a7b96359ac1534a5565e6e9b0cc53a0b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">the place of head represented in terms of integer, LSB is 1, left of LSB is 2, 2 left of LSB is 3 and so on. head_place is effectively the number of unread bits remaining in the buffer.  <br /></td></tr>
<tr class="separator:a7b96359ac1534a5565e6e9b0cc53a0b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>deals with reading bit streams from binary files, this is the reverse of obitstream </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af5f00b64072ed3ffe495b7712a71e3eb" name="af5f00b64072ed3ffe495b7712a71e3eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5f00b64072ed3ffe495b7712a71e3eb">&#9670;&#160;</a></span>ibitstream()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ibitstream::ibitstream </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>file_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  142</span>                              {</div>
<div class="line"><span class="lineno">  143</span>    <a class="code hl_variable" href="classibitstream.html#a3ea2cdd0cf97820f0e1520c42e364308">f</a> = fopen(file_name.c_str(), <span class="stringliteral">&quot;rb+&quot;</span>);</div>
<div class="line"><span class="lineno">  144</span>    <a class="code hl_variable" href="classibitstream.html#a73f0b24d3d4402369f1abbb43f7f70ef">buffer</a> =0;</div>
<div class="line"><span class="lineno">  145</span>    <a class="code hl_variable" href="classibitstream.html#a48cd41991b6c29ea5120b53873a72a70">head_mask</a> = 0;</div>
<div class="line"><span class="lineno">  146</span>    <a class="code hl_variable" href="classibitstream.html#a7b96359ac1534a5565e6e9b0cc53a0b3">head_place</a> = 0;</div>
<div class="line"><span class="lineno">  147</span>  }</div>
<div class="ttc" id="aclassibitstream_html_a3ea2cdd0cf97820f0e1520c42e364308"><div class="ttname"><a href="classibitstream.html#a3ea2cdd0cf97820f0e1520c42e364308">ibitstream::f</a></div><div class="ttdeci">FILE * f</div><div class="ttdoc">pointer to input binary file</div><div class="ttdef"><b>Definition</b> bitstream.h:120</div></div>
<div class="ttc" id="aclassibitstream_html_a48cd41991b6c29ea5120b53873a72a70"><div class="ttname"><a href="classibitstream.html#a48cd41991b6c29ea5120b53873a72a70">ibitstream::head_mask</a></div><div class="ttdeci">unsigned int head_mask</div><div class="ttdoc">the place of the head bit in buffer, represented in terms of mask. So if we are in the LSB,...</div><div class="ttdef"><b>Definition</b> bitstream.h:122</div></div>
<div class="ttc" id="aclassibitstream_html_a73f0b24d3d4402369f1abbb43f7f70ef"><div class="ttname"><a href="classibitstream.html#a73f0b24d3d4402369f1abbb43f7f70ef">ibitstream::buffer</a></div><div class="ttdeci">unsigned int buffer</div><div class="ttdoc">the last chunk read from the input</div><div class="ttdef"><b>Definition</b> bitstream.h:121</div></div>
<div class="ttc" id="aclassibitstream_html_a7b96359ac1534a5565e6e9b0cc53a0b3"><div class="ttname"><a href="classibitstream.html#a7b96359ac1534a5565e6e9b0cc53a0b3">ibitstream::head_place</a></div><div class="ttdeci">unsigned int head_place</div><div class="ttdoc">the place of head represented in terms of integer, LSB is 1, left of LSB is 2, 2 left of LSB is 3 and...</div><div class="ttdef"><b>Definition</b> bitstream.h:123</div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a4d1bfd02f98f6af2ac4d80034b23e26d" name="a4d1bfd02f98f6af2ac4d80034b23e26d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d1bfd02f98f6af2ac4d80034b23e26d">&#9670;&#160;</a></span>bin_inter_decode() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ibitstream::bin_inter_decode </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>uses binary interpolative coding algorithm to decode for an array of increasing nonnegative integers. Caution: we do not sort the decoding vector for efficiency purposes and return elements in the order they were encoded (mid point first left subinterval then subinterval) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>The number of bits used in the compression phase to encode size of array and lower and upper values (for graph compression, it is number of bits in the number of vertices). </td></tr>
    <tr><td class="paramname">a</td><td>reference to the array to add elements to. Here, we do not erase a, so you need to make sure a is empty. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="lineno">  549</span>                                                      {</div>
<div class="line"><span class="lineno">  550</span>  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> a_size;</div>
<div class="line"><span class="lineno">  551</span>  <span class="keywordflow">if</span> (b &gt; <a class="code hl_variable" href="bitstream_8h.html#afcadf5aa65c5159bfb96c4d82ebc0a5d">BIT_INT</a>)</div>
<div class="line"><span class="lineno">  552</span>    cerr &lt;&lt; <span class="stringliteral">&quot; 549 b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</div>
<div class="line"><span class="lineno">  553</span>  a_size = <a class="code hl_function" href="classibitstream.html#a2fdcaecf10fefa6942dcd5286a2696e0">read_bits</a>(b); <span class="comment">// size of the vector</span></div>
<div class="line"><span class="lineno">  554</span>  <span class="comment">//cout &lt;&lt; &quot;a_size &quot; &lt;&lt; a_size &lt;&lt; endl;</span></div>
<div class="line"><span class="lineno">  555</span> </div>
<div class="line"><span class="lineno">  556</span>  <span class="keywordflow">if</span> (a_size == 0)</div>
<div class="line"><span class="lineno">  557</span>    <span class="keywordflow">return</span>;</div>
<div class="line"><span class="lineno">  558</span>  <span class="keywordflow">if</span> (a_size == 1){</div>
<div class="line"><span class="lineno">  559</span>    <span class="keywordflow">if</span> (b &gt; <a class="code hl_variable" href="bitstream_8h.html#afcadf5aa65c5159bfb96c4d82ebc0a5d">BIT_INT</a>)</div>
<div class="line"><span class="lineno">  560</span>      cerr &lt;&lt; <span class="stringliteral">&quot; 557 b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</div>
<div class="line"><span class="lineno">  561</span>    a.push_back(<a class="code hl_function" href="classibitstream.html#a2fdcaecf10fefa6942dcd5286a2696e0">read_bits</a>(b));</div>
<div class="line"><span class="lineno">  562</span>    <span class="keywordflow">return</span>;</div>
<div class="line"><span class="lineno">  563</span>  }</div>
<div class="line"><span class="lineno">  564</span> </div>
<div class="line"><span class="lineno">  565</span>  <span class="comment">// read low and high values</span></div>
<div class="line"><span class="lineno">  566</span>  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> low, high;</div>
<div class="line"><span class="lineno">  567</span>  <span class="keywordflow">if</span> (b &gt; <a class="code hl_variable" href="bitstream_8h.html#afcadf5aa65c5159bfb96c4d82ebc0a5d">BIT_INT</a>)</div>
<div class="line"><span class="lineno">  568</span>    cerr &lt;&lt; <span class="stringliteral">&quot; 565 b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</div>
<div class="line"><span class="lineno">  569</span>  low = <a class="code hl_function" href="classibitstream.html#a2fdcaecf10fefa6942dcd5286a2696e0">read_bits</a>(b);</div>
<div class="line"><span class="lineno">  570</span>  high = <a class="code hl_function" href="classibitstream.html#a2fdcaecf10fefa6942dcd5286a2696e0">read_bits</a>(b);</div>
<div class="line"><span class="lineno">  571</span>  <span class="comment">//cout &lt;&lt; &quot; low &quot; &lt;&lt; low &lt;&lt; &quot; high &quot; &lt;&lt; high &lt;&lt; endl;</span></div>
<div class="line"><span class="lineno">  572</span>  <a class="code hl_function" href="classibitstream.html#a4d1bfd02f98f6af2ac4d80034b23e26d">bin_inter_decode</a>(a, 0, a_size - 1, low, high);</div>
<div class="line"><span class="lineno">  573</span>  <span class="keywordflow">return</span>;</div>
<div class="line"><span class="lineno">  574</span>}</div>
<div class="ttc" id="abitstream_8h_html_afcadf5aa65c5159bfb96c4d82ebc0a5d"><div class="ttname"><a href="bitstream_8h.html#afcadf5aa65c5159bfb96c4d82ebc0a5d">BIT_INT</a></div><div class="ttdeci">const unsigned int BIT_INT</div><div class="ttdef"><b>Definition</b> bitstream.h:13</div></div>
<div class="ttc" id="aclassibitstream_html_a2fdcaecf10fefa6942dcd5286a2696e0"><div class="ttname"><a href="classibitstream.html#a2fdcaecf10fefa6942dcd5286a2696e0">ibitstream::read_bits</a></div><div class="ttdeci">unsigned int read_bits(unsigned int k)</div><div class="ttdoc">read k bits from the input, interpret it as integer (first bit read is MSB) and return its value....</div><div class="ttdef"><b>Definition</b> bitstream.cpp:336</div></div>
<div class="ttc" id="aclassibitstream_html_a4d1bfd02f98f6af2ac4d80034b23e26d"><div class="ttname"><a href="classibitstream.html#a4d1bfd02f98f6af2ac4d80034b23e26d">ibitstream::bin_inter_decode</a></div><div class="ttdeci">void bin_inter_decode(vector&lt; int &gt; &amp;a, int b)</div><div class="ttdoc">uses binary interpolative coding algorithm to decode for an array of increasing nonnegative integers....</div><div class="ttdef"><b>Definition</b> bitstream.cpp:549</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a97983c20903c908fafb26e250bf9e812" name="a97983c20903c908fafb26e250bf9e812"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97983c20903c908fafb26e250bf9e812">&#9670;&#160;</a></span>bin_inter_decode() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ibitstream::bin_inter_decode </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>high</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>using bit interpolative coding algorithm to decode for a subinterval of an array </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>reference to the array to add elements to </td></tr>
    <tr><td class="paramname">i,j</td><td>the endpoints of the interval to be decoded (with respect to the encoded array) </td></tr>
    <tr><td class="paramname">low</td><td>lower bound on the elements of the encoded array in the interval [i,j]n </td></tr>
    <tr><td class="paramname">high</td><td>lower bound on the elements of the encoded array in the interval [i,j] </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="lineno">  584</span>                                                                                {</div>
<div class="line"><span class="lineno">  585</span>  <span class="comment">// cout &lt;&lt; &quot; i &quot; &lt;&lt; i &lt;&lt; &quot; j &quot; &lt;&lt; j &lt;&lt; &quot; low &quot; &lt;&lt; low &lt;&lt; &quot; high &quot; &lt;&lt; high &lt;&lt; endl;</span></div>
<div class="line"><span class="lineno">  586</span>  <span class="keywordflow">if</span> (j &lt; i)</div>
<div class="line"><span class="lineno">  587</span>    <span class="keywordflow">return</span>;</div>
<div class="line"><span class="lineno">  588</span>  <span class="keywordflow">if</span> (i==j){</div>
<div class="line"><span class="lineno">  589</span>    <span class="keywordflow">if</span>(low == high){</div>
<div class="line"><span class="lineno">  590</span>      a.push_back(low); <span class="comment">// the element must be low = high, no other change, nothing to read</span></div>
<div class="line"><span class="lineno">  591</span>    }<span class="keywordflow">else</span>{</div>
<div class="line"><span class="lineno">  592</span>      <span class="keywordflow">if</span> (<a class="code hl_function" href="bitstream_8h.html#a9dfce6f51e3febb3973aa3b16c2fecb4">nu_bits</a>(high-low) &gt; <a class="code hl_variable" href="bitstream_8h.html#afcadf5aa65c5159bfb96c4d82ebc0a5d">BIT_INT</a>)</div>
<div class="line"><span class="lineno">  593</span>        cerr &lt;&lt; <span class="stringliteral">&quot; 590 nu_bits(high-low) = &quot;</span> &lt;&lt; <a class="code hl_function" href="bitstream_8h.html#a9dfce6f51e3febb3973aa3b16c2fecb4">nu_bits</a>(high-low) &lt;&lt; endl;</div>
<div class="line"><span class="lineno">  594</span>      a.push_back(<a class="code hl_function" href="classibitstream.html#a2fdcaecf10fefa6942dcd5286a2696e0">read_bits</a>(<a class="code hl_function" href="bitstream_8h.html#a9dfce6f51e3febb3973aa3b16c2fecb4">nu_bits</a>(high-low)) + low);</div>
<div class="line"><span class="lineno">  595</span>    }</div>
<div class="line"><span class="lineno">  596</span>    <span class="keywordflow">return</span>;</div>
<div class="line"><span class="lineno">  597</span>  }</div>
<div class="line"><span class="lineno">  598</span> </div>
<div class="line"><span class="lineno">  599</span>  <span class="keywordtype">int</span> m = (i+j)/2;</div>
<div class="line"><span class="lineno">  600</span>  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> L = low + m - i; <span class="comment">// lower bound on a[m]</span></div>
<div class="line"><span class="lineno">  601</span>  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> H = high - (j - m); <span class="comment">// upper bound on a[m]</span></div>
<div class="line"><span class="lineno">  602</span>  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> a_m; <span class="comment">// the value of the intermediate point</span></div>
<div class="line"><span class="lineno">  603</span>  <span class="keywordflow">if</span> (L == H){</div>
<div class="line"><span class="lineno">  604</span>    a_m = L; <span class="comment">// there will be no bits to read</span></div>
<div class="line"><span class="lineno">  605</span>  }<span class="keywordflow">else</span>{</div>
<div class="line"><span class="lineno">  606</span>    <span class="keywordflow">if</span> (<a class="code hl_function" href="bitstream_8h.html#a9dfce6f51e3febb3973aa3b16c2fecb4">nu_bits</a>(H-L) &gt; <a class="code hl_variable" href="bitstream_8h.html#afcadf5aa65c5159bfb96c4d82ebc0a5d">BIT_INT</a>)</div>
<div class="line"><span class="lineno">  607</span>      cerr &lt;&lt; <span class="stringliteral">&quot; 604 nu_bits(H-L) = &quot;</span> &lt;&lt; <a class="code hl_function" href="bitstream_8h.html#a9dfce6f51e3febb3973aa3b16c2fecb4">nu_bits</a>(H-L) &lt;&lt; endl;</div>
<div class="line"><span class="lineno">  608</span>    a_m = <a class="code hl_function" href="classibitstream.html#a2fdcaecf10fefa6942dcd5286a2696e0">read_bits</a>(<a class="code hl_function" href="bitstream_8h.html#a9dfce6f51e3febb3973aa3b16c2fecb4">nu_bits</a>(H-L)) + L;</div>
<div class="line"><span class="lineno">  609</span>  }</div>
<div class="line"><span class="lineno">  610</span>  </div>
<div class="line"><span class="lineno">  611</span>  a.push_back(a_m);</div>
<div class="line"><span class="lineno">  612</span> </div>
<div class="line"><span class="lineno">  613</span>  <a class="code hl_function" href="classibitstream.html#a4d1bfd02f98f6af2ac4d80034b23e26d">bin_inter_decode</a>(a, i, m-1, low, a_m - 1);</div>
<div class="line"><span class="lineno">  614</span>  <a class="code hl_function" href="classibitstream.html#a4d1bfd02f98f6af2ac4d80034b23e26d">bin_inter_decode</a>(a, m+1, j, a_m + 1, high);</div>
<div class="line"><span class="lineno">  615</span>}</div>
<div class="ttc" id="abitstream_8h_html_a9dfce6f51e3febb3973aa3b16c2fecb4"><div class="ttname"><a href="bitstream_8h.html#a9dfce6f51e3febb3973aa3b16c2fecb4">nu_bits</a></div><div class="ttdeci">unsigned int nu_bits(unsigned int n)</div><div class="ttdoc">returns number of bits in a positive integer n, e.g. 3 has 3 bits, 12 has 4 bits, and 0 has 0 bits.</div><div class="ttdef"><b>Definition</b> bitstream.cpp:635</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aa7b59600e58571b802d6d0dadf92d37a" name="aa7b59600e58571b802d6d0dadf92d37a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7b59600e58571b802d6d0dadf92d37a">&#9670;&#160;</a></span>close()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ibitstream::close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>closes the session by closing the input file </p>
<div class="fragment"><div class="line"><span class="lineno">  165</span>{fclose(<a class="code hl_variable" href="classibitstream.html#a3ea2cdd0cf97820f0e1520c42e364308">f</a>);}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a0264d01fa1211c4bb73f5de2bc68adbc" name="a0264d01fa1211c4bb73f5de2bc68adbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0264d01fa1211c4bb73f5de2bc68adbc">&#9670;&#160;</a></span>operator&gt;&gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classibitstream.html">ibitstream</a> &amp; ibitstream::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">mpz_class &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>reads a nonnegative mpz_class integer using Elias delta decoding and stores in the reference given </p>
<div class="fragment"><div class="line"><span class="lineno">  489</span>                                                {</div>
<div class="line"><span class="lineno">  490</span>  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> L = 0;</div>
<div class="line"><span class="lineno">  491</span>  <span class="comment">//cout &lt;&lt; &quot;head_place &quot; &lt;&lt; head_place &lt;&lt; endl;</span></div>
<div class="line"><span class="lineno">  492</span>  <span class="comment">//cout &lt;&lt; &quot;head_mask  &quot; &lt;&lt; head_mask &lt;&lt; endl;</span></div>
<div class="line"><span class="lineno">  493</span>  <span class="keywordflow">while</span> (!<a class="code hl_function" href="classibitstream.html#a895239acf7179f6778388c39c97643e4">read_bit</a>()){</div>
<div class="line"><span class="lineno">  494</span>    <span class="comment">// read until reach one</span></div>
<div class="line"><span class="lineno">  495</span>    L++;</div>
<div class="line"><span class="lineno">  496</span>  }</div>
<div class="line"><span class="lineno">  497</span> </div>
<div class="line"><span class="lineno">  498</span>  <span class="comment">//cout &lt;&lt; &quot; L = &quot; &lt;&lt; L &lt;&lt; endl;</span></div>
<div class="line"><span class="lineno">  499</span>  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N;</div>
<div class="line"><span class="lineno">  500</span>  <span class="keywordflow">if</span> (L == 0){<span class="comment">// special case, avoid going over further calculations</span></div>
<div class="line"><span class="lineno">  501</span>    n = 0; <span class="comment">// we had subtracted one when encoding </span></div>
<div class="line"><span class="lineno">  502</span>    <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line"><span class="lineno">  503</span>  }</div>
<div class="line"><span class="lineno">  504</span> </div>
<div class="line"><span class="lineno">  505</span>  <span class="keywordflow">if</span> (L &gt; <a class="code hl_variable" href="bitstream_8h.html#afcadf5aa65c5159bfb96c4d82ebc0a5d">BIT_INT</a>)</div>
<div class="line"><span class="lineno">  506</span>    cerr &lt;&lt; <span class="stringliteral">&quot; 503 L = &quot;</span> &lt;&lt; L &lt;&lt; endl;</div>
<div class="line"><span class="lineno">  507</span>  N = <a class="code hl_function" href="classibitstream.html#a2fdcaecf10fefa6942dcd5286a2696e0">read_bits</a>(L); <span class="comment">// read L digits</span></div>
<div class="line"><span class="lineno">  508</span>  </div>
<div class="line"><span class="lineno">  509</span>  N += (1&lt;&lt;L); <span class="comment">// we must add 2^L</span></div>
<div class="line"><span class="lineno">  510</span>  N --; <span class="comment">// this was N + 1</span></div>
<div class="line"><span class="lineno">  511</span> </div>
<div class="line"><span class="lineno">  512</span>  <span class="comment">// we must read N bits and form n based on that</span></div>
<div class="line"><span class="lineno">  513</span> </div>
<div class="line"><span class="lineno">  514</span>  <a class="code hl_class" href="classbit__pipe.html">bit_pipe</a> B;</div>
<div class="line"><span class="lineno">  515</span>  <span class="comment">//cout &lt;&lt; &quot; N &quot; &lt;&lt; N &lt;&lt; endl;</span></div>
<div class="line"><span class="lineno">  516</span>  <a class="code hl_function" href="classibitstream.html#a2fdcaecf10fefa6942dcd5286a2696e0">read_bits</a>(N, B);</div>
<div class="line"><span class="lineno">  517</span>  <span class="comment">//cout &lt;&lt; &quot; B first &quot; &lt;&lt; B &lt;&lt; endl;</span></div>
<div class="line"><span class="lineno">  518</span>  <span class="comment">// we should add a leading 1 to B</span></div>
<div class="line"><span class="lineno">  519</span>  <span class="comment">// in order to do so, we should consider 2 cases:</span></div>
<div class="line"><span class="lineno">  520</span>  <span class="keywordflow">if</span> (N % <a class="code hl_variable" href="bitstream_8h.html#afcadf5aa65c5159bfb96c4d82ebc0a5d">BIT_INT</a> == 0){</div>
<div class="line"><span class="lineno">  521</span>    <span class="comment">// this is the tricky case, since B now contains full chunks and there is no room to add the leading 1</span></div>
<div class="line"><span class="lineno">  522</span>    <span class="comment">// so we need to insert a chunk at the beginning and place the leading bit there</span></div>
<div class="line"><span class="lineno">  523</span>    <span class="comment">// since the leading bit will be in the rightmost bit in this case, the value of the initial chunk is 1 in this case</span></div>
<div class="line"><span class="lineno">  524</span>    B.<a class="code hl_variable" href="classbit__pipe.html#a86f38af1e9736b053728033490476b50">bits</a>.insert(B.<a class="code hl_variable" href="classbit__pipe.html#a86f38af1e9736b053728033490476b50">bits</a>.begin(), 1);</div>
<div class="line"><span class="lineno">  525</span>  }<span class="keywordflow">else</span>{</div>
<div class="line"><span class="lineno">  526</span>    <span class="comment">// in this case, the lading bit will be placed in the first chunk of B</span></div>
<div class="line"><span class="lineno">  527</span>    B.<a class="code hl_variable" href="classbit__pipe.html#a86f38af1e9736b053728033490476b50">bits</a>[0] |= (1 &lt;&lt; (N % <a class="code hl_variable" href="bitstream_8h.html#afcadf5aa65c5159bfb96c4d82ebc0a5d">BIT_INT</a>));</div>
<div class="line"><span class="lineno">  528</span>  }</div>
<div class="line"><span class="lineno">  529</span>  <span class="comment">//cout &lt;&lt; &quot; B &quot; &lt;&lt; B &lt;&lt; endl;</span></div>
<div class="line"><span class="lineno">  530</span>  <span class="comment">//cout &lt;&lt; B.bits[0] &lt;&lt; endl;</span></div>
<div class="line"><span class="lineno">  531</span> </div>
<div class="line"><span class="lineno">  532</span>  <span class="comment">// construct the mpz_clas</span></div>
<div class="line"><span class="lineno">  533</span>  mpz_import(n.get_mpz_t(),</div>
<div class="line"><span class="lineno">  534</span>             B.<a class="code hl_variable" href="classbit__pipe.html#a86f38af1e9736b053728033490476b50">bits</a>.size(), <span class="comment">// the number of words</span></div>
<div class="line"><span class="lineno">  535</span>             1, <span class="comment">// order: 1 means first significant word first</span></div>
<div class="line"><span class="lineno">  536</span>             <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>), <span class="comment">// each word is this many bytes</span></div>
<div class="line"><span class="lineno">  537</span>             0, <span class="comment">// endian can be 1 for most significant byte first, -1 for least significant first, or 0 for the native endianness of the host CPU.</span></div>
<div class="line"><span class="lineno">  538</span>             0, <span class="comment">// nails</span></div>
<div class="line"><span class="lineno">  539</span>             &amp;B.<a class="code hl_variable" href="classbit__pipe.html#a86f38af1e9736b053728033490476b50">bits</a>[0]); <span class="comment">//&amp;B.bits[0]);</span></div>
<div class="line"><span class="lineno">  540</span> </div>
<div class="line"><span class="lineno">  541</span>  n --; <span class="comment">// when encoding, we added 1 to make sure it is positive</span></div>
<div class="line"><span class="lineno">  542</span>  <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line"><span class="lineno">  543</span>}</div>
<div class="ttc" id="aclassbit__pipe_html"><div class="ttname"><a href="classbit__pipe.html">bit_pipe</a></div><div class="ttdoc">A sequence of arbitrary number of bits.</div><div class="ttdef"><b>Definition</b> bitstream.h:23</div></div>
<div class="ttc" id="aclassbit__pipe_html_a86f38af1e9736b053728033490476b50"><div class="ttname"><a href="classbit__pipe.html#a86f38af1e9736b053728033490476b50">bit_pipe::bits</a></div><div class="ttdeci">vector&lt; unsigned int &gt; bits</div><div class="ttdoc">a vector of chunks, each of size 4 bytes. This represents an arbitrary sequence of bits</div><div class="ttdef"><b>Definition</b> bitstream.h:25</div></div>
<div class="ttc" id="aclassibitstream_html_a895239acf7179f6778388c39c97643e4"><div class="ttname"><a href="classibitstream.html#a895239acf7179f6778388c39c97643e4">ibitstream::read_bit</a></div><div class="ttdeci">bool read_bit()</div><div class="ttdoc">read one bit from input and return true if its value is 1 and false otherwise.</div><div class="ttdef"><b>Definition</b> bitstream.cpp:618</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ae3e91ecc9ff17eef98d72d44aec02eca" name="ae3e91ecc9ff17eef98d72d44aec02eca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3e91ecc9ff17eef98d72d44aec02eca">&#9670;&#160;</a></span>operator&gt;&gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classibitstream.html">ibitstream</a> &amp; ibitstream::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>reads an unsigned int from the input using Elias delta decoding and saves it in the reference given </p>
<div class="fragment"><div class="line"><span class="lineno">  455</span>                                                   {</div>
<div class="line"><span class="lineno">  456</span>  <span class="comment">// implement Elias delta decoding</span></div>
<div class="line"><span class="lineno">  457</span>  <span class="comment">//bitset&lt;32&gt; B(buffer);</span></div>
<div class="line"><span class="lineno">  458</span>  <span class="comment">//cerr &lt;&lt; &quot; buffer &quot; &lt;&lt; B &lt;&lt; endl;</span></div>
<div class="line"><span class="lineno">  459</span>  <span class="comment">//cerr &lt;&lt; &quot; head &quot; &lt;&lt; bitset&lt;32&gt;(head_mask) &lt;&lt; endl;</span></div>
<div class="line"><span class="lineno">  460</span>  <span class="comment">//cerr &lt;&lt; &quot; head position &quot; &lt;&lt; head_place &lt;&lt; endl;</span></div>
<div class="line"><span class="lineno">  461</span>  </div>
<div class="line"><span class="lineno">  462</span>  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> L = 0;</div>
<div class="line"><span class="lineno">  463</span>  <span class="keywordflow">while</span> (!<a class="code hl_function" href="classibitstream.html#a895239acf7179f6778388c39c97643e4">read_bit</a>()){</div>
<div class="line"><span class="lineno">  464</span>    <span class="comment">// read until reach one</span></div>
<div class="line"><span class="lineno">  465</span>    L++;</div>
<div class="line"><span class="lineno">  466</span>  }</div>
<div class="line"><span class="lineno">  467</span>  <span class="comment">//cerr &lt;&lt; &quot; L &quot; &lt;&lt; L &lt;&lt; endl;</span></div>
<div class="line"><span class="lineno">  468</span>  </div>
<div class="line"><span class="lineno">  469</span>  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N;</div>
<div class="line"><span class="lineno">  470</span>  <span class="keywordflow">if</span> (L == 0){<span class="comment">// special case, avoid going over further calculations</span></div>
<div class="line"><span class="lineno">  471</span>    n = 0; <span class="comment">// we had subtracted one when encoding </span></div>
<div class="line"><span class="lineno">  472</span>    <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line"><span class="lineno">  473</span>  }</div>
<div class="line"><span class="lineno">  474</span>  <span class="keywordflow">if</span> (L &gt; <a class="code hl_variable" href="bitstream_8h.html#afcadf5aa65c5159bfb96c4d82ebc0a5d">BIT_INT</a>)</div>
<div class="line"><span class="lineno">  475</span>    cerr &lt;&lt; <span class="stringliteral">&quot; 472 L = &quot;</span> &lt;&lt; L &lt;&lt; endl;</div>
<div class="line"><span class="lineno">  476</span>  N = <a class="code hl_function" href="classibitstream.html#a2fdcaecf10fefa6942dcd5286a2696e0">read_bits</a>(L); <span class="comment">// read L digits</span></div>
<div class="line"><span class="lineno">  477</span>  </div>
<div class="line"><span class="lineno">  478</span>  N += (1&lt;&lt;L); <span class="comment">// we must add 2^L</span></div>
<div class="line"><span class="lineno">  479</span>  N --; <span class="comment">// this was N + 1</span></div>
<div class="line"><span class="lineno">  480</span> </div>
<div class="line"><span class="lineno">  481</span>  <span class="keywordflow">if</span> (N &gt; <a class="code hl_variable" href="bitstream_8h.html#afcadf5aa65c5159bfb96c4d82ebc0a5d">BIT_INT</a>)</div>
<div class="line"><span class="lineno">  482</span>    cerr &lt;&lt; <span class="stringliteral">&quot; 479 N = &quot;</span> &lt;&lt; N &lt;&lt; <span class="stringliteral">&quot; L = &quot;</span> &lt;&lt; L &lt;&lt; endl;</div>
<div class="line"><span class="lineno">  483</span>  n = <a class="code hl_function" href="classibitstream.html#a2fdcaecf10fefa6942dcd5286a2696e0">read_bits</a>(N); <span class="comment">// read N digits</span></div>
<div class="line"><span class="lineno">  484</span>  n += (1 &lt;&lt; N); <span class="comment">// we must add 2^N</span></div>
<div class="line"><span class="lineno">  485</span>  n --; <span class="comment">// when we encoded, in order to get a positive integer, we added one, now we subtract one</span></div>
<div class="line"><span class="lineno">  486</span>  <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line"><span class="lineno">  487</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a895239acf7179f6778388c39c97643e4" name="a895239acf7179f6778388c39c97643e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a895239acf7179f6778388c39c97643e4">&#9670;&#160;</a></span>read_bit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ibitstream::read_bit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>read one bit from input and return true if its value is 1 and false otherwise. </p>
<div class="fragment"><div class="line"><span class="lineno">  618</span>                         {</div>
<div class="line"><span class="lineno">  619</span>  <span class="keywordflow">if</span> (<a class="code hl_variable" href="classibitstream.html#a48cd41991b6c29ea5120b53873a72a70">head_mask</a> == 0){ <span class="comment">// nothing is in buffer</span></div>
<div class="line"><span class="lineno">  620</span>    <span class="comment">//cerr &lt;&lt; &quot; read a chunk &quot; &lt;&lt; endl;</span></div>
<div class="line"><span class="lineno">  621</span>    <a class="code hl_function" href="classibitstream.html#ac62c26004436d83f337f4aeba0895e20">read_chunk</a>();</div>
<div class="line"><span class="lineno">  622</span>  }</div>
<div class="line"><span class="lineno">  623</span>  <span class="keywordtype">bool</span> ans = <a class="code hl_variable" href="classibitstream.html#a48cd41991b6c29ea5120b53873a72a70">head_mask</a> &amp; <a class="code hl_variable" href="classibitstream.html#a73f0b24d3d4402369f1abbb43f7f70ef">buffer</a>; <span class="comment">// look at the value of buffer at the bit where the head_mask is pointing to</span></div>
<div class="line"><span class="lineno">  624</span>  <a class="code hl_variable" href="classibitstream.html#a48cd41991b6c29ea5120b53873a72a70">head_mask</a> &gt;&gt;= 1; <span class="comment">// go one bit to the right</span></div>
<div class="line"><span class="lineno">  625</span>  <a class="code hl_variable" href="classibitstream.html#a7b96359ac1534a5565e6e9b0cc53a0b3">head_place</a> --;</div>
<div class="line"><span class="lineno">  626</span>  <span class="comment">//cerr &lt;&lt; &quot; read bit &quot; &lt;&lt; ans &lt;&lt; endl;</span></div>
<div class="line"><span class="lineno">  627</span>  <span class="keywordflow">return</span> ans;</div>
<div class="line"><span class="lineno">  628</span>}</div>
<div class="ttc" id="aclassibitstream_html_ac62c26004436d83f337f4aeba0895e20"><div class="ttname"><a href="classibitstream.html#ac62c26004436d83f337f4aeba0895e20">ibitstream::read_chunk</a></div><div class="ttdeci">void read_chunk()</div><div class="ttdoc">reads one chunk (4 bytes) from the input file and stores it in buffer</div><div class="ttdef"><b>Definition</b> bitstream.cpp:328</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a4bb7a698ab44c1e2fe21b4daa880bd6c" name="a4bb7a698ab44c1e2fe21b4daa880bd6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bb7a698ab44c1e2fe21b4daa880bd6c">&#9670;&#160;</a></span>read_bits() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ibitstream::read_bits </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbit__pipe.html">bit_pipe</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>reads k bits from input and stores in the given <a class="el" href="classbit__pipe.html" title="A sequence of arbitrary number of bits.">bit_pipe</a>. \(k \geq 1\) is arbitrary. The bits are stored in the <a class="el" href="classbit__pipe.html" title="A sequence of arbitrary number of bits.">bit_pipe</a> so that can be interpreted as integer (e.g. mpz_class) so the LSB is located in the rightmost bit of the rightmost chunk (unlike the usual <a class="el" href="classbit__pipe.html" title="A sequence of arbitrary number of bits.">bit_pipe</a> situation). We assume that the B given here is an empty <a class="el" href="classbit__pipe.html" title="A sequence of arbitrary number of bits.">bit_pipe</a> </p>
<div class="fragment"><div class="line"><span class="lineno">  438</span>                                            {</div>
<div class="line"><span class="lineno">  439</span>  <span class="comment">//cerr &lt;&lt; &quot; read_bits &quot; &lt;&lt; k &lt;&lt; endl;</span></div>
<div class="line"><span class="lineno">  440</span>  <span class="comment">// assumption: B is empty bit_pipe</span></div>
<div class="line"><span class="lineno">  441</span>  <span class="keywordflow">if</span> (B.<a class="code hl_variable" href="classbit__pipe.html#a86f38af1e9736b053728033490476b50">bits</a>.size() != 0 or B.<a class="code hl_variable" href="classbit__pipe.html#a0f3e84b02751803adaab499b5dad86fe">last_bits</a> != 0){</div>
<div class="line"><span class="lineno">  442</span>    cerr &lt;&lt; <span class="stringliteral">&quot; ERROR: ibitstream::read_bits(int k, bit_pipe&amp; B) must be called with an empty bit_pipe, a nonempty bitpipe is given with B.bits.size() = &quot;</span> &lt;&lt; B.<a class="code hl_variable" href="classbit__pipe.html#a86f38af1e9736b053728033490476b50">bits</a>.size() &lt;&lt; endl;</div>
<div class="line"><span class="lineno">  443</span>  }</div>
<div class="line"><span class="lineno">  444</span>  <a class="code hl_function" href="classibitstream.html#acec2e9efa21551ce8db784f5b0bbd1b5">read_bits_append</a>(k, B);</div>
<div class="line"><span class="lineno">  445</span>  <span class="comment">// there might be a few zero chunks at the beginning of B which are redundant, we remove them here</span></div>
<div class="line"><span class="lineno">  446</span>  <span class="comment">// the number of nonzero chunks is exactly the floor of k / BIT_INT</span></div>
<div class="line"><span class="lineno">  447</span>  <span class="keywordtype">int</span> nonzero_chunks = k / <a class="code hl_variable" href="bitstream_8h.html#afcadf5aa65c5159bfb96c4d82ebc0a5d">BIT_INT</a>;</div>
<div class="line"><span class="lineno">  448</span>  <span class="keywordflow">if</span> (k % <a class="code hl_variable" href="bitstream_8h.html#afcadf5aa65c5159bfb96c4d82ebc0a5d">BIT_INT</a> != 0)</div>
<div class="line"><span class="lineno">  449</span>    nonzero_chunks ++; <span class="comment">// take the floor</span></div>
<div class="line"><span class="lineno">  450</span>  <span class="comment">//cerr &lt;&lt; &quot; nonzero_chunks &quot; &lt;&lt; nonzero_chunks &lt;&lt; endl;</span></div>
<div class="line"><span class="lineno">  451</span>  <span class="keywordflow">if</span> (nonzero_chunks &lt; B.<a class="code hl_variable" href="classbit__pipe.html#a86f38af1e9736b053728033490476b50">bits</a>.size())</div>
<div class="line"><span class="lineno">  452</span>    B.<a class="code hl_variable" href="classbit__pipe.html#a86f38af1e9736b053728033490476b50">bits</a>.erase(B.<a class="code hl_variable" href="classbit__pipe.html#a86f38af1e9736b053728033490476b50">bits</a>.begin(), B.<a class="code hl_variable" href="classbit__pipe.html#a86f38af1e9736b053728033490476b50">bits</a>.begin() + B.<a class="code hl_variable" href="classbit__pipe.html#a86f38af1e9736b053728033490476b50">bits</a>.size() - nonzero_chunks);</div>
<div class="line"><span class="lineno">  453</span>}</div>
<div class="ttc" id="aclassbit__pipe_html_a0f3e84b02751803adaab499b5dad86fe"><div class="ttname"><a href="classbit__pipe.html#a0f3e84b02751803adaab499b5dad86fe">bit_pipe::last_bits</a></div><div class="ttdeci">int last_bits</div><div class="ttdoc">the number of bits in the last chunk (the last chunk starts from MSB, so the BIT_INT - last_bits many...</div><div class="ttdef"><b>Definition</b> bitstream.h:26</div></div>
<div class="ttc" id="aclassibitstream_html_acec2e9efa21551ce8db784f5b0bbd1b5"><div class="ttname"><a href="classibitstream.html#acec2e9efa21551ce8db784f5b0bbd1b5">ibitstream::read_bits_append</a></div><div class="ttdeci">void read_bits_append(int k, bit_pipe &amp;B)</div><div class="ttdoc">similar to read_bits, but B does not have to be empty and the result will be appended to B (this is u...</div><div class="ttdef"><b>Definition</b> bitstream.cpp:384</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a2fdcaecf10fefa6942dcd5286a2696e0" name="a2fdcaecf10fefa6942dcd5286a2696e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fdcaecf10fefa6942dcd5286a2696e0">&#9670;&#160;</a></span>read_bits() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ibitstream::read_bits </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>read k bits from the input, interpret it as integer (first bit read is MSB) and return its value. Here, k must be in the range 1 &lt;= k &lt;= BIT_INT </p>
<div class="fragment"><div class="line"><span class="lineno">  336</span>                                                {</div>
<div class="line"><span class="lineno">  337</span> </div>
<div class="line"><span class="lineno">  338</span>  <span class="comment">//cerr &lt;&lt; &quot; read bits with k = &quot; &lt;&lt; k &lt;&lt; endl;</span></div>
<div class="line"><span class="lineno">  339</span>  <span class="keywordflow">if</span> (k &lt; 1 or k &gt; <a class="code hl_variable" href="bitstream_8h.html#afcadf5aa65c5159bfb96c4d82ebc0a5d">BIT_INT</a>){</div>
<div class="line"><span class="lineno">  340</span>    cerr &lt;&lt; <span class="stringliteral">&quot;ERROR: ibitstream::read_bits called with k out of range, k = &quot;</span> &lt;&lt; k &lt;&lt; endl;</div>
<div class="line"><span class="lineno">  341</span>  }</div>
<div class="line"><span class="lineno">  342</span>  <span class="keywordflow">if</span> (<a class="code hl_variable" href="classibitstream.html#a7b96359ac1534a5565e6e9b0cc53a0b3">head_place</a> == 0)<span class="comment">// no bits left</span></div>
<div class="line"><span class="lineno">  343</span>    <a class="code hl_function" href="classibitstream.html#ac62c26004436d83f337f4aeba0895e20">read_chunk</a>();</div>
<div class="line"><span class="lineno">  344</span>  <span class="keywordflow">if</span> (<a class="code hl_variable" href="classibitstream.html#a7b96359ac1534a5565e6e9b0cc53a0b3">head_place</a> &gt;= k){ <span class="comment">// head_place is effectively the number of unread bits remaining in the buffer</span></div>
<div class="line"><span class="lineno">  345</span>    <span class="comment">//cerr &lt;&lt; &quot; head_place &gt;= k head_mask = &quot; &lt;&lt; head_mask &lt;&lt; &quot; head_place = &quot; &lt;&lt; head_place &lt;&lt; endl;</span></div>
<div class="line"><span class="lineno">  346</span>    <span class="comment">// there are enough number of bits in the current buffer to read</span></div>
<div class="line"><span class="lineno">  347</span>    <span class="comment">// mask the input</span></div>
<div class="line"><span class="lineno">  348</span>    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> mask = <a class="code hl_function" href="bitstream_8h.html#a6364b017a9400a38f7a994376bb3ebee">mask_gen</a>(k); <span class="comment">// k ones</span></div>
<div class="line"><span class="lineno">  349</span>    <span class="comment">// now we should shift mask to start at head_place</span></div>
<div class="line"><span class="lineno">  350</span>    mask &lt;&lt;= (<a class="code hl_variable" href="classibitstream.html#a7b96359ac1534a5565e6e9b0cc53a0b3">head_place</a> - k);</div>
<div class="line"><span class="lineno">  351</span>    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ans = <a class="code hl_variable" href="classibitstream.html#a73f0b24d3d4402369f1abbb43f7f70ef">buffer</a> &amp; mask; <span class="comment">// mask out the corresponding bits</span></div>
<div class="line"><span class="lineno">  352</span>    ans &gt;&gt;= (<a class="code hl_variable" href="classibitstream.html#a7b96359ac1534a5565e6e9b0cc53a0b3">head_place</a> - k); <span class="comment">// bring it back to LSB</span></div>
<div class="line"><span class="lineno">  353</span> </div>
<div class="line"><span class="lineno">  354</span>    <span class="comment">// we need to shift head k bits to the right</span></div>
<div class="line"><span class="lineno">  355</span>    <span class="comment">// in some compilers, &gt;&gt;= 32 does strange things, in fact it does nothing. To avoid that, I shift k - 1 bits and then an extra 1 bit</span></div>
<div class="line"><span class="lineno">  356</span>    <a class="code hl_variable" href="classibitstream.html#a48cd41991b6c29ea5120b53873a72a70">head_mask</a> &gt;&gt;= k - 1;</div>
<div class="line"><span class="lineno">  357</span>    <a class="code hl_variable" href="classibitstream.html#a48cd41991b6c29ea5120b53873a72a70">head_mask</a> &gt;&gt;= 1;</div>
<div class="line"><span class="lineno">  358</span>    <a class="code hl_variable" href="classibitstream.html#a7b96359ac1534a5565e6e9b0cc53a0b3">head_place</a> -= k;</div>
<div class="line"><span class="lineno">  359</span>    <span class="comment">//cerr &lt;&lt; &quot; after head_mask &quot; &lt;&lt; head_mask &lt;&lt; &quot; head_place = &quot; &lt;&lt; head_place &lt;&lt; endl;</span></div>
<div class="line"><span class="lineno">  360</span>    <span class="keywordflow">return</span> ans;</div>
<div class="line"><span class="lineno">  361</span>  }<span class="keywordflow">else</span>{</div>
<div class="line"><span class="lineno">  362</span>    <span class="comment">// there is not enough bits in the current buffer.</span></div>
<div class="line"><span class="lineno">  363</span>    <span class="comment">// So we should read head_place many bits from the current buffer</span></div>
<div class="line"><span class="lineno">  364</span>    <span class="comment">// then read another chunk from input file</span></div>
<div class="line"><span class="lineno">  365</span>    <span class="comment">// and then read k - head_place bits from the new buffer</span></div>
<div class="line"><span class="lineno">  366</span>    <span class="comment">// we do these two steps recursively</span></div>
<div class="line"><span class="lineno">  367</span>    <span class="comment">// but first need to store the number of bits we will have to read in the future, since these variables will be modified later:</span></div>
<div class="line"><span class="lineno">  368</span>    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> future_bits = k - <a class="code hl_variable" href="classibitstream.html#a7b96359ac1534a5565e6e9b0cc53a0b3">head_place</a>;</div>
<div class="line"><span class="lineno">  369</span>    <span class="keywordflow">if</span> (<a class="code hl_variable" href="classibitstream.html#a7b96359ac1534a5565e6e9b0cc53a0b3">head_place</a> &gt; <a class="code hl_variable" href="bitstream_8h.html#afcadf5aa65c5159bfb96c4d82ebc0a5d">BIT_INT</a>)</div>
<div class="line"><span class="lineno">  370</span>      cerr &lt;&lt; <span class="stringliteral">&quot; 367 head_place = &quot;</span> &lt;&lt; <a class="code hl_variable" href="classibitstream.html#a7b96359ac1534a5565e6e9b0cc53a0b3">head_place</a> &lt;&lt; endl;</div>
<div class="line"><span class="lineno">  371</span>    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> a = <a class="code hl_function" href="classibitstream.html#a2fdcaecf10fefa6942dcd5286a2696e0">read_bits</a>(<a class="code hl_variable" href="classibitstream.html#a7b96359ac1534a5565e6e9b0cc53a0b3">head_place</a>); <span class="comment">// the bits from the current buffer</span></div>
<div class="line"><span class="lineno">  372</span>    <a class="code hl_function" href="classibitstream.html#ac62c26004436d83f337f4aeba0895e20">read_chunk</a>();</div>
<div class="line"><span class="lineno">  373</span>    <span class="keywordflow">if</span> (future_bits &gt; <a class="code hl_variable" href="bitstream_8h.html#afcadf5aa65c5159bfb96c4d82ebc0a5d">BIT_INT</a>)</div>
<div class="line"><span class="lineno">  374</span>      cerr &lt;&lt; <span class="stringliteral">&quot; 371 future_bits = &quot;</span> &lt;&lt; future_bits &lt;&lt; endl;</div>
<div class="line"><span class="lineno">  375</span>    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> b = <a class="code hl_function" href="classibitstream.html#a2fdcaecf10fefa6942dcd5286a2696e0">read_bits</a>(future_bits); <span class="comment">// bits from the next buffer</span></div>
<div class="line"><span class="lineno">  376</span>    <span class="comment">// now we need to combine these</span></div>
<div class="line"><span class="lineno">  377</span>    <span class="comment">// in order to do so, we need to shift a to the left and combine with b</span></div>
<div class="line"><span class="lineno">  378</span>    <span class="comment">// but the number of bits we need to shift a is exactly future bits</span></div>
<div class="line"><span class="lineno">  379</span>    a &lt;&lt;= future_bits;</div>
<div class="line"><span class="lineno">  380</span>    <span class="keywordflow">return</span> a | b;</div>
<div class="line"><span class="lineno">  381</span>  }</div>
<div class="line"><span class="lineno">  382</span>}</div>
<div class="ttc" id="abitstream_8h_html_a6364b017a9400a38f7a994376bb3ebee"><div class="ttname"><a href="bitstream_8h.html#a6364b017a9400a38f7a994376bb3ebee">mask_gen</a></div><div class="ttdeci">unsigned int mask_gen(int n)</div><div class="ttdoc">generates a binary mask with n consecutive ones in LSB</div><div class="ttdef"><b>Definition</b> bitstream.cpp:649</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="acec2e9efa21551ce8db784f5b0bbd1b5" name="acec2e9efa21551ce8db784f5b0bbd1b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acec2e9efa21551ce8db784f5b0bbd1b5">&#9670;&#160;</a></span>read_bits_append()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ibitstream::read_bits_append </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbit__pipe.html">bit_pipe</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>similar to read_bits, but B does not have to be empty and the result will be appended to B (this is used in order to recursively implement read_bits) </p>
<div class="fragment"><div class="line"><span class="lineno">  384</span>                                                   {</div>
<div class="line"><span class="lineno">  385</span>  <span class="comment">//cout &lt;&lt; &quot; read_bits called k = &quot; &lt;&lt; k &lt;&lt; &quot; head_place = &quot; &lt;&lt; head_place &lt;&lt; endl;</span></div>
<div class="line"><span class="lineno">  386</span>  <span class="comment">// by assumption, when calling this function, B has full chunks (last_bits is either zero so BIT_INT)</span></div>
<div class="line"><span class="lineno">  387</span>  <span class="keywordflow">if</span> (k == 0)</div>
<div class="line"><span class="lineno">  388</span>    <span class="keywordflow">return</span>; <span class="comment">// nothing remains to be done</span></div>
<div class="line"><span class="lineno">  389</span>  <span class="keywordflow">if</span> (<a class="code hl_variable" href="classibitstream.html#a7b96359ac1534a5565e6e9b0cc53a0b3">head_place</a> == 0){</div>
<div class="line"><span class="lineno">  390</span>    <span class="comment">// we are over with the current bits in the buffer</span></div>
<div class="line"><span class="lineno">  391</span>    <span class="comment">// so we need to load a few chunks from the input</span></div>
<div class="line"><span class="lineno">  392</span>    <span class="comment">// we should append k / BIT_INT full chunks to B and then k % BIT_INT bits from the next chunk</span></div>
<div class="line"><span class="lineno">  393</span>    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> full_chunks = k / <a class="code hl_variable" href="bitstream_8h.html#afcadf5aa65c5159bfb96c4d82ebc0a5d">BIT_INT</a>;</div>
<div class="line"><span class="lineno">  394</span>    <span class="keywordflow">if</span> (full_chunks &gt; 0){</div>
<div class="line"><span class="lineno">  395</span>      B.<a class="code hl_variable" href="classbit__pipe.html#a86f38af1e9736b053728033490476b50">bits</a>.resize(B.<a class="code hl_variable" href="classbit__pipe.html#a86f38af1e9736b053728033490476b50">bits</a>.size() + full_chunks);</div>
<div class="line"><span class="lineno">  396</span>      fread(&amp;B.<a class="code hl_variable" href="classbit__pipe.html#a86f38af1e9736b053728033490476b50">bits</a>[B.<a class="code hl_variable" href="classbit__pipe.html#a86f38af1e9736b053728033490476b50">bits</a>.size() - full_chunks], <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>), full_chunks, <a class="code hl_variable" href="classibitstream.html#a3ea2cdd0cf97820f0e1520c42e364308">f</a>); <span class="comment">// read full_chunks many chunks</span></div>
<div class="line"><span class="lineno">  397</span>      B.<a class="code hl_variable" href="classbit__pipe.html#a0f3e84b02751803adaab499b5dad86fe">last_bits</a> = <a class="code hl_variable" href="bitstream_8h.html#afcadf5aa65c5159bfb96c4d82ebc0a5d">BIT_INT</a>; <span class="comment">// the last chunk contains full bits </span></div>
<div class="line"><span class="lineno">  398</span>    }</div>
<div class="line"><span class="lineno">  399</span>    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> res_bits = k % <a class="code hl_variable" href="bitstream_8h.html#afcadf5aa65c5159bfb96c4d82ebc0a5d">BIT_INT</a>; <span class="comment">// the remaining bits to be read</span></div>
<div class="line"><span class="lineno">  400</span>    <span class="keywordflow">if</span> (res_bits &gt; 0){</div>
<div class="line"><span class="lineno">  401</span>      <span class="comment">// we need to read an extra res bits</span></div>
<div class="line"><span class="lineno">  402</span>      <span class="keywordflow">if</span> (res_bits &gt; <a class="code hl_variable" href="bitstream_8h.html#afcadf5aa65c5159bfb96c4d82ebc0a5d">BIT_INT</a>)</div>
<div class="line"><span class="lineno">  403</span>        cerr &lt;&lt; <span class="stringliteral">&quot; 400 res_bits = &quot;</span> &lt;&lt; res_bits &lt;&lt; endl;</div>
<div class="line"><span class="lineno">  404</span>      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> res = <a class="code hl_function" href="classibitstream.html#a2fdcaecf10fefa6942dcd5286a2696e0">read_bits</a> (res_bits); <span class="comment">// read res many bits</span></div>
<div class="line"><span class="lineno">  405</span>      <span class="comment">// we should shift res_bits so that its MSB is the leftmost bits of the chunk</span></div>
<div class="line"><span class="lineno">  406</span>      res &lt;&lt;= (<a class="code hl_variable" href="bitstream_8h.html#afcadf5aa65c5159bfb96c4d82ebc0a5d">BIT_INT</a> - res_bits);</div>
<div class="line"><span class="lineno">  407</span>      B.<a class="code hl_variable" href="classbit__pipe.html#a86f38af1e9736b053728033490476b50">bits</a>.push_back(res);</div>
<div class="line"><span class="lineno">  408</span>      B.<a class="code hl_variable" href="classbit__pipe.html#a0f3e84b02751803adaab499b5dad86fe">last_bits</a> = res_bits;</div>
<div class="line"><span class="lineno">  409</span>    }</div>
<div class="line"><span class="lineno">  410</span>  }<span class="keywordflow">else</span>{</div>
<div class="line"><span class="lineno">  411</span>    <span class="keywordflow">if</span> (k &lt;= <a class="code hl_variable" href="classibitstream.html#a7b96359ac1534a5565e6e9b0cc53a0b3">head_place</a>){</div>
<div class="line"><span class="lineno">  412</span>      <span class="comment">// there are enough bits to read</span></div>
<div class="line"><span class="lineno">  413</span>      <span class="keywordflow">if</span> (k &gt; <a class="code hl_variable" href="bitstream_8h.html#afcadf5aa65c5159bfb96c4d82ebc0a5d">BIT_INT</a>)</div>
<div class="line"><span class="lineno">  414</span>        cerr &lt;&lt; <span class="stringliteral">&quot; 411 k = &quot;</span> &lt;&lt; k &lt;&lt; endl;</div>
<div class="line"><span class="lineno">  415</span>      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> a = <a class="code hl_function" href="classibitstream.html#a2fdcaecf10fefa6942dcd5286a2696e0">read_bits</a>(k);</div>
<div class="line"><span class="lineno">  416</span>      <span class="comment">// no need to shift a since we need LSB of a to be in the rightmost bit</span></div>
<div class="line"><span class="lineno">  417</span>      B.<a class="code hl_variable" href="classbit__pipe.html#a86f38af1e9736b053728033490476b50">bits</a>.push_back(a);</div>
<div class="line"><span class="lineno">  418</span>      B.<a class="code hl_variable" href="classbit__pipe.html#a0f3e84b02751803adaab499b5dad86fe">last_bits</a> = <a class="code hl_variable" href="bitstream_8h.html#afcadf5aa65c5159bfb96c4d82ebc0a5d">BIT_INT</a>;</div>
<div class="line"><span class="lineno">  419</span>    }<span class="keywordflow">else</span>{</div>
<div class="line"><span class="lineno">  420</span>      <span class="comment">// read head_place bits and call again</span></div>
<div class="line"><span class="lineno">  421</span>      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> future_read; <span class="comment">// number of bits to read in future after calling the read_bits function below</span></div>
<div class="line"><span class="lineno">  422</span>      future_read = k - <a class="code hl_variable" href="classibitstream.html#a7b96359ac1534a5565e6e9b0cc53a0b3">head_place</a>;</div>
<div class="line"><span class="lineno">  423</span>      <span class="keywordflow">if</span> (<a class="code hl_variable" href="classibitstream.html#a7b96359ac1534a5565e6e9b0cc53a0b3">head_place</a> &gt; <a class="code hl_variable" href="bitstream_8h.html#afcadf5aa65c5159bfb96c4d82ebc0a5d">BIT_INT</a>)</div>
<div class="line"><span class="lineno">  424</span>        cerr &lt;&lt; <span class="stringliteral">&quot; 421 head_place = &quot;</span> &lt;&lt; <a class="code hl_variable" href="classibitstream.html#a7b96359ac1534a5565e6e9b0cc53a0b3">head_place</a> &lt;&lt; endl;</div>
<div class="line"><span class="lineno">  425</span>      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> a = <a class="code hl_function" href="classibitstream.html#a2fdcaecf10fefa6942dcd5286a2696e0">read_bits</a>(<a class="code hl_variable" href="classibitstream.html#a7b96359ac1534a5565e6e9b0cc53a0b3">head_place</a>);</div>
<div class="line"><span class="lineno">  426</span>      B.<a class="code hl_variable" href="classbit__pipe.html#a86f38af1e9736b053728033490476b50">bits</a>.push_back(a);</div>
<div class="line"><span class="lineno">  427</span>      B.<a class="code hl_variable" href="classbit__pipe.html#a0f3e84b02751803adaab499b5dad86fe">last_bits</a> = <a class="code hl_variable" href="bitstream_8h.html#afcadf5aa65c5159bfb96c4d82ebc0a5d">BIT_INT</a>;</div>
<div class="line"><span class="lineno">  428</span>      <a class="code hl_function" href="classibitstream.html#acec2e9efa21551ce8db784f5b0bbd1b5">read_bits_append</a>(future_read, B); <span class="comment">// read the remaining bits </span></div>
<div class="line"><span class="lineno">  429</span>    }</div>
<div class="line"><span class="lineno">  430</span>  }</div>
<div class="line"><span class="lineno">  431</span> </div>
<div class="line"><span class="lineno">  432</span>  B.<a class="code hl_function" href="classbit__pipe.html#a341a1f62d728a67f730503ca722a7770">shift_right</a>(<a class="code hl_variable" href="bitstream_8h.html#afcadf5aa65c5159bfb96c4d82ebc0a5d">BIT_INT</a> - B.<a class="code hl_variable" href="classbit__pipe.html#a0f3e84b02751803adaab499b5dad86fe">last_bits</a>); <span class="comment">// so that LSB of B is the rightmost bit of the lats chunk.</span></div>
<div class="line"><span class="lineno">  433</span> </div>
<div class="line"><span class="lineno">  434</span>  <span class="comment">// this is important to make sure that B is correctly representing an integer and can be converted to mpz_class</span></div>
<div class="line"><span class="lineno">  435</span>  <span class="comment">// TODO issue of 2^k - 1 correct</span></div>
<div class="line"><span class="lineno">  436</span>}</div>
<div class="ttc" id="aclassbit__pipe_html_a341a1f62d728a67f730503ca722a7770"><div class="ttname"><a href="classbit__pipe.html#a341a1f62d728a67f730503ca722a7770">bit_pipe::shift_right</a></div><div class="ttdeci">void shift_right(int n)</div><div class="ttdoc">shifts n bits to the right.</div><div class="ttdef"><b>Definition</b> bitstream.cpp:45</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ac62c26004436d83f337f4aeba0895e20" name="ac62c26004436d83f337f4aeba0895e20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac62c26004436d83f337f4aeba0895e20">&#9670;&#160;</a></span>read_chunk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ibitstream::read_chunk </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>reads one chunk (4 bytes) from the input file and stores it in buffer </p>
<div class="fragment"><div class="line"><span class="lineno">  328</span>                           {</div>
<div class="line"><span class="lineno">  329</span>  fread(&amp;<a class="code hl_variable" href="classibitstream.html#a73f0b24d3d4402369f1abbb43f7f70ef">buffer</a>, <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>), 1, <a class="code hl_variable" href="classibitstream.html#a3ea2cdd0cf97820f0e1520c42e364308">f</a>);</div>
<div class="line"><span class="lineno">  330</span>  <span class="comment">//cout &lt;&lt; &quot; in read chunk  buffer = &quot; &lt;&lt; bitset&lt;32&gt;(buffer) &lt;&lt; endl;</span></div>
<div class="line"><span class="lineno">  331</span>  <a class="code hl_variable" href="classibitstream.html#a48cd41991b6c29ea5120b53873a72a70">head_mask</a> = 1 &lt;&lt; (<a class="code hl_variable" href="bitstream_8h.html#afcadf5aa65c5159bfb96c4d82ebc0a5d">BIT_INT</a> - 1); <span class="comment">// pointing to the MSB which is the first bit to consider</span></div>
<div class="line"><span class="lineno">  332</span>  <a class="code hl_variable" href="classibitstream.html#a7b96359ac1534a5565e6e9b0cc53a0b3">head_place</a> = <a class="code hl_variable" href="bitstream_8h.html#afcadf5aa65c5159bfb96c4d82ebc0a5d">BIT_INT</a>;</div>
<div class="line"><span class="lineno">  333</span>}</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a73f0b24d3d4402369f1abbb43f7f70ef" name="a73f0b24d3d4402369f1abbb43f7f70ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73f0b24d3d4402369f1abbb43f7f70ef">&#9670;&#160;</a></span>buffer</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ibitstream::buffer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>the last chunk read from the input </p>

</div>
</div>
<a id="a3ea2cdd0cf97820f0e1520c42e364308" name="a3ea2cdd0cf97820f0e1520c42e364308"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ea2cdd0cf97820f0e1520c42e364308">&#9670;&#160;</a></span>f</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FILE* ibitstream::f</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>pointer to input binary file </p>

</div>
</div>
<a id="a48cd41991b6c29ea5120b53873a72a70" name="a48cd41991b6c29ea5120b53873a72a70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48cd41991b6c29ea5120b53873a72a70">&#9670;&#160;</a></span>head_mask</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ibitstream::head_mask</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>the place of the head bit in buffer, represented in terms of mask. So if we are in the LSB, head_mask is one, if we are in two bit left of LSB, this is 4 so on. When this is zero, it means the buffer is expired and we should probably read one more chunk from the input file </p>

</div>
</div>
<a id="a7b96359ac1534a5565e6e9b0cc53a0b3" name="a7b96359ac1534a5565e6e9b0cc53a0b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b96359ac1534a5565e6e9b0cc53a0b3">&#9670;&#160;</a></span>head_place</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ibitstream::head_place</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>the place of head represented in terms of integer, LSB is 1, left of LSB is 2, 2 left of LSB is 3 and so on. head_place is effectively the number of unread bits remaining in the buffer. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="bitstream_8h_source.html">bitstream.h</a></li>
<li><a class="el" href="bitstream_8cpp.html">bitstream.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
