<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Marked Graph Compression: ibitstream Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Marked Graph Compression
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classibitstream-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ibitstream Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>deals with reading bit streams from binary files, this is the reverse of obitstream  
 <a href="classibitstream.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="bitstream_8h_source.html">bitstream.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac62c26004436d83f337f4aeba0895e20"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibitstream.html#ac62c26004436d83f337f4aeba0895e20">read_chunk</a> ()</td></tr>
<tr class="memdesc:ac62c26004436d83f337f4aeba0895e20"><td class="mdescLeft">&#160;</td><td class="mdescRight">reads one chunk (4 bytes) from the input file and stores it in buffer  <a href="#ac62c26004436d83f337f4aeba0895e20">More...</a><br /></td></tr>
<tr class="separator:ac62c26004436d83f337f4aeba0895e20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fdcaecf10fefa6942dcd5286a2696e0"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibitstream.html#a2fdcaecf10fefa6942dcd5286a2696e0">read_bits</a> (unsigned int k)</td></tr>
<tr class="memdesc:a2fdcaecf10fefa6942dcd5286a2696e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">read k bits from the input, interpret it as integer (first bit read is MSB) and return its value. Here, k must be in the range 1 &lt;= k &lt;= BIT_INT  <a href="#a2fdcaecf10fefa6942dcd5286a2696e0">More...</a><br /></td></tr>
<tr class="separator:a2fdcaecf10fefa6942dcd5286a2696e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bb7a698ab44c1e2fe21b4daa880bd6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibitstream.html#a4bb7a698ab44c1e2fe21b4daa880bd6c">read_bits</a> (int k, <a class="el" href="classbit__pipe.html">bit_pipe</a> &amp;B)</td></tr>
<tr class="memdesc:a4bb7a698ab44c1e2fe21b4daa880bd6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">reads k bits from input and stores in the given <a class="el" href="classbit__pipe.html" title="A sequence of arbitrary number of bits. ">bit_pipe</a>. \(k \geq 1\) is arbitrary. The bits are stored in the <a class="el" href="classbit__pipe.html" title="A sequence of arbitrary number of bits. ">bit_pipe</a> so that can be interpreted as integer (e.g. mpz_class) so the LSB is located in the rightmost bit of the rightmost chunk (unlike the usual <a class="el" href="classbit__pipe.html" title="A sequence of arbitrary number of bits. ">bit_pipe</a> situation). We assume that the B given here is an empty <a class="el" href="classbit__pipe.html" title="A sequence of arbitrary number of bits. ">bit_pipe</a>  <a href="#a4bb7a698ab44c1e2fe21b4daa880bd6c">More...</a><br /></td></tr>
<tr class="separator:a4bb7a698ab44c1e2fe21b4daa880bd6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acec2e9efa21551ce8db784f5b0bbd1b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibitstream.html#acec2e9efa21551ce8db784f5b0bbd1b5">read_bits_append</a> (int k, <a class="el" href="classbit__pipe.html">bit_pipe</a> &amp;B)</td></tr>
<tr class="memdesc:acec2e9efa21551ce8db784f5b0bbd1b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">similar to read_bits, but B does not have to be empty and the result will be appended to B (this is used in order to recursively implement read_bits)  <a href="#acec2e9efa21551ce8db784f5b0bbd1b5">More...</a><br /></td></tr>
<tr class="separator:acec2e9efa21551ce8db784f5b0bbd1b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a895239acf7179f6778388c39c97643e4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibitstream.html#a895239acf7179f6778388c39c97643e4">read_bit</a> ()</td></tr>
<tr class="memdesc:a895239acf7179f6778388c39c97643e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">read one bit from input and return true if its value is 1 and false otherwise.  <a href="#a895239acf7179f6778388c39c97643e4">More...</a><br /></td></tr>
<tr class="separator:a895239acf7179f6778388c39c97643e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5f00b64072ed3ffe495b7712a71e3eb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibitstream.html#af5f00b64072ed3ffe495b7712a71e3eb">ibitstream</a> (string file_name)</td></tr>
<tr class="separator:af5f00b64072ed3ffe495b7712a71e3eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3e91ecc9ff17eef98d72d44aec02eca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classibitstream.html">ibitstream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibitstream.html#ae3e91ecc9ff17eef98d72d44aec02eca">operator&gt;&gt;</a> (unsigned int &amp;n)</td></tr>
<tr class="memdesc:ae3e91ecc9ff17eef98d72d44aec02eca"><td class="mdescLeft">&#160;</td><td class="mdescRight">reads an unsigned int from the input using Elias delta decoding and saves it in the reference given  <a href="#ae3e91ecc9ff17eef98d72d44aec02eca">More...</a><br /></td></tr>
<tr class="separator:ae3e91ecc9ff17eef98d72d44aec02eca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0264d01fa1211c4bb73f5de2bc68adbc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classibitstream.html">ibitstream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibitstream.html#a0264d01fa1211c4bb73f5de2bc68adbc">operator&gt;&gt;</a> (mpz_class &amp;n)</td></tr>
<tr class="memdesc:a0264d01fa1211c4bb73f5de2bc68adbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">reads a nonnegative mpz_class integer using Elias delta decoding and stores in the reference given  <a href="#a0264d01fa1211c4bb73f5de2bc68adbc">More...</a><br /></td></tr>
<tr class="separator:a0264d01fa1211c4bb73f5de2bc68adbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7b59600e58571b802d6d0dadf92d37a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibitstream.html#aa7b59600e58571b802d6d0dadf92d37a">close</a> ()</td></tr>
<tr class="memdesc:aa7b59600e58571b802d6d0dadf92d37a"><td class="mdescLeft">&#160;</td><td class="mdescRight">closes the session by closing the input file  <a href="#aa7b59600e58571b802d6d0dadf92d37a">More...</a><br /></td></tr>
<tr class="separator:aa7b59600e58571b802d6d0dadf92d37a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a3ea2cdd0cf97820f0e1520c42e364308"><td class="memItemLeft" align="right" valign="top">FILE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibitstream.html#a3ea2cdd0cf97820f0e1520c42e364308">f</a></td></tr>
<tr class="memdesc:a3ea2cdd0cf97820f0e1520c42e364308"><td class="mdescLeft">&#160;</td><td class="mdescRight">pointer to input binary file  <a href="#a3ea2cdd0cf97820f0e1520c42e364308">More...</a><br /></td></tr>
<tr class="separator:a3ea2cdd0cf97820f0e1520c42e364308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73f0b24d3d4402369f1abbb43f7f70ef"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibitstream.html#a73f0b24d3d4402369f1abbb43f7f70ef">buffer</a></td></tr>
<tr class="memdesc:a73f0b24d3d4402369f1abbb43f7f70ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">the last chunk read from the input  <a href="#a73f0b24d3d4402369f1abbb43f7f70ef">More...</a><br /></td></tr>
<tr class="separator:a73f0b24d3d4402369f1abbb43f7f70ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48cd41991b6c29ea5120b53873a72a70"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibitstream.html#a48cd41991b6c29ea5120b53873a72a70">head_mask</a></td></tr>
<tr class="memdesc:a48cd41991b6c29ea5120b53873a72a70"><td class="mdescLeft">&#160;</td><td class="mdescRight">the place of the head bit in buffer, represented in terms of mask. So if we are in the LSB, head_mask is one, if we are in two bit left of LSB, this is 4 so on. When this is zero, it means the buffer is expired and we should probably read one more chunk from the input file  <a href="#a48cd41991b6c29ea5120b53873a72a70">More...</a><br /></td></tr>
<tr class="separator:a48cd41991b6c29ea5120b53873a72a70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b96359ac1534a5565e6e9b0cc53a0b3"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibitstream.html#a7b96359ac1534a5565e6e9b0cc53a0b3">head_place</a></td></tr>
<tr class="memdesc:a7b96359ac1534a5565e6e9b0cc53a0b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">the place of head represented in terms of integer, LSB is 1, left of LSB is 2, 2 left of LSB is 3 and so on. head_place is effectively the number of unread bits remaining in the buffer.  <a href="#a7b96359ac1534a5565e6e9b0cc53a0b3">More...</a><br /></td></tr>
<tr class="separator:a7b96359ac1534a5565e6e9b0cc53a0b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>deals with reading bit streams from binary files, this is the reverse of obitstream </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af5f00b64072ed3ffe495b7712a71e3eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5f00b64072ed3ffe495b7712a71e3eb">&#9670;&nbsp;</a></span>ibitstream()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ibitstream::ibitstream </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>file_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;                              {</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;    <a class="code" href="classibitstream.html#a3ea2cdd0cf97820f0e1520c42e364308">f</a> = fopen(file_name.c_str(), <span class="stringliteral">&quot;rb+&quot;</span>);</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;    <a class="code" href="classibitstream.html#a73f0b24d3d4402369f1abbb43f7f70ef">buffer</a> =0;</div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;    <a class="code" href="classibitstream.html#a48cd41991b6c29ea5120b53873a72a70">head_mask</a> = 0;</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;    <a class="code" href="classibitstream.html#a7b96359ac1534a5565e6e9b0cc53a0b3">head_place</a> = 0;</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;  }</div><div class="ttc" id="classibitstream_html_a7b96359ac1534a5565e6e9b0cc53a0b3"><div class="ttname"><a href="classibitstream.html#a7b96359ac1534a5565e6e9b0cc53a0b3">ibitstream::head_place</a></div><div class="ttdeci">unsigned int head_place</div><div class="ttdoc">the place of head represented in terms of integer, LSB is 1, left of LSB is 2, 2 left of LSB is 3 and...</div><div class="ttdef"><b>Definition:</b> bitstream.h:116</div></div>
<div class="ttc" id="classibitstream_html_a73f0b24d3d4402369f1abbb43f7f70ef"><div class="ttname"><a href="classibitstream.html#a73f0b24d3d4402369f1abbb43f7f70ef">ibitstream::buffer</a></div><div class="ttdeci">unsigned int buffer</div><div class="ttdoc">the last chunk read from the input </div><div class="ttdef"><b>Definition:</b> bitstream.h:114</div></div>
<div class="ttc" id="classibitstream_html_a3ea2cdd0cf97820f0e1520c42e364308"><div class="ttname"><a href="classibitstream.html#a3ea2cdd0cf97820f0e1520c42e364308">ibitstream::f</a></div><div class="ttdeci">FILE * f</div><div class="ttdoc">pointer to input binary file </div><div class="ttdef"><b>Definition:</b> bitstream.h:113</div></div>
<div class="ttc" id="classibitstream_html_a48cd41991b6c29ea5120b53873a72a70"><div class="ttname"><a href="classibitstream.html#a48cd41991b6c29ea5120b53873a72a70">ibitstream::head_mask</a></div><div class="ttdeci">unsigned int head_mask</div><div class="ttdoc">the place of the head bit in buffer, represented in terms of mask. So if we are in the LSB...</div><div class="ttdef"><b>Definition:</b> bitstream.h:115</div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa7b59600e58571b802d6d0dadf92d37a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7b59600e58571b802d6d0dadf92d37a">&#9670;&nbsp;</a></span>close()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ibitstream::close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>closes the session by closing the input file </p>
<div class="fragment"><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;{fclose(<a class="code" href="classibitstream.html#a3ea2cdd0cf97820f0e1520c42e364308">f</a>);}</div><div class="ttc" id="classibitstream_html_a3ea2cdd0cf97820f0e1520c42e364308"><div class="ttname"><a href="classibitstream.html#a3ea2cdd0cf97820f0e1520c42e364308">ibitstream::f</a></div><div class="ttdeci">FILE * f</div><div class="ttdoc">pointer to input binary file </div><div class="ttdef"><b>Definition:</b> bitstream.h:113</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ae3e91ecc9ff17eef98d72d44aec02eca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3e91ecc9ff17eef98d72d44aec02eca">&#9670;&nbsp;</a></span>operator>>() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classibitstream.html">ibitstream</a> &amp; ibitstream::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>reads an unsigned int from the input using Elias delta decoding and saves it in the reference given </p>
<div class="fragment"><div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;                                                   {</div><div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;  <span class="comment">// implement Elias delta decoding</span></div><div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;  <span class="comment">//bitset&lt;32&gt; B(buffer);</span></div><div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;  <span class="comment">//cerr &lt;&lt; &quot; buffer &quot; &lt;&lt; B &lt;&lt; endl;</span></div><div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;  <span class="comment">//cerr &lt;&lt; &quot; head &quot; &lt;&lt; bitset&lt;32&gt;(head_mask) &lt;&lt; endl;</span></div><div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;  <span class="comment">//cerr &lt;&lt; &quot; head position &quot; &lt;&lt; head_place &lt;&lt; endl;</span></div><div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;  </div><div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> L = 0;</div><div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;  <span class="keywordflow">while</span> (!<a class="code" href="classibitstream.html#a895239acf7179f6778388c39c97643e4">read_bit</a>()){</div><div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;    <span class="comment">// read until reach one</span></div><div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;    L++;</div><div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;  }</div><div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;  <span class="comment">//cerr &lt;&lt; &quot; L &quot; &lt;&lt; L &lt;&lt; endl;</span></div><div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;  </div><div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N;</div><div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;  <span class="keywordflow">if</span> (L == 0){<span class="comment">// special case, avoid going over further calculations</span></div><div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;    n = 0; <span class="comment">// we had subtracted one when encoding </span></div><div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;    <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div><div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;  }</div><div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;  N = <a class="code" href="classibitstream.html#a2fdcaecf10fefa6942dcd5286a2696e0">read_bits</a>(L); <span class="comment">// read L digits</span></div><div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;  </div><div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;  N += (1&lt;&lt;L); <span class="comment">// we must add 2^L</span></div><div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;  N --; <span class="comment">// this was N + 1</span></div><div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;  </div><div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;  n = <a class="code" href="classibitstream.html#a2fdcaecf10fefa6942dcd5286a2696e0">read_bits</a>(N); <span class="comment">// read N digits</span></div><div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;  n += (1 &lt;&lt; N); <span class="comment">// we must add 2^N</span></div><div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;  n --; <span class="comment">// when we encoded, in order to get a positive integer, we added one, now we subtract one</span></div><div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;  <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div><div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;}</div><div class="ttc" id="classibitstream_html_a2fdcaecf10fefa6942dcd5286a2696e0"><div class="ttname"><a href="classibitstream.html#a2fdcaecf10fefa6942dcd5286a2696e0">ibitstream::read_bits</a></div><div class="ttdeci">unsigned int read_bits(unsigned int k)</div><div class="ttdoc">read k bits from the input, interpret it as integer (first bit read is MSB) and return its value...</div><div class="ttdef"><b>Definition:</b> bitstream.cpp:274</div></div>
<div class="ttc" id="classibitstream_html_a895239acf7179f6778388c39c97643e4"><div class="ttname"><a href="classibitstream.html#a895239acf7179f6778388c39c97643e4">ibitstream::read_bit</a></div><div class="ttdeci">bool read_bit()</div><div class="ttdoc">read one bit from input and return true if its value is 1 and false otherwise. </div><div class="ttdef"><b>Definition:</b> bitstream.cpp:468</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a0264d01fa1211c4bb73f5de2bc68adbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0264d01fa1211c4bb73f5de2bc68adbc">&#9670;&nbsp;</a></span>operator>>() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classibitstream.html">ibitstream</a> &amp; ibitstream::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">mpz_class &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>reads a nonnegative mpz_class integer using Elias delta decoding and stores in the reference given </p>
<div class="fragment"><div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;                                                {</div><div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> L = 0;</div><div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;  <span class="comment">//cout &lt;&lt; &quot;head_place &quot; &lt;&lt; head_place &lt;&lt; endl;</span></div><div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;  <span class="comment">//cout &lt;&lt; &quot;head_mask  &quot; &lt;&lt; head_mask &lt;&lt; endl;</span></div><div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;  <span class="keywordflow">while</span> (!<a class="code" href="classibitstream.html#a895239acf7179f6778388c39c97643e4">read_bit</a>()){</div><div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;    <span class="comment">// read until reach one</span></div><div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;    L++;</div><div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;  }</div><div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;</div><div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;  <span class="comment">//cout &lt;&lt; &quot; L = &quot; &lt;&lt; L &lt;&lt; endl;</span></div><div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N;</div><div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;  <span class="keywordflow">if</span> (L == 0){<span class="comment">// special case, avoid going over further calculations</span></div><div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;    n = 0; <span class="comment">// we had subtracted one when encoding </span></div><div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;    <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div><div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;  }</div><div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;</div><div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;  N = <a class="code" href="classibitstream.html#a2fdcaecf10fefa6942dcd5286a2696e0">read_bits</a>(L); <span class="comment">// read L digits</span></div><div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;  </div><div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;  N += (1&lt;&lt;L); <span class="comment">// we must add 2^L</span></div><div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;  N --; <span class="comment">// this was N + 1</span></div><div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;</div><div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;  <span class="comment">// we must read N bits and form n based on that</span></div><div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;</div><div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;  <a class="code" href="classbit__pipe.html">bit_pipe</a> B;</div><div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;  <span class="comment">//cout &lt;&lt; &quot; N &quot; &lt;&lt; N &lt;&lt; endl;</span></div><div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;  <a class="code" href="classibitstream.html#a2fdcaecf10fefa6942dcd5286a2696e0">read_bits</a>(N, B);</div><div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;  <span class="comment">//cout &lt;&lt; &quot; B first &quot; &lt;&lt; B &lt;&lt; endl;</span></div><div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;  <span class="comment">// we should add a leading 1 to B</span></div><div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;  <span class="comment">// in order to do so, we should consider 2 cases:</span></div><div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;  <span class="keywordflow">if</span> (N % <a class="code" href="bitstream_8h.html#afcadf5aa65c5159bfb96c4d82ebc0a5d">BIT_INT</a> == 0){</div><div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;    <span class="comment">// this is the tricky case, since B now contains full chunks and there is no room to add the leading 1</span></div><div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;    <span class="comment">// so we need to insert a chunk at the beginning and place the leading bit there</span></div><div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;    <span class="comment">// since the leading bit will be in the rightmost bit in this case, the value of the initial chunk is 1 in this case</span></div><div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;    B.<a class="code" href="classbit__pipe.html#a86f38af1e9736b053728033490476b50">bits</a>.insert(B.<a class="code" href="classbit__pipe.html#a86f38af1e9736b053728033490476b50">bits</a>.begin(), 1);</div><div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;  }<span class="keywordflow">else</span>{</div><div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;    <span class="comment">// in this case, the lading bit will be placed in the first chunk of B</span></div><div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;    B.<a class="code" href="classbit__pipe.html#a86f38af1e9736b053728033490476b50">bits</a>[0] |= (1 &lt;&lt; (N % <a class="code" href="bitstream_8h.html#afcadf5aa65c5159bfb96c4d82ebc0a5d">BIT_INT</a>));</div><div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;  }</div><div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;  <span class="comment">//cout &lt;&lt; &quot; B &quot; &lt;&lt; B &lt;&lt; endl;</span></div><div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;  <span class="comment">//cout &lt;&lt; B.bits[0] &lt;&lt; endl;</span></div><div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;</div><div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;  <span class="comment">// construct the mpz_clas</span></div><div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;  mpz_import(n.get_mpz_t(),</div><div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;             B.<a class="code" href="classbit__pipe.html#a86f38af1e9736b053728033490476b50">bits</a>.size(), <span class="comment">// the number of words</span></div><div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;             1, <span class="comment">// order: 1 means first significant word first</span></div><div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;             <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> int), <span class="comment">// each word is this many bytes</span></div><div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;             0, <span class="comment">// endian can be 1 for most significant byte first, -1 for least significant first, or 0 for the native endianness of the host CPU.</span></div><div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;             0, <span class="comment">// nails</span></div><div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;             &amp;B.<a class="code" href="classbit__pipe.html#a86f38af1e9736b053728033490476b50">bits</a>[0]); <span class="comment">//&amp;B.bits[0]);</span></div><div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;</div><div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;  n --; <span class="comment">// when encoding, we added 1 to make sure it is positive</span></div><div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;  <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div><div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;}</div><div class="ttc" id="bitstream_8h_html_afcadf5aa65c5159bfb96c4d82ebc0a5d"><div class="ttname"><a href="bitstream_8h.html#afcadf5aa65c5159bfb96c4d82ebc0a5d">BIT_INT</a></div><div class="ttdeci">const unsigned int BIT_INT</div><div class="ttdef"><b>Definition:</b> bitstream.h:11</div></div>
<div class="ttc" id="classbit__pipe_html"><div class="ttname"><a href="classbit__pipe.html">bit_pipe</a></div><div class="ttdoc">A sequence of arbitrary number of bits. </div><div class="ttdef"><b>Definition:</b> bitstream.h:21</div></div>
<div class="ttc" id="classibitstream_html_a2fdcaecf10fefa6942dcd5286a2696e0"><div class="ttname"><a href="classibitstream.html#a2fdcaecf10fefa6942dcd5286a2696e0">ibitstream::read_bits</a></div><div class="ttdeci">unsigned int read_bits(unsigned int k)</div><div class="ttdoc">read k bits from the input, interpret it as integer (first bit read is MSB) and return its value...</div><div class="ttdef"><b>Definition:</b> bitstream.cpp:274</div></div>
<div class="ttc" id="classibitstream_html_a895239acf7179f6778388c39c97643e4"><div class="ttname"><a href="classibitstream.html#a895239acf7179f6778388c39c97643e4">ibitstream::read_bit</a></div><div class="ttdeci">bool read_bit()</div><div class="ttdoc">read one bit from input and return true if its value is 1 and false otherwise. </div><div class="ttdef"><b>Definition:</b> bitstream.cpp:468</div></div>
<div class="ttc" id="classbit__pipe_html_a86f38af1e9736b053728033490476b50"><div class="ttname"><a href="classbit__pipe.html#a86f38af1e9736b053728033490476b50">bit_pipe::bits</a></div><div class="ttdeci">vector&lt; unsigned int &gt; bits</div><div class="ttdoc">a vector of chunks, each of size 4 bytes. This represents an arbitrary sequence of bits ...</div><div class="ttdef"><b>Definition:</b> bitstream.h:23</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a895239acf7179f6778388c39c97643e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a895239acf7179f6778388c39c97643e4">&#9670;&nbsp;</a></span>read_bit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ibitstream::read_bit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>read one bit from input and return true if its value is 1 and false otherwise. </p>
<div class="fragment"><div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;                         {</div><div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;  <span class="keywordflow">if</span> (<a class="code" href="classibitstream.html#a48cd41991b6c29ea5120b53873a72a70">head_mask</a> == 0){ <span class="comment">// nothing is in buffer</span></div><div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;    <span class="comment">//cerr &lt;&lt; &quot; read a chunk &quot; &lt;&lt; endl;</span></div><div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;    <a class="code" href="classibitstream.html#ac62c26004436d83f337f4aeba0895e20">read_chunk</a>();</div><div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;  }</div><div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;  <span class="keywordtype">bool</span> ans = <a class="code" href="classibitstream.html#a48cd41991b6c29ea5120b53873a72a70">head_mask</a> &amp; <a class="code" href="classibitstream.html#a73f0b24d3d4402369f1abbb43f7f70ef">buffer</a>; <span class="comment">// look at the value of buffer at the bit where the head_mask is pointing to</span></div><div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;  <a class="code" href="classibitstream.html#a48cd41991b6c29ea5120b53873a72a70">head_mask</a> &gt;&gt;= 1; <span class="comment">// go one bit to the right</span></div><div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;  <a class="code" href="classibitstream.html#a7b96359ac1534a5565e6e9b0cc53a0b3">head_place</a> --;</div><div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;  <span class="comment">//cerr &lt;&lt; &quot; read bit &quot; &lt;&lt; ans &lt;&lt; endl;</span></div><div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;  <span class="keywordflow">return</span> ans;</div><div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;}</div><div class="ttc" id="classibitstream_html_ac62c26004436d83f337f4aeba0895e20"><div class="ttname"><a href="classibitstream.html#ac62c26004436d83f337f4aeba0895e20">ibitstream::read_chunk</a></div><div class="ttdeci">void read_chunk()</div><div class="ttdoc">reads one chunk (4 bytes) from the input file and stores it in buffer </div><div class="ttdef"><b>Definition:</b> bitstream.cpp:266</div></div>
<div class="ttc" id="classibitstream_html_a7b96359ac1534a5565e6e9b0cc53a0b3"><div class="ttname"><a href="classibitstream.html#a7b96359ac1534a5565e6e9b0cc53a0b3">ibitstream::head_place</a></div><div class="ttdeci">unsigned int head_place</div><div class="ttdoc">the place of head represented in terms of integer, LSB is 1, left of LSB is 2, 2 left of LSB is 3 and...</div><div class="ttdef"><b>Definition:</b> bitstream.h:116</div></div>
<div class="ttc" id="classibitstream_html_a73f0b24d3d4402369f1abbb43f7f70ef"><div class="ttname"><a href="classibitstream.html#a73f0b24d3d4402369f1abbb43f7f70ef">ibitstream::buffer</a></div><div class="ttdeci">unsigned int buffer</div><div class="ttdoc">the last chunk read from the input </div><div class="ttdef"><b>Definition:</b> bitstream.h:114</div></div>
<div class="ttc" id="classibitstream_html_a48cd41991b6c29ea5120b53873a72a70"><div class="ttname"><a href="classibitstream.html#a48cd41991b6c29ea5120b53873a72a70">ibitstream::head_mask</a></div><div class="ttdeci">unsigned int head_mask</div><div class="ttdoc">the place of the head bit in buffer, represented in terms of mask. So if we are in the LSB...</div><div class="ttdef"><b>Definition:</b> bitstream.h:115</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a2fdcaecf10fefa6942dcd5286a2696e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fdcaecf10fefa6942dcd5286a2696e0">&#9670;&nbsp;</a></span>read_bits() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ibitstream::read_bits </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>read k bits from the input, interpret it as integer (first bit read is MSB) and return its value. Here, k must be in the range 1 &lt;= k &lt;= BIT_INT </p>
<div class="fragment"><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;                                                {</div><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;</div><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;  <span class="comment">//cerr &lt;&lt; &quot; read bits with k = &quot; &lt;&lt; k &lt;&lt; endl;</span></div><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;  <span class="keywordflow">if</span> (k &lt; 1 or k &gt; <a class="code" href="bitstream_8h.html#afcadf5aa65c5159bfb96c4d82ebc0a5d">BIT_INT</a>){</div><div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;    cerr &lt;&lt; <span class="stringliteral">&quot;ERROR: ibitstream::read_bits called with k out of range, k = &quot;</span> &lt;&lt; k &lt;&lt; endl;</div><div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;  }</div><div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;  <span class="keywordflow">if</span> (<a class="code" href="classibitstream.html#a7b96359ac1534a5565e6e9b0cc53a0b3">head_place</a> == 0)<span class="comment">// no bits left</span></div><div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;    <a class="code" href="classibitstream.html#ac62c26004436d83f337f4aeba0895e20">read_chunk</a>();</div><div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;  <span class="keywordflow">if</span> (<a class="code" href="classibitstream.html#a7b96359ac1534a5565e6e9b0cc53a0b3">head_place</a> &gt;= k){ <span class="comment">// head_place is effectively the number of unread bits remaining in the buffer</span></div><div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;    <span class="comment">//cerr &lt;&lt; &quot; head_place &gt;= k head_mask = &quot; &lt;&lt; head_mask &lt;&lt; &quot; head_place = &quot; &lt;&lt; head_place &lt;&lt; endl;</span></div><div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;    <span class="comment">// there are enough number of bits in the current buffer to read</span></div><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;    <span class="comment">// mask the input</span></div><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> mask = <a class="code" href="bitstream_8cpp.html#a6364b017a9400a38f7a994376bb3ebee">mask_gen</a>(k); <span class="comment">// k ones</span></div><div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;    <span class="comment">// now we should shift mask to start at head_place</span></div><div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;    mask &lt;&lt;= (<a class="code" href="classibitstream.html#a7b96359ac1534a5565e6e9b0cc53a0b3">head_place</a> - k);</div><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ans = <a class="code" href="classibitstream.html#a73f0b24d3d4402369f1abbb43f7f70ef">buffer</a> &amp; mask; <span class="comment">// mask out the corresponding bits</span></div><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;    ans &gt;&gt;= (<a class="code" href="classibitstream.html#a7b96359ac1534a5565e6e9b0cc53a0b3">head_place</a> - k); <span class="comment">// bring it back to LSB</span></div><div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;</div><div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;    <span class="comment">// we need to shift head k bits to the right</span></div><div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;    <span class="comment">// in some compilers, &gt;&gt;= 32 does strange things, in fact it does nothing. To avoid that, I shift k - 1 bits and then an extra 1 bit</span></div><div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;    <a class="code" href="classibitstream.html#a48cd41991b6c29ea5120b53873a72a70">head_mask</a> &gt;&gt;= k - 1;</div><div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;    <a class="code" href="classibitstream.html#a48cd41991b6c29ea5120b53873a72a70">head_mask</a> &gt;&gt;= 1;</div><div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;    <a class="code" href="classibitstream.html#a7b96359ac1534a5565e6e9b0cc53a0b3">head_place</a> -= k;</div><div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;    <span class="comment">//cerr &lt;&lt; &quot; after head_mask &quot; &lt;&lt; head_mask &lt;&lt; &quot; head_place = &quot; &lt;&lt; head_place &lt;&lt; endl;</span></div><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;    <span class="keywordflow">return</span> ans;</div><div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;  }<span class="keywordflow">else</span>{</div><div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;    <span class="comment">// there is not enough bits in the current buffer.</span></div><div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;    <span class="comment">// So we should read head_place many bits from the current buffer</span></div><div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;    <span class="comment">// then read another chunk from input file</span></div><div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;    <span class="comment">// and then read k - head_place bits from the new buffer</span></div><div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;    <span class="comment">// we do these two steps recursively</span></div><div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;    <span class="comment">// but first need to store the number of bits we will have to read in the future, since these variables will be modified later:</span></div><div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> future_bits = k - <a class="code" href="classibitstream.html#a7b96359ac1534a5565e6e9b0cc53a0b3">head_place</a>;</div><div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> a = <a class="code" href="classibitstream.html#a2fdcaecf10fefa6942dcd5286a2696e0">read_bits</a>(head_place); <span class="comment">// the bits from the current buffer</span></div><div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;    <a class="code" href="classibitstream.html#ac62c26004436d83f337f4aeba0895e20">read_chunk</a>();</div><div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> b = <a class="code" href="classibitstream.html#a2fdcaecf10fefa6942dcd5286a2696e0">read_bits</a>(future_bits); <span class="comment">// bits from the next buffer</span></div><div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;    <span class="comment">// now we need to combine these</span></div><div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;    <span class="comment">// in order to do so, we need to shift a to the left and combine with b</span></div><div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;    <span class="comment">// but the number of bits we need to shift a is exactly future bits</span></div><div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;    a &lt;&lt;= future_bits;</div><div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;    <span class="keywordflow">return</span> a | b;</div><div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;  }</div><div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;}</div><div class="ttc" id="classibitstream_html_ac62c26004436d83f337f4aeba0895e20"><div class="ttname"><a href="classibitstream.html#ac62c26004436d83f337f4aeba0895e20">ibitstream::read_chunk</a></div><div class="ttdeci">void read_chunk()</div><div class="ttdoc">reads one chunk (4 bytes) from the input file and stores it in buffer </div><div class="ttdef"><b>Definition:</b> bitstream.cpp:266</div></div>
<div class="ttc" id="bitstream_8h_html_afcadf5aa65c5159bfb96c4d82ebc0a5d"><div class="ttname"><a href="bitstream_8h.html#afcadf5aa65c5159bfb96c4d82ebc0a5d">BIT_INT</a></div><div class="ttdeci">const unsigned int BIT_INT</div><div class="ttdef"><b>Definition:</b> bitstream.h:11</div></div>
<div class="ttc" id="classibitstream_html_a7b96359ac1534a5565e6e9b0cc53a0b3"><div class="ttname"><a href="classibitstream.html#a7b96359ac1534a5565e6e9b0cc53a0b3">ibitstream::head_place</a></div><div class="ttdeci">unsigned int head_place</div><div class="ttdoc">the place of head represented in terms of integer, LSB is 1, left of LSB is 2, 2 left of LSB is 3 and...</div><div class="ttdef"><b>Definition:</b> bitstream.h:116</div></div>
<div class="ttc" id="classibitstream_html_a73f0b24d3d4402369f1abbb43f7f70ef"><div class="ttname"><a href="classibitstream.html#a73f0b24d3d4402369f1abbb43f7f70ef">ibitstream::buffer</a></div><div class="ttdeci">unsigned int buffer</div><div class="ttdoc">the last chunk read from the input </div><div class="ttdef"><b>Definition:</b> bitstream.h:114</div></div>
<div class="ttc" id="classibitstream_html_a2fdcaecf10fefa6942dcd5286a2696e0"><div class="ttname"><a href="classibitstream.html#a2fdcaecf10fefa6942dcd5286a2696e0">ibitstream::read_bits</a></div><div class="ttdeci">unsigned int read_bits(unsigned int k)</div><div class="ttdoc">read k bits from the input, interpret it as integer (first bit read is MSB) and return its value...</div><div class="ttdef"><b>Definition:</b> bitstream.cpp:274</div></div>
<div class="ttc" id="classibitstream_html_a48cd41991b6c29ea5120b53873a72a70"><div class="ttname"><a href="classibitstream.html#a48cd41991b6c29ea5120b53873a72a70">ibitstream::head_mask</a></div><div class="ttdeci">unsigned int head_mask</div><div class="ttdoc">the place of the head bit in buffer, represented in terms of mask. So if we are in the LSB...</div><div class="ttdef"><b>Definition:</b> bitstream.h:115</div></div>
<div class="ttc" id="bitstream_8cpp_html_a6364b017a9400a38f7a994376bb3ebee"><div class="ttname"><a href="bitstream_8cpp.html#a6364b017a9400a38f7a994376bb3ebee">mask_gen</a></div><div class="ttdeci">unsigned int mask_gen(int n)</div><div class="ttdoc">generates a binary mask with n consecutive ones in LSB </div><div class="ttdef"><b>Definition:</b> bitstream.cpp:499</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a4bb7a698ab44c1e2fe21b4daa880bd6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bb7a698ab44c1e2fe21b4daa880bd6c">&#9670;&nbsp;</a></span>read_bits() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ibitstream::read_bits </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbit__pipe.html">bit_pipe</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>reads k bits from input and stores in the given <a class="el" href="classbit__pipe.html" title="A sequence of arbitrary number of bits. ">bit_pipe</a>. \(k \geq 1\) is arbitrary. The bits are stored in the <a class="el" href="classbit__pipe.html" title="A sequence of arbitrary number of bits. ">bit_pipe</a> so that can be interpreted as integer (e.g. mpz_class) so the LSB is located in the rightmost bit of the rightmost chunk (unlike the usual <a class="el" href="classbit__pipe.html" title="A sequence of arbitrary number of bits. ">bit_pipe</a> situation). We assume that the B given here is an empty <a class="el" href="classbit__pipe.html" title="A sequence of arbitrary number of bits. ">bit_pipe</a> </p>
<div class="fragment"><div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;                                            {</div><div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;  <span class="comment">//cerr &lt;&lt; &quot; read_bits &quot; &lt;&lt; k &lt;&lt; endl;</span></div><div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;  <span class="comment">// assumption: B is empty bit_pipe</span></div><div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;  <span class="keywordflow">if</span> (B.<a class="code" href="classbit__pipe.html#a86f38af1e9736b053728033490476b50">bits</a>.size() != 0 or B.<a class="code" href="classbit__pipe.html#a0f3e84b02751803adaab499b5dad86fe">last_bits</a> != 0){</div><div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;    cerr &lt;&lt; <span class="stringliteral">&quot; ERROR: ibitstream::read_bits(int k, bit_pipe&amp; B) must be called with an empty bit_pipe, a nonempty bitpipe is given with B.bits.size() = &quot;</span> &lt;&lt; B.<a class="code" href="classbit__pipe.html#a86f38af1e9736b053728033490476b50">bits</a>.size() &lt;&lt; endl;</div><div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;  }</div><div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;  <a class="code" href="classibitstream.html#acec2e9efa21551ce8db784f5b0bbd1b5">read_bits_append</a>(k, B);</div><div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;  <span class="comment">// there might be a few zero chunks at the beginning of B which are redundant, we remove them here</span></div><div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;  <span class="comment">// the number of nonzero chunks is exactly the floor of k / BIT_INT</span></div><div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;  <span class="keywordtype">int</span> nonzero_chunks = k / <a class="code" href="bitstream_8h.html#afcadf5aa65c5159bfb96c4d82ebc0a5d">BIT_INT</a>;</div><div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;  <span class="keywordflow">if</span> (k % <a class="code" href="bitstream_8h.html#afcadf5aa65c5159bfb96c4d82ebc0a5d">BIT_INT</a> != 0)</div><div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;    nonzero_chunks ++; <span class="comment">// take the floor</span></div><div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;  <span class="comment">//cerr &lt;&lt; &quot; nonzero_chunks &quot; &lt;&lt; nonzero_chunks &lt;&lt; endl;</span></div><div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;  <span class="keywordflow">if</span> (nonzero_chunks &lt; B.<a class="code" href="classbit__pipe.html#a86f38af1e9736b053728033490476b50">bits</a>.size())</div><div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;    B.<a class="code" href="classbit__pipe.html#a86f38af1e9736b053728033490476b50">bits</a>.erase(B.<a class="code" href="classbit__pipe.html#a86f38af1e9736b053728033490476b50">bits</a>.begin(), B.<a class="code" href="classbit__pipe.html#a86f38af1e9736b053728033490476b50">bits</a>.begin() + B.<a class="code" href="classbit__pipe.html#a86f38af1e9736b053728033490476b50">bits</a>.size() - nonzero_chunks);</div><div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;}</div><div class="ttc" id="bitstream_8h_html_afcadf5aa65c5159bfb96c4d82ebc0a5d"><div class="ttname"><a href="bitstream_8h.html#afcadf5aa65c5159bfb96c4d82ebc0a5d">BIT_INT</a></div><div class="ttdeci">const unsigned int BIT_INT</div><div class="ttdef"><b>Definition:</b> bitstream.h:11</div></div>
<div class="ttc" id="classbit__pipe_html_a0f3e84b02751803adaab499b5dad86fe"><div class="ttname"><a href="classbit__pipe.html#a0f3e84b02751803adaab499b5dad86fe">bit_pipe::last_bits</a></div><div class="ttdeci">int last_bits</div><div class="ttdoc">the number of bits in the last chunk (the last chunk starts from MSB, so the BIT_INT - last_bits many...</div><div class="ttdef"><b>Definition:</b> bitstream.h:24</div></div>
<div class="ttc" id="classibitstream_html_acec2e9efa21551ce8db784f5b0bbd1b5"><div class="ttname"><a href="classibitstream.html#acec2e9efa21551ce8db784f5b0bbd1b5">ibitstream::read_bits_append</a></div><div class="ttdeci">void read_bits_append(int k, bit_pipe &amp;B)</div><div class="ttdoc">similar to read_bits, but B does not have to be empty and the result will be appended to B (this is u...</div><div class="ttdef"><b>Definition:</b> bitstream.cpp:318</div></div>
<div class="ttc" id="classbit__pipe_html_a86f38af1e9736b053728033490476b50"><div class="ttname"><a href="classbit__pipe.html#a86f38af1e9736b053728033490476b50">bit_pipe::bits</a></div><div class="ttdeci">vector&lt; unsigned int &gt; bits</div><div class="ttdoc">a vector of chunks, each of size 4 bytes. This represents an arbitrary sequence of bits ...</div><div class="ttdef"><b>Definition:</b> bitstream.h:23</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="acec2e9efa21551ce8db784f5b0bbd1b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acec2e9efa21551ce8db784f5b0bbd1b5">&#9670;&nbsp;</a></span>read_bits_append()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ibitstream::read_bits_append </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbit__pipe.html">bit_pipe</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>similar to read_bits, but B does not have to be empty and the result will be appended to B (this is used in order to recursively implement read_bits) </p>
<div class="fragment"><div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;                                                   {</div><div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;  <span class="comment">//cout &lt;&lt; &quot; read_bits called k = &quot; &lt;&lt; k &lt;&lt; &quot; head_place = &quot; &lt;&lt; head_place &lt;&lt; endl;</span></div><div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;  <span class="comment">// by assumption, when calling this function, B has full chunks (last_bits is either zero so BIT_INT)</span></div><div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;  <span class="keywordflow">if</span> (k == 0)</div><div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;    <span class="keywordflow">return</span>; <span class="comment">// nothing remains to be done</span></div><div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;  <span class="keywordflow">if</span> (<a class="code" href="classibitstream.html#a7b96359ac1534a5565e6e9b0cc53a0b3">head_place</a> == 0){</div><div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;    <span class="comment">// we are over with the current bits in the buffer</span></div><div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;    <span class="comment">// so we need to load a few chunks from the input</span></div><div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;    <span class="comment">// we should append k / BIT_INT full chunks to B and then k % BIT_INT bits from the next chunk</span></div><div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> full_chunks = k / <a class="code" href="bitstream_8h.html#afcadf5aa65c5159bfb96c4d82ebc0a5d">BIT_INT</a>;</div><div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;    <span class="keywordflow">if</span> (full_chunks &gt; 0){</div><div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;      B.<a class="code" href="classbit__pipe.html#a86f38af1e9736b053728033490476b50">bits</a>.resize(B.<a class="code" href="classbit__pipe.html#a86f38af1e9736b053728033490476b50">bits</a>.size() + full_chunks);</div><div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;      fread(&amp;B.<a class="code" href="classbit__pipe.html#a86f38af1e9736b053728033490476b50">bits</a>[B.<a class="code" href="classbit__pipe.html#a86f38af1e9736b053728033490476b50">bits</a>.size() - full_chunks], <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> int), full_chunks, <a class="code" href="classibitstream.html#a3ea2cdd0cf97820f0e1520c42e364308">f</a>); <span class="comment">// read full_chunks many chunks</span></div><div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;      B.<a class="code" href="classbit__pipe.html#a0f3e84b02751803adaab499b5dad86fe">last_bits</a> = <a class="code" href="bitstream_8h.html#afcadf5aa65c5159bfb96c4d82ebc0a5d">BIT_INT</a>; <span class="comment">// the last chunk contains full bits </span></div><div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;    }</div><div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> res_bits = k % <a class="code" href="bitstream_8h.html#afcadf5aa65c5159bfb96c4d82ebc0a5d">BIT_INT</a>; <span class="comment">// the remaining bits to be read</span></div><div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;    <span class="keywordflow">if</span> (res_bits &gt; 0){</div><div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;      <span class="comment">// we need to read an extra res bits</span></div><div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> res = <a class="code" href="classibitstream.html#a2fdcaecf10fefa6942dcd5286a2696e0">read_bits</a> (res_bits); <span class="comment">// read res many bits</span></div><div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;      <span class="comment">// we should shift res_bits so that its MSB is the leftmost bits of the chunk</span></div><div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;      res &lt;&lt;= (<a class="code" href="bitstream_8h.html#afcadf5aa65c5159bfb96c4d82ebc0a5d">BIT_INT</a> - res_bits);</div><div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;      B.<a class="code" href="classbit__pipe.html#a86f38af1e9736b053728033490476b50">bits</a>.push_back(res);</div><div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;      B.<a class="code" href="classbit__pipe.html#a0f3e84b02751803adaab499b5dad86fe">last_bits</a> = res_bits;</div><div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;    }</div><div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;  }<span class="keywordflow">else</span>{</div><div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;    <span class="keywordflow">if</span> (k &lt;= <a class="code" href="classibitstream.html#a7b96359ac1534a5565e6e9b0cc53a0b3">head_place</a>){</div><div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;      <span class="comment">// there are enough bits to read</span></div><div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> a = <a class="code" href="classibitstream.html#a2fdcaecf10fefa6942dcd5286a2696e0">read_bits</a>(k);</div><div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;      <span class="comment">// no need to shift a since we need LSB of a to be in the rightmost bit</span></div><div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;      B.<a class="code" href="classbit__pipe.html#a86f38af1e9736b053728033490476b50">bits</a>.push_back(a);</div><div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;      B.<a class="code" href="classbit__pipe.html#a0f3e84b02751803adaab499b5dad86fe">last_bits</a> = <a class="code" href="bitstream_8h.html#afcadf5aa65c5159bfb96c4d82ebc0a5d">BIT_INT</a>;</div><div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;    }<span class="keywordflow">else</span>{</div><div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;      <span class="comment">// read head_place bits and call again</span></div><div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> future_read; <span class="comment">// number of bits to read in future after calling the read_bits function below</span></div><div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;      future_read = k - <a class="code" href="classibitstream.html#a7b96359ac1534a5565e6e9b0cc53a0b3">head_place</a>; </div><div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> a = <a class="code" href="classibitstream.html#a2fdcaecf10fefa6942dcd5286a2696e0">read_bits</a>(head_place);</div><div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;      B.<a class="code" href="classbit__pipe.html#a86f38af1e9736b053728033490476b50">bits</a>.push_back(a);</div><div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;      B.<a class="code" href="classbit__pipe.html#a0f3e84b02751803adaab499b5dad86fe">last_bits</a> = <a class="code" href="bitstream_8h.html#afcadf5aa65c5159bfb96c4d82ebc0a5d">BIT_INT</a>;</div><div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;      <a class="code" href="classibitstream.html#acec2e9efa21551ce8db784f5b0bbd1b5">read_bits_append</a>(future_read, B); <span class="comment">// read the remaining bits </span></div><div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;    }</div><div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;  }</div><div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;</div><div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;  B.<a class="code" href="classbit__pipe.html#a341a1f62d728a67f730503ca722a7770">shift_right</a>(<a class="code" href="bitstream_8h.html#afcadf5aa65c5159bfb96c4d82ebc0a5d">BIT_INT</a> - B.<a class="code" href="classbit__pipe.html#a0f3e84b02751803adaab499b5dad86fe">last_bits</a>); <span class="comment">// so that LSB of B is the rightmost bit of the lats chunk.</span></div><div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;</div><div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;  <span class="comment">// this is important to make sure that B is correctly representing an integer and can be converted to mpz_class</span></div><div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;  <span class="comment">// TODO issue of 2^k - 1 correct</span></div><div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;}</div><div class="ttc" id="bitstream_8h_html_afcadf5aa65c5159bfb96c4d82ebc0a5d"><div class="ttname"><a href="bitstream_8h.html#afcadf5aa65c5159bfb96c4d82ebc0a5d">BIT_INT</a></div><div class="ttdeci">const unsigned int BIT_INT</div><div class="ttdef"><b>Definition:</b> bitstream.h:11</div></div>
<div class="ttc" id="classibitstream_html_a7b96359ac1534a5565e6e9b0cc53a0b3"><div class="ttname"><a href="classibitstream.html#a7b96359ac1534a5565e6e9b0cc53a0b3">ibitstream::head_place</a></div><div class="ttdeci">unsigned int head_place</div><div class="ttdoc">the place of head represented in terms of integer, LSB is 1, left of LSB is 2, 2 left of LSB is 3 and...</div><div class="ttdef"><b>Definition:</b> bitstream.h:116</div></div>
<div class="ttc" id="classbit__pipe_html_a341a1f62d728a67f730503ca722a7770"><div class="ttname"><a href="classbit__pipe.html#a341a1f62d728a67f730503ca722a7770">bit_pipe::shift_right</a></div><div class="ttdeci">void shift_right(int n)</div><div class="ttdoc">shifts n bits to the right. </div><div class="ttdef"><b>Definition:</b> bitstream.cpp:43</div></div>
<div class="ttc" id="classibitstream_html_a2fdcaecf10fefa6942dcd5286a2696e0"><div class="ttname"><a href="classibitstream.html#a2fdcaecf10fefa6942dcd5286a2696e0">ibitstream::read_bits</a></div><div class="ttdeci">unsigned int read_bits(unsigned int k)</div><div class="ttdoc">read k bits from the input, interpret it as integer (first bit read is MSB) and return its value...</div><div class="ttdef"><b>Definition:</b> bitstream.cpp:274</div></div>
<div class="ttc" id="classibitstream_html_a3ea2cdd0cf97820f0e1520c42e364308"><div class="ttname"><a href="classibitstream.html#a3ea2cdd0cf97820f0e1520c42e364308">ibitstream::f</a></div><div class="ttdeci">FILE * f</div><div class="ttdoc">pointer to input binary file </div><div class="ttdef"><b>Definition:</b> bitstream.h:113</div></div>
<div class="ttc" id="classbit__pipe_html_a0f3e84b02751803adaab499b5dad86fe"><div class="ttname"><a href="classbit__pipe.html#a0f3e84b02751803adaab499b5dad86fe">bit_pipe::last_bits</a></div><div class="ttdeci">int last_bits</div><div class="ttdoc">the number of bits in the last chunk (the last chunk starts from MSB, so the BIT_INT - last_bits many...</div><div class="ttdef"><b>Definition:</b> bitstream.h:24</div></div>
<div class="ttc" id="classibitstream_html_acec2e9efa21551ce8db784f5b0bbd1b5"><div class="ttname"><a href="classibitstream.html#acec2e9efa21551ce8db784f5b0bbd1b5">ibitstream::read_bits_append</a></div><div class="ttdeci">void read_bits_append(int k, bit_pipe &amp;B)</div><div class="ttdoc">similar to read_bits, but B does not have to be empty and the result will be appended to B (this is u...</div><div class="ttdef"><b>Definition:</b> bitstream.cpp:318</div></div>
<div class="ttc" id="classbit__pipe_html_a86f38af1e9736b053728033490476b50"><div class="ttname"><a href="classbit__pipe.html#a86f38af1e9736b053728033490476b50">bit_pipe::bits</a></div><div class="ttdeci">vector&lt; unsigned int &gt; bits</div><div class="ttdoc">a vector of chunks, each of size 4 bytes. This represents an arbitrary sequence of bits ...</div><div class="ttdef"><b>Definition:</b> bitstream.h:23</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ac62c26004436d83f337f4aeba0895e20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac62c26004436d83f337f4aeba0895e20">&#9670;&nbsp;</a></span>read_chunk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ibitstream::read_chunk </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>reads one chunk (4 bytes) from the input file and stores it in buffer </p>
<div class="fragment"><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;                           {</div><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;  fread(&amp;<a class="code" href="classibitstream.html#a73f0b24d3d4402369f1abbb43f7f70ef">buffer</a>, <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>), 1, <a class="code" href="classibitstream.html#a3ea2cdd0cf97820f0e1520c42e364308">f</a>);</div><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;  <span class="comment">//cout &lt;&lt; &quot; in read chunk  buffer = &quot; &lt;&lt; bitset&lt;32&gt;(buffer) &lt;&lt; endl;</span></div><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;  <a class="code" href="classibitstream.html#a48cd41991b6c29ea5120b53873a72a70">head_mask</a> = 1 &lt;&lt; (<a class="code" href="bitstream_8h.html#afcadf5aa65c5159bfb96c4d82ebc0a5d">BIT_INT</a> - 1); <span class="comment">// pointing to the MSB which is the first bit to consider</span></div><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;  <a class="code" href="classibitstream.html#a7b96359ac1534a5565e6e9b0cc53a0b3">head_place</a> = <a class="code" href="bitstream_8h.html#afcadf5aa65c5159bfb96c4d82ebc0a5d">BIT_INT</a>;</div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;}</div><div class="ttc" id="bitstream_8h_html_afcadf5aa65c5159bfb96c4d82ebc0a5d"><div class="ttname"><a href="bitstream_8h.html#afcadf5aa65c5159bfb96c4d82ebc0a5d">BIT_INT</a></div><div class="ttdeci">const unsigned int BIT_INT</div><div class="ttdef"><b>Definition:</b> bitstream.h:11</div></div>
<div class="ttc" id="classibitstream_html_a7b96359ac1534a5565e6e9b0cc53a0b3"><div class="ttname"><a href="classibitstream.html#a7b96359ac1534a5565e6e9b0cc53a0b3">ibitstream::head_place</a></div><div class="ttdeci">unsigned int head_place</div><div class="ttdoc">the place of head represented in terms of integer, LSB is 1, left of LSB is 2, 2 left of LSB is 3 and...</div><div class="ttdef"><b>Definition:</b> bitstream.h:116</div></div>
<div class="ttc" id="classibitstream_html_a73f0b24d3d4402369f1abbb43f7f70ef"><div class="ttname"><a href="classibitstream.html#a73f0b24d3d4402369f1abbb43f7f70ef">ibitstream::buffer</a></div><div class="ttdeci">unsigned int buffer</div><div class="ttdoc">the last chunk read from the input </div><div class="ttdef"><b>Definition:</b> bitstream.h:114</div></div>
<div class="ttc" id="classibitstream_html_a3ea2cdd0cf97820f0e1520c42e364308"><div class="ttname"><a href="classibitstream.html#a3ea2cdd0cf97820f0e1520c42e364308">ibitstream::f</a></div><div class="ttdeci">FILE * f</div><div class="ttdoc">pointer to input binary file </div><div class="ttdef"><b>Definition:</b> bitstream.h:113</div></div>
<div class="ttc" id="classibitstream_html_a48cd41991b6c29ea5120b53873a72a70"><div class="ttname"><a href="classibitstream.html#a48cd41991b6c29ea5120b53873a72a70">ibitstream::head_mask</a></div><div class="ttdeci">unsigned int head_mask</div><div class="ttdoc">the place of the head bit in buffer, represented in terms of mask. So if we are in the LSB...</div><div class="ttdef"><b>Definition:</b> bitstream.h:115</div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a73f0b24d3d4402369f1abbb43f7f70ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73f0b24d3d4402369f1abbb43f7f70ef">&#9670;&nbsp;</a></span>buffer</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ibitstream::buffer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>the last chunk read from the input </p>

</div>
</div>
<a id="a3ea2cdd0cf97820f0e1520c42e364308"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ea2cdd0cf97820f0e1520c42e364308">&#9670;&nbsp;</a></span>f</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FILE* ibitstream::f</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>pointer to input binary file </p>

</div>
</div>
<a id="a48cd41991b6c29ea5120b53873a72a70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48cd41991b6c29ea5120b53873a72a70">&#9670;&nbsp;</a></span>head_mask</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ibitstream::head_mask</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>the place of the head bit in buffer, represented in terms of mask. So if we are in the LSB, head_mask is one, if we are in two bit left of LSB, this is 4 so on. When this is zero, it means the buffer is expired and we should probably read one more chunk from the input file </p>

</div>
</div>
<a id="a7b96359ac1534a5565e6e9b0cc53a0b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b96359ac1534a5565e6e9b0cc53a0b3">&#9670;&nbsp;</a></span>head_place</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ibitstream::head_place</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>the place of head represented in terms of integer, LSB is 1, left of LSB is 2, 2 left of LSB is 3 and so on. head_place is effectively the number of unread bits remaining in the buffer. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="bitstream_8h_source.html">bitstream.h</a></li>
<li><a class="el" href="bitstream_8cpp.html">bitstream.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
