\hypertarget{classb__graph__encoder}{}\section{b\+\_\+graph\+\_\+encoder Class Reference}
\label{classb__graph__encoder}\index{b\+\_\+graph\+\_\+encoder@{b\+\_\+graph\+\_\+encoder}}


Encodes a simple unmarked bipartite graph.  




{\ttfamily \#include $<$bipartite\+\_\+graph\+\_\+compression.\+h$>$}

\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classb__graph__encoder_a77b8fc4f060a8ef159583f1cfa35f283}{b\+\_\+graph\+\_\+encoder} (vector$<$ int $>$ a\+\_\+, vector$<$ int $>$ b\+\_\+)
\begin{DoxyCompactList}\small\item\em constructor \end{DoxyCompactList}\item 
void \hyperlink{classb__graph__encoder_a9b62ac0580191ac42b98d764046af7cb}{init} (const \hyperlink{classb__graph}{b\+\_\+graph} \&G)
\begin{DoxyCompactList}\small\item\em initializes beta and U \end{DoxyCompactList}\item 
pair$<$ mpz\+\_\+class, mpz\+\_\+class $>$ \hyperlink{classb__graph__encoder_a3ffcfb945e8563d01e683fc5e5127d6d}{compute\+\_\+N} (int i, int j, const \hyperlink{classb__graph}{b\+\_\+graph} \&G)
\begin{DoxyCompactList}\small\item\em computes $N_{i,j}(G)$ \end{DoxyCompactList}\item 
pair$<$ mpz\+\_\+class, mpz\+\_\+class $>$ \hyperlink{classb__graph__encoder_abb9153c776f8c9ec9aeb6361080e84d4}{compute\+\_\+\+N\+\_\+new} (const \hyperlink{classb__graph}{b\+\_\+graph} \&G)
\item 
mpz\+\_\+class \hyperlink{classb__graph__encoder_a9dbf40f42a2eb12822b14ca10d580763}{encode} (const \hyperlink{classb__graph}{b\+\_\+graph} \&G)
\begin{DoxyCompactList}\small\item\em encodes the given bipartite graph $G$ and returns an integer in the specified range \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
vector$<$ int $>$ \hyperlink{classb__graph__encoder_ae54d76cc4cee399d98951f870897a144}{beta}
\begin{DoxyCompactList}\small\item\em when compute\+\_\+N is called for $i \leq j$, for $ i \leq v \leq n$, we have beta\mbox{[}v\mbox{]} = $b_v(i)$ \end{DoxyCompactList}\item 
vector$<$ int $>$ \hyperlink{classb__graph__encoder_afd22d167f495cd85b41397f337c377c2}{a}
\begin{DoxyCompactList}\small\item\em the degree sequence for the left nodes \end{DoxyCompactList}\item 
vector$<$ int $>$ \hyperlink{classb__graph__encoder_a767826e268702e45ab71565e096a52b8}{b}
\begin{DoxyCompactList}\small\item\em the degree sequence for the right nodes \end{DoxyCompactList}\item 
\hyperlink{classreverse__fenwick__tree}{reverse\+\_\+fenwick\+\_\+tree} \hyperlink{classb__graph__encoder_ac810138443002a2b2cf579ced2dc34ce}{U}
\begin{DoxyCompactList}\small\item\em a Fenwick tree which encodes the degree of right nodes. When compute\+\_\+N is called for $i \leq j$, for $i \leq v \leq n$, we have U.\+sum\mbox{[}v\mbox{]} $= \sum_{k = v}^n b_k(i)$. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
Encodes a simple unmarked bipartite graph. 

Encodes a simple bipartite graph in the set of bipartite graphs with given left degree sequence a and right degree sequence b. Therefore, to construct an encoder object, we need to specify these two degree sequences as vectors of int. For instance (in c++11)


\begin{DoxyCode}
vector<int> a = \{1,1,2\};
vector<int> b = \{2,2\};
\hyperlink{classb__graph__encoder}{b\_graph\_encoder} E(a,b);
\end{DoxyCode}


constructs an encode object E which is capable of encoding bipartite graphs having 3 left nodes with degrees 1, 1, 2 (in order) and 2 right nodes with degrees 2,2 (in order). Hence, assume that we have defined such a bipartite graph by giving adjacency list\+:


\begin{DoxyCode}
\hyperlink{classb__graph}{b\_graph} G(\{\{0\},\{1\},\{0,1\}\});
\end{DoxyCode}


Note that G has left and right degree sequences which are equal to a and b, respectively. Then, we can use E to encode G as follows\+:


\begin{DoxyCode}
mpz\_class f = E.encode(G);
\end{DoxyCode}


In this way, the encode converts G to an integer stored in f. Later on, we can use f to decode G. 

\subsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classb__graph__encoder_a77b8fc4f060a8ef159583f1cfa35f283}\label{classb__graph__encoder_a77b8fc4f060a8ef159583f1cfa35f283}} 
\index{b\+\_\+graph\+\_\+encoder@{b\+\_\+graph\+\_\+encoder}!b\+\_\+graph\+\_\+encoder@{b\+\_\+graph\+\_\+encoder}}
\index{b\+\_\+graph\+\_\+encoder@{b\+\_\+graph\+\_\+encoder}!b\+\_\+graph\+\_\+encoder@{b\+\_\+graph\+\_\+encoder}}
\subsubsection{\texorpdfstring{b\+\_\+graph\+\_\+encoder()}{b\_graph\_encoder()}}
{\footnotesize\ttfamily b\+\_\+graph\+\_\+encoder\+::b\+\_\+graph\+\_\+encoder (\begin{DoxyParamCaption}\item[{vector$<$ int $>$}]{a\+\_\+,  }\item[{vector$<$ int $>$}]{b\+\_\+ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



constructor 


\begin{DoxyCode}
46 : \hyperlink{classb__graph__encoder_afd22d167f495cd85b41397f337c377c2}{a}(a\_), \hyperlink{classb__graph__encoder_a767826e268702e45ab71565e096a52b8}{b}(b\_) \{\}
\end{DoxyCode}


\subsection{Member Function Documentation}
\mbox{\Hypertarget{classb__graph__encoder_a3ffcfb945e8563d01e683fc5e5127d6d}\label{classb__graph__encoder_a3ffcfb945e8563d01e683fc5e5127d6d}} 
\index{b\+\_\+graph\+\_\+encoder@{b\+\_\+graph\+\_\+encoder}!compute\+\_\+N@{compute\+\_\+N}}
\index{compute\+\_\+N@{compute\+\_\+N}!b\+\_\+graph\+\_\+encoder@{b\+\_\+graph\+\_\+encoder}}
\subsubsection{\texorpdfstring{compute\+\_\+\+N()}{compute\_N()}}
{\footnotesize\ttfamily pair$<$ mpz\+\_\+class, mpz\+\_\+class $>$ b\+\_\+graph\+\_\+encoder\+::compute\+\_\+N (\begin{DoxyParamCaption}\item[{int}]{i,  }\item[{int}]{j,  }\item[{const \hyperlink{classb__graph}{b\+\_\+graph} \&}]{G }\end{DoxyParamCaption})}



computes $N_{i,j}(G)$ 


\begin{DoxyParams}{Parameters}
{\em i,j} & the interval for which we compute $N_{i,j}(G)$ \\
\hline
{\em G} & reference to the bipartite graph for which we compute N \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A pair, where the first component is $N_{i,j}(G)$, and the second component is $l_{i,j}(G)$ 
\end{DoxyReturn}

\begin{DoxyCode}
24 \{
25   mpz\_class Nij = 0;
26   mpz\_class lij = 1;
27   \textcolor{keywordflow}{if} (i == j)\{
28     vector<int> x = G.\hyperlink{classb__graph_aa81c7179b9c6cb4986c4b41e84a85799}{get\_adj\_list}(i); \textcolor{comment}{// the adjacency list of the vertex}
29     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} k=0;k<\hyperlink{classb__graph__encoder_afd22d167f495cd85b41397f337c377c2}{a}[i];k++)\{
30       Nij += lij * \hyperlink{compression__helper_8cpp_acecca9cb279d3b3d82915a07d67818cf}{binomial}(\hyperlink{classb__graph__encoder_ac810138443002a2b2cf579ced2dc34ce}{U}.\hyperlink{classreverse__fenwick__tree_a672731fd6395b4853430073a099a80e6}{sum}(1+x[k]), a[i] - k);
31       lij *= \hyperlink{classb__graph__encoder_ae54d76cc4cee399d98951f870897a144}{beta}[x[k]];
32       \hyperlink{classb__graph__encoder_ae54d76cc4cee399d98951f870897a144}{beta}[x[k]] --;
33       \hyperlink{classb__graph__encoder_ac810138443002a2b2cf579ced2dc34ce}{U}.\hyperlink{classreverse__fenwick__tree_a942d7f49b37e53ebfec3076d177691d7}{add}(x[k],-1);
34     \}
35     \textcolor{keywordflow}{return} pair<mpz\_class, mpz\_class> (Nij, lij);
36   \}\textcolor{keywordflow}{else}\{
37     \textcolor{keywordtype}{int} t = (i+j)/ 2;
38     mpz\_class Nit, lit; \textcolor{comment}{// for the left subinterval i, j}
39     mpz\_class Ntj, ltj; \textcolor{comment}{// for the right subinterval t+1, j}
40     mpz\_class Nij, lij; \textcolor{comment}{// to return}
41     \textcolor{keywordtype}{int} St; \textcolor{comment}{// S\_\{t+1\}}
42     \textcolor{keywordtype}{int} Sj; \textcolor{comment}{// S\_\{j+1\}}
43 
44     pair<mpz\_class, mpz\_class> ans; \textcolor{comment}{// for collecting the results from subintervals}
45 
46     \textcolor{comment}{// left subinterval}
47     ans = \hyperlink{classb__graph__encoder_a3ffcfb945e8563d01e683fc5e5127d6d}{compute\_N}(i,t, G);
48     Nit = ans.first;
49     lit = ans.second;
50     St = \hyperlink{classb__graph__encoder_ac810138443002a2b2cf579ced2dc34ce}{U}.\hyperlink{classreverse__fenwick__tree_a672731fd6395b4853430073a099a80e6}{sum}(0);
51 
52     \textcolor{comment}{// right subinterval}
53     ans = \hyperlink{classb__graph__encoder_a3ffcfb945e8563d01e683fc5e5127d6d}{compute\_N}(t+1, j, G);
54     Ntj = ans.first;
55     ltj = ans.second;
56     Sj = \hyperlink{classb__graph__encoder_ac810138443002a2b2cf579ced2dc34ce}{U}.\hyperlink{classreverse__fenwick__tree_a672731fd6395b4853430073a099a80e6}{sum}(0);
57 
58     mpz\_class rtj; \textcolor{comment}{// r\_\{t+1, j\}}
59     mpz\_class prod\_afac = \hyperlink{compression__helper_8cpp_a86d8a20e022dc06b23df3b08ac10b7d1}{prod\_factorial}(a, t+1, j);; \textcolor{comment}{// the product of a\_k! for t + 1 <= k
       <= j}
60 
61 
62     rtj = \hyperlink{compression__helper_8cpp_ae2afb43aabe50f7d42aae8f82b5a35f4}{compute\_product}(St, St - Sj, 1) / prod\_afac; 
63 
64     Nij = Nit * rtj + lit * Ntj;
65     lij = lit * ltj;
66     \textcolor{keywordflow}{return} pair<mpz\_class, mpz\_class>(Nij, lij);
67   \}
68 \}
\end{DoxyCode}
\mbox{\Hypertarget{classb__graph__encoder_abb9153c776f8c9ec9aeb6361080e84d4}\label{classb__graph__encoder_abb9153c776f8c9ec9aeb6361080e84d4}} 
\index{b\+\_\+graph\+\_\+encoder@{b\+\_\+graph\+\_\+encoder}!compute\+\_\+\+N\+\_\+new@{compute\+\_\+\+N\+\_\+new}}
\index{compute\+\_\+\+N\+\_\+new@{compute\+\_\+\+N\+\_\+new}!b\+\_\+graph\+\_\+encoder@{b\+\_\+graph\+\_\+encoder}}
\subsubsection{\texorpdfstring{compute\+\_\+\+N\+\_\+new()}{compute\_N\_new()}}
{\footnotesize\ttfamily pair$<$ mpz\+\_\+class, mpz\+\_\+class $>$ b\+\_\+graph\+\_\+encoder\+::compute\+\_\+\+N\+\_\+new (\begin{DoxyParamCaption}\item[{const \hyperlink{classb__graph}{b\+\_\+graph} \&}]{G }\end{DoxyParamCaption})}


\begin{DoxyCode}
71                                                                          \{
72   \textcolor{comment}{//logger::item\_start("bip init");}
73   \textcolor{keywordtype}{int} n\_l = G.\hyperlink{classb__graph_a5e71d5c97f2501b0b93c17146cf7e68e}{nu\_left\_vertices}(); \textcolor{comment}{// number of left vertices}
74   \textcolor{keywordtype}{int} n\_bits = 0;
75   \textcolor{keywordtype}{int} n\_copy = n\_l;
76   \textcolor{keywordflow}{while} (n\_copy > 0)\{
77     n\_bits ++;
78     n\_copy >>= 1;
79   \}
80   n\_bits += 2;
81 
82   vector<pair<int, int> > call\_stack(2 * n\_bits);
83   vector<pair<mpz\_class, mpz\_class> > \hyperlink{namespacehelper__vars_a6d2100c373830cacd232319a9958652d}{return\_stack}(2 * n\_bits); \textcolor{comment}{// first = N, second = l}
84   vector<int> status\_stack(2 * n\_bits);
85   vector<int> St\_stack(2 * n\_bits); \textcolor{comment}{// stack to store values of St}
86  
87   call\_stack[0] = pair<int, int> (0,n\_l-1); \textcolor{comment}{// i j }
88   status\_stack[0] = 0; \textcolor{comment}{// newly added}
89  
90   \textcolor{keywordtype}{int} call\_size = 1; \textcolor{comment}{// the size of the call stack}
91   \textcolor{keywordtype}{int} return\_size = 0; \textcolor{comment}{// the size of the return stack}
92 
93   \textcolor{keywordtype}{int} i, j, t, Sj;
94   \textcolor{keywordtype}{int} status;
95  
96   vector<int> gamma; \textcolor{comment}{// forward list  of the graph}
97 
98   mpz\_class rtj, prod\_afac, Nit\_rtj, lit\_Ntj;
99   \textcolor{comment}{//logger::item\_stop("bip init");}
100   \textcolor{keywordflow}{while}(call\_size > 0)\{
101     \textcolor{comment}{//cerr << " call\_size " << call\_size << endl;}
102     i = call\_stack[call\_size-1].first;
103     j = call\_stack[call\_size-1].second;
104     \textcolor{keywordflow}{if} (i==j)\{
105       \textcolor{comment}{//logger::item\_start("bip enc i = j");}
106       \hyperlink{namespacehelper__vars_a6d2100c373830cacd232319a9958652d}{return\_stack}[return\_size].first = 0; \textcolor{comment}{// N\_\{i,j\} is initialized with 0}
107       \hyperlink{namespacehelper__vars_a6d2100c373830cacd232319a9958652d}{return\_stack}[return\_size].second = 1; \textcolor{comment}{// l\_\{i,j\} is initialized with 1}
108       gamma = G.\hyperlink{classb__graph_aa81c7179b9c6cb4986c4b41e84a85799}{get\_adj\_list}(i);
109       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} k=0;k<\hyperlink{classb__graph__encoder_afd22d167f495cd85b41397f337c377c2}{a}[i];k++)\{
110         \hyperlink{namespacehelper__vars_a6d2100c373830cacd232319a9958652d}{return\_stack}[return\_size].first += \hyperlink{namespacehelper__vars_a6d2100c373830cacd232319a9958652d}{return\_stack}[return\_size].second * 
      \hyperlink{compression__helper_8cpp_acecca9cb279d3b3d82915a07d67818cf}{binomial}(\hyperlink{classb__graph__encoder_ac810138443002a2b2cf579ced2dc34ce}{U}.\hyperlink{classreverse__fenwick__tree_a672731fd6395b4853430073a099a80e6}{sum}(1+gamma[k]), a[i] - k);
111         \hyperlink{namespacehelper__vars_a6d2100c373830cacd232319a9958652d}{return\_stack}[return\_size].second *= \hyperlink{classb__graph__encoder_ae54d76cc4cee399d98951f870897a144}{beta}[gamma[k]];
112         \hyperlink{classb__graph__encoder_ae54d76cc4cee399d98951f870897a144}{beta}[gamma[k]] --;
113         \hyperlink{classb__graph__encoder_ac810138443002a2b2cf579ced2dc34ce}{U}.\hyperlink{classreverse__fenwick__tree_a942d7f49b37e53ebfec3076d177691d7}{add}(gamma[k],-1);
114       \}
115       return\_size ++;
116       call\_size --;
117       \textcolor{comment}{//logger::item\_stop("bip enc i = j");}
118     \}\textcolor{keywordflow}{else}\{
119       t = (i+j)/2;
120       status = status\_stack[call\_size - 1];
121       \textcolor{keywordflow}{if} (status == 0)\{
122         \textcolor{comment}{// newly added, left node must be called}
123         call\_stack[call\_size].first = i;
124         call\_stack[call\_size].second = t;
125         status\_stack[call\_size-1] = 1; \textcolor{comment}{// left is called}
126         status\_stack[call\_size] = 0; \textcolor{comment}{// newly added}
127         call\_size++;
128       \}
129       \textcolor{keywordflow}{if} (status == 1)\{
130         \textcolor{comment}{// left is returned}
131         St\_stack[call\_size-1] = \hyperlink{classb__graph__encoder_ac810138443002a2b2cf579ced2dc34ce}{U}.\hyperlink{classreverse__fenwick__tree_a672731fd6395b4853430073a099a80e6}{sum}(0);
132         \textcolor{comment}{// call the right child}
133         call\_stack[call\_size].first = t+1;
134         call\_stack[call\_size].second = j;
135         status\_stack[call\_size-1] = 2; \textcolor{comment}{//right is called}
136         status\_stack[call\_size] = 0;  \textcolor{comment}{// newly called}
137         call\_size ++;
138       \}
139       \textcolor{keywordflow}{if} (status == 2)\{
140         Sj = \hyperlink{classb__graph__encoder_ac810138443002a2b2cf579ced2dc34ce}{U}.\hyperlink{classreverse__fenwick__tree_a672731fd6395b4853430073a099a80e6}{sum}(0);
141         \textcolor{comment}{//logger::item\_start("bip enc i neq j prod\_factorial");}
142         prod\_afac = \hyperlink{compression__helper_8cpp_a86d8a20e022dc06b23df3b08ac10b7d1}{prod\_factorial}(a, t+1, j); \textcolor{comment}{// the product of a\_k! for t + 1 <= k <= j}
143         \textcolor{comment}{//logger::item\_stop("bip enc i neq j prod\_factorial");}
144 
145         \textcolor{comment}{//logger::item\_start("bip enc i neq j compute\_product");}
146         rtj = \hyperlink{compression__helper_8cpp_ae2afb43aabe50f7d42aae8f82b5a35f4}{compute\_product}(St\_stack[call\_size-1], St\_stack[call\_size-1] - Sj, 1) / 
      prod\_afac;
147         \textcolor{comment}{//logger::item\_stop("bip enc i neq j compute\_product");}
148 
149         \textcolor{comment}{//logger::item\_start("bip enc i neq j arithmetic");}
150         Nit\_rtj = \hyperlink{namespacehelper__vars_a6d2100c373830cacd232319a9958652d}{return\_stack}[return\_size-2].first * rtj;
151         lit\_Ntj = \hyperlink{namespacehelper__vars_a6d2100c373830cacd232319a9958652d}{return\_stack}[return\_size-2].second * \hyperlink{namespacehelper__vars_a6d2100c373830cacd232319a9958652d}{return\_stack}[return\_size-1].
      first;
152         \hyperlink{namespacehelper__vars_a6d2100c373830cacd232319a9958652d}{return\_stack}[return\_size-2].first = Nit\_rtj + lit\_Ntj; \textcolor{comment}{// Nij}
153         \hyperlink{namespacehelper__vars_a6d2100c373830cacd232319a9958652d}{return\_stack}[return\_size-2].second = \hyperlink{namespacehelper__vars_a6d2100c373830cacd232319a9958652d}{return\_stack}[return\_size-2].second * 
      \hyperlink{namespacehelper__vars_a6d2100c373830cacd232319a9958652d}{return\_stack}[return\_size-1].second; \textcolor{comment}{// lij}
154         \textcolor{comment}{//logger::item\_stop("bip enc i neq j arithmetic");}
155         return\_size --; \textcolor{comment}{// pop 2 add 1}
156         call\_size --;
157       \}
158     \}
159 
160   \}
161   \textcolor{keywordflow}{if} (return\_size != 1)\{
162     cerr << \textcolor{stringliteral}{" error: bip compute\_N return\_size is not 1 it is "} << return\_size << endl;
163   \}
164   \textcolor{keywordflow}{return} \hyperlink{namespacehelper__vars_a6d2100c373830cacd232319a9958652d}{return\_stack}[0];
165 \}
\end{DoxyCode}
\mbox{\Hypertarget{classb__graph__encoder_a9dbf40f42a2eb12822b14ca10d580763}\label{classb__graph__encoder_a9dbf40f42a2eb12822b14ca10d580763}} 
\index{b\+\_\+graph\+\_\+encoder@{b\+\_\+graph\+\_\+encoder}!encode@{encode}}
\index{encode@{encode}!b\+\_\+graph\+\_\+encoder@{b\+\_\+graph\+\_\+encoder}}
\subsubsection{\texorpdfstring{encode()}{encode()}}
{\footnotesize\ttfamily mpz\+\_\+class b\+\_\+graph\+\_\+encoder\+::encode (\begin{DoxyParamCaption}\item[{const \hyperlink{classb__graph}{b\+\_\+graph} \&}]{G }\end{DoxyParamCaption})}



encodes the given bipartite graph $G$ and returns an integer in the specified range 


\begin{DoxyCode}
169 \{
170   \textcolor{keywordflow}{if} (\hyperlink{classb__graph__encoder_afd22d167f495cd85b41397f337c377c2}{a} != G.\hyperlink{classb__graph_afd65fb655f7e24217393a10533b87d3c}{get\_left\_degree\_sequence}() or \hyperlink{classb__graph__encoder_a767826e268702e45ab71565e096a52b8}{b} != G.
      \hyperlink{classb__graph_a2711566385b92b02f4c03abdc1f9a582}{get\_right\_degree\_sequence}())
171     cerr << \textcolor{stringliteral}{" WARNING b\_graph\_encoder::encoder : vectors a and/or b do not match with the degree sequences
       of the given bipartite graph  "} << endl;
172 
173   \textcolor{comment}{//init(G); // initialize U and beta for G}
174   \textcolor{comment}{//pair<mpz\_class, mpz\_class> ans = compute\_N(0,G.nu\_left\_vertices()-1, G);}
175   \hyperlink{classb__graph__encoder_a9b62ac0580191ac42b98d764046af7cb}{init}(G);
176   pair<mpz\_class, mpz\_class> ans = \hyperlink{classb__graph__encoder_abb9153c776f8c9ec9aeb6361080e84d4}{compute\_N\_new}(G);
177   \textcolor{comment}{//if (ans.first!= ans\_2.first or ans.second != ans\_2.second)\{}
178   \textcolor{comment}{//  cerr << " bip ans != ans\_2 ans = (" << ans.first << " , " << ans.second <<  " ) ans\_2 = (" <<
       ans\_2.first << " , " << ans\_2.second << " ) "  << endl;}
179   \textcolor{comment}{//\}//else\{}
180   \textcolor{comment}{//cerr << " the same! ans = (" << ans.first << " , " << ans.second <<  " ) ans\_2 = (" << ans\_2.first << "
       , " << ans\_2.second << " ) "  << endl;}
181   \textcolor{comment}{//\}}
182   \textcolor{comment}{//mpz\_class prod\_b\_factorial = prod\_factorial(b, 0, b.size()-1); // \(\backslash\)prod\_\{i=0\}^\{n-1\} b\_i}
183 
184   \textcolor{comment}{//if (prod\_b\_factorial != ans.second)}
185   \textcolor{comment}{//  cerr << "EEEEEEEEEEEEEEEEEEEEEEEEE prod\_b\_factorial != ans.second" << endl;}
186 
187   \textcolor{keywordtype}{bool} ceil = \textcolor{keyword}{false};
188   \textcolor{keywordflow}{if} (ans.first % ans.second != 0)
189     ceil = \textcolor{keyword}{true};
190   ans.first /= ans.second;
191   \textcolor{keywordflow}{if} (ceil)
192     ans.first ++;
193   \textcolor{keywordflow}{return} ans.first;
194 \}
\end{DoxyCode}
\mbox{\Hypertarget{classb__graph__encoder_a9b62ac0580191ac42b98d764046af7cb}\label{classb__graph__encoder_a9b62ac0580191ac42b98d764046af7cb}} 
\index{b\+\_\+graph\+\_\+encoder@{b\+\_\+graph\+\_\+encoder}!init@{init}}
\index{init@{init}!b\+\_\+graph\+\_\+encoder@{b\+\_\+graph\+\_\+encoder}}
\subsubsection{\texorpdfstring{init()}{init()}}
{\footnotesize\ttfamily void b\+\_\+graph\+\_\+encoder\+::init (\begin{DoxyParamCaption}\item[{const \hyperlink{classb__graph}{b\+\_\+graph} \&}]{G }\end{DoxyParamCaption})}



initializes beta and U 


\begin{DoxyCode}
9 \{
10   \textcolor{comment}{// initializing beta}
11   \hyperlink{classb__graph__encoder_ae54d76cc4cee399d98951f870897a144}{beta} = G.\hyperlink{classb__graph_a2711566385b92b02f4c03abdc1f9a582}{get\_right\_degree\_sequence}();
12 
13   \textcolor{comment}{// initializing the Fenwick tree}
14   \hyperlink{classb__graph__encoder_ac810138443002a2b2cf579ced2dc34ce}{U} = \hyperlink{classreverse__fenwick__tree}{reverse\_fenwick\_tree}(\hyperlink{classb__graph__encoder_ae54d76cc4cee399d98951f870897a144}{beta});
15 
16   \textcolor{keywordflow}{if} (\hyperlink{classb__graph__encoder_afd22d167f495cd85b41397f337c377c2}{a} != G.\hyperlink{classb__graph_afd65fb655f7e24217393a10533b87d3c}{get\_left\_degree\_sequence}() or \hyperlink{classb__graph__encoder_a767826e268702e45ab71565e096a52b8}{b} != G.
      \hyperlink{classb__graph_a2711566385b92b02f4c03abdc1f9a582}{get\_right\_degree\_sequence}())
17     cerr << \textcolor{stringliteral}{" WARNING b\_graph\_encoder::init : vectors a and/or b do not match with the degree sequences of
       the given bipartite graph  "} << endl;
18 
19 \}
\end{DoxyCode}


\subsection{Member Data Documentation}
\mbox{\Hypertarget{classb__graph__encoder_afd22d167f495cd85b41397f337c377c2}\label{classb__graph__encoder_afd22d167f495cd85b41397f337c377c2}} 
\index{b\+\_\+graph\+\_\+encoder@{b\+\_\+graph\+\_\+encoder}!a@{a}}
\index{a@{a}!b\+\_\+graph\+\_\+encoder@{b\+\_\+graph\+\_\+encoder}}
\subsubsection{\texorpdfstring{a}{a}}
{\footnotesize\ttfamily vector$<$int$>$ b\+\_\+graph\+\_\+encoder\+::a\hspace{0.3cm}{\ttfamily [private]}}



the degree sequence for the left nodes 

\mbox{\Hypertarget{classb__graph__encoder_a767826e268702e45ab71565e096a52b8}\label{classb__graph__encoder_a767826e268702e45ab71565e096a52b8}} 
\index{b\+\_\+graph\+\_\+encoder@{b\+\_\+graph\+\_\+encoder}!b@{b}}
\index{b@{b}!b\+\_\+graph\+\_\+encoder@{b\+\_\+graph\+\_\+encoder}}
\subsubsection{\texorpdfstring{b}{b}}
{\footnotesize\ttfamily vector$<$int$>$ b\+\_\+graph\+\_\+encoder\+::b\hspace{0.3cm}{\ttfamily [private]}}



the degree sequence for the right nodes 

\mbox{\Hypertarget{classb__graph__encoder_ae54d76cc4cee399d98951f870897a144}\label{classb__graph__encoder_ae54d76cc4cee399d98951f870897a144}} 
\index{b\+\_\+graph\+\_\+encoder@{b\+\_\+graph\+\_\+encoder}!beta@{beta}}
\index{beta@{beta}!b\+\_\+graph\+\_\+encoder@{b\+\_\+graph\+\_\+encoder}}
\subsubsection{\texorpdfstring{beta}{beta}}
{\footnotesize\ttfamily vector$<$int$>$ b\+\_\+graph\+\_\+encoder\+::beta\hspace{0.3cm}{\ttfamily [private]}}



when compute\+\_\+N is called for $i \leq j$, for $ i \leq v \leq n$, we have beta\mbox{[}v\mbox{]} = $b_v(i)$ 

\mbox{\Hypertarget{classb__graph__encoder_ac810138443002a2b2cf579ced2dc34ce}\label{classb__graph__encoder_ac810138443002a2b2cf579ced2dc34ce}} 
\index{b\+\_\+graph\+\_\+encoder@{b\+\_\+graph\+\_\+encoder}!U@{U}}
\index{U@{U}!b\+\_\+graph\+\_\+encoder@{b\+\_\+graph\+\_\+encoder}}
\subsubsection{\texorpdfstring{U}{U}}
{\footnotesize\ttfamily \hyperlink{classreverse__fenwick__tree}{reverse\+\_\+fenwick\+\_\+tree} b\+\_\+graph\+\_\+encoder\+::U\hspace{0.3cm}{\ttfamily [private]}}



a Fenwick tree which encodes the degree of right nodes. When compute\+\_\+N is called for $i \leq j$, for $i \leq v \leq n$, we have U.\+sum\mbox{[}v\mbox{]} $= \sum_{k = v}^n b_k(i)$. 



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
\hyperlink{bipartite__graph__compression_8h}{bipartite\+\_\+graph\+\_\+compression.\+h}\item 
\hyperlink{bipartite__graph__compression_8cpp}{bipartite\+\_\+graph\+\_\+compression.\+cpp}\end{DoxyCompactItemize}
