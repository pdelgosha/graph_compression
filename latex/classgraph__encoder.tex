\hypertarget{classgraph__encoder}{}\section{graph\+\_\+encoder Class Reference}
\label{classgraph__encoder}\index{graph\+\_\+encoder@{graph\+\_\+encoder}}


Encodes a simple unmarked graph.  




{\ttfamily \#include $<$simple\+\_\+graph\+\_\+compression.\+h$>$}

\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classgraph__encoder_a571aefbf0b6ad203346fc4e0ef1a33dc}{graph\+\_\+encoder} (const vector$<$ int $>$ \&a\+\_\+)
\begin{DoxyCompactList}\small\item\em constructor \end{DoxyCompactList}\item 
void \hyperlink{classgraph__encoder_a6cfb6fca4bc50d4e5d267060a91f43c3}{init} (const \hyperlink{classgraph}{graph} \&G)
\begin{DoxyCompactList}\small\item\em initializes beta and U, clears Stilde for a fresh use \end{DoxyCompactList}\item 
pair$<$ mpz\+\_\+class, mpz\+\_\+class $>$ \hyperlink{classgraph__encoder_ae7273c47d6dab8367daa5ee6a9cdbc72}{compute\+\_\+N} (int i, int j, int I, const \hyperlink{classgraph}{graph} \&G)
\begin{DoxyCompactList}\small\item\em computes $N_{i,j}(G)$ \end{DoxyCompactList}\item 
pair$<$ mpz\+\_\+class, mpz\+\_\+class $>$ \hyperlink{classgraph__encoder_aeab221523400ec73da6146fdbbd11274}{compute\+\_\+\+N\+\_\+new} (const \hyperlink{classgraph}{graph} \&G)
\item 
pair$<$ mpz\+\_\+class, vector$<$ int $>$ $>$ \hyperlink{classgraph__encoder_a23350e4c0986763b24d14c5ef1beb37e}{encode} (const \hyperlink{classgraph}{graph} \&G)
\begin{DoxyCompactList}\small\item\em Encodes the graph and returns N together with Stilde. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
int \hyperlink{classgraph__encoder_a7fedc9ace19e34abb32f1851c8597591}{n}
\begin{DoxyCompactList}\small\item\em the number of vertices \end{DoxyCompactList}\item 
vector$<$ int $>$ \hyperlink{classgraph__encoder_a56eb5cf480ae5c2fca9f3a45f2ffd4f1}{a}
\begin{DoxyCompactList}\small\item\em the degree sequence \end{DoxyCompactList}\item 
vector$<$ int $>$ \hyperlink{classgraph__encoder_a40880adecfd63fb86e94b4b0fc3f6bc2}{beta}
\begin{DoxyCompactList}\small\item\em When compute\+\_\+N is called for $i \leq j$, for $i \leq v \leq n$, we have $\beta_v = d_v(i)$. \end{DoxyCompactList}\item 
\hyperlink{classreverse__fenwick__tree}{reverse\+\_\+fenwick\+\_\+tree} \hyperlink{classgraph__encoder_a3314c40920f2ee132958a6b0ce7e7995}{U}
\begin{DoxyCompactList}\small\item\em a Fenwick tree which encodes the forward degrees to the right. When compute\+\_\+N is called for $i \leq j$, for $i \leq v$, we have $U_v = \sum_{k=v}^n d_k(i)$. \end{DoxyCompactList}\item 
vector$<$ int $>$ \hyperlink{classgraph__encoder_a342688a3fdee511b7fae3f155cfb10cf}{Stilde}
\begin{DoxyCompactList}\small\item\em Summation of forward degrees at $n / \log^2 n$ many points. \end{DoxyCompactList}\item 
int \hyperlink{classgraph__encoder_a27fde3a95a280304877b1e37fc4d8553}{logn2}
\begin{DoxyCompactList}\small\item\em $\lfloor \log_2 n \rfloor^2$ where $n$ is the number of vertices \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
Encodes a simple unmarked graph. 

Encodes a simple graph in the set of graphs with a given degree sequence a. Therefore, to construct an encoder object, we need to specify this degree sequence as a vector of int. For instance (in c++11)


\begin{DoxyCode}
vector<int> a = \{3,2,2,3\};
\hyperlink{classgraph__encoder}{graph\_encoder} E(a);
\end{DoxyCode}


constructs an encode object E which is capable of encoding graphs having 4 nodes with degrees 3, 2, 2, 3 (in order). Hence, assume that we have defined such a graph by giving forward adjacency list\+:


\begin{DoxyCode}
\hyperlink{classgraph}{graph} G(\{1,2,3\},\{3\},\{3\},\{\});
\end{DoxyCode}


Note that G has a degree sequences which is equal to a. Then, we can use E to encode G as follows\+:


\begin{DoxyCode}
pair<mpz\_class, vector<int> > f = E.encode(G);
\end{DoxyCode}


In this way, the encode converts G to a pair stored in f, where its first part is an integer, and the second part is the array of integers $\tilde{S}$. Later on, we can use f to decode G. 

\subsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classgraph__encoder_a571aefbf0b6ad203346fc4e0ef1a33dc}\label{classgraph__encoder_a571aefbf0b6ad203346fc4e0ef1a33dc}} 
\index{graph\+\_\+encoder@{graph\+\_\+encoder}!graph\+\_\+encoder@{graph\+\_\+encoder}}
\index{graph\+\_\+encoder@{graph\+\_\+encoder}!graph\+\_\+encoder@{graph\+\_\+encoder}}
\subsubsection{\texorpdfstring{graph\+\_\+encoder()}{graph\_encoder()}}
{\footnotesize\ttfamily graph\+\_\+encoder\+::graph\+\_\+encoder (\begin{DoxyParamCaption}\item[{const vector$<$ int $>$ \&}]{a\+\_\+ }\end{DoxyParamCaption})}



constructor 

initializes the degree sequence to a\+\_\+, sets n and logn2, and resizes the Stilde vector 
\begin{DoxyCode}
11                                                  \{
12   \hyperlink{classgraph__encoder_a56eb5cf480ae5c2fca9f3a45f2ffd4f1}{a} = a\_;
13   \hyperlink{classgraph__encoder_a7fedc9ace19e34abb32f1851c8597591}{n} = \hyperlink{classgraph__encoder_a56eb5cf480ae5c2fca9f3a45f2ffd4f1}{a}.size();
14   \textcolor{keywordtype}{int} log2n = 0; \textcolor{comment}{// log of n in base 2}
15   \textcolor{keywordtype}{int} nn = \hyperlink{classgraph__encoder_a7fedc9ace19e34abb32f1851c8597591}{n}; \textcolor{comment}{// a copy of n}
16   \textcolor{keywordflow}{while} (nn>0)\{
17     log2n ++;
18     nn = nn >> 1; \textcolor{comment}{// divide by 2}
19   \} \textcolor{comment}{// eventually, we count the number of bits in n}
20   log2n --; \textcolor{comment}{// we count extra, e.g. when n = 1, we end up having 1, rather than 0}
21   \hyperlink{classgraph__encoder_a27fde3a95a280304877b1e37fc4d8553}{logn2} = log2n * log2n;
22 
23   \hyperlink{classgraph__encoder_a342688a3fdee511b7fae3f155cfb10cf}{Stilde}.clear();
24   \hyperlink{classgraph__encoder_a342688a3fdee511b7fae3f155cfb10cf}{Stilde}.resize(4 * \hyperlink{classgraph__encoder_a7fedc9ace19e34abb32f1851c8597591}{n} / \hyperlink{classgraph__encoder_a27fde3a95a280304877b1e37fc4d8553}{logn2}); \textcolor{comment}{// look at the explanation of the algorithm, before deriving
       the bound 16 n, that 4n / \(\backslash\)lfloor \(\backslash\)log\_2 n \(\backslash\)rfloor^2 is also an upper bound. After this point, we have used
       \(\backslash\)lfloor \(\backslash\)log\_2 n \(\backslash\)rfloor \(\backslash\)geq \(\backslash\)log n / 2 to derive the 16 n bound.}
25   \hyperlink{classgraph__encoder_a342688a3fdee511b7fae3f155cfb10cf}{Stilde}[0] = 0;
26 \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\mbox{\Hypertarget{classgraph__encoder_ae7273c47d6dab8367daa5ee6a9cdbc72}\label{classgraph__encoder_ae7273c47d6dab8367daa5ee6a9cdbc72}} 
\index{graph\+\_\+encoder@{graph\+\_\+encoder}!compute\+\_\+N@{compute\+\_\+N}}
\index{compute\+\_\+N@{compute\+\_\+N}!graph\+\_\+encoder@{graph\+\_\+encoder}}
\subsubsection{\texorpdfstring{compute\+\_\+\+N()}{compute\_N()}}
{\footnotesize\ttfamily pair$<$ mpz\+\_\+class, mpz\+\_\+class $>$ graph\+\_\+encoder\+::compute\+\_\+N (\begin{DoxyParamCaption}\item[{int}]{i,  }\item[{int}]{j,  }\item[{int}]{I,  }\item[{const \hyperlink{classgraph}{graph} \&}]{G }\end{DoxyParamCaption})}



computes $N_{i,j}(G)$ 


\begin{DoxyParams}{Parameters}
{\em i,j} & the interval for which we compute $N_{i,j}(G)$ \\
\hline
{\em I} & The integer index corresponding to the current interval (follows a heap convention). \\
\hline
{\em G} & the reference to the simple graph G \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A pair, where the first component is $N_{i,j}(G)$ and the second component is $l_{i,j}(G)$. 
\end{DoxyReturn}

\begin{DoxyCode}
49 \{
50   \textcolor{comment}{//cerr << " i, j " << i << " , " << j << endl;}
51   \textcolor{keywordflow}{if} (i==j)\{
52     mpz\_class zi, li, zik, lik;
53     zi = 0;
54     li = 1;
55     vector<int> x = G.\hyperlink{classgraph_aa8fbee52a7b3604dbbd9175040c7ead5}{get\_forward\_list}(i); \textcolor{comment}{// the forward adjacency list of vertex i}
56     \textcolor{keywordflow}{if} (\hyperlink{classgraph__encoder_a40880adecfd63fb86e94b4b0fc3f6bc2}{beta}[i] != x.size())
57       cerr << \textcolor{stringliteral}{" DANGER! beta[i] is not the same as x.size()!!"} << endl;
58     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} k=0;k<x.size();k++)\{
59       \textcolor{comment}{//logger::item\_start("simple\_cp\_1");}
60       zik = \hyperlink{compression__helper_8cpp_ae2afb43aabe50f7d42aae8f82b5a35f4}{compute\_product}(\hyperlink{classgraph__encoder_a3314c40920f2ee132958a6b0ce7e7995}{U}.\hyperlink{classreverse__fenwick__tree_a672731fd6395b4853430073a099a80e6}{sum}(1+x[k]), \hyperlink{classgraph__encoder_a40880adecfd63fb86e94b4b0fc3f6bc2}{beta}[i] - k, 1); \textcolor{comment}{// we are zero based
       here, so instead of -k + 1, we have -k}
61       \textcolor{comment}{//logger::item\_stop("simple\_cp\_1");}
62       \textcolor{comment}{//logger::item\_start("simple\_ar");}
63       zi += li * zik;
64       lik = (\hyperlink{classgraph__encoder_a40880adecfd63fb86e94b4b0fc3f6bc2}{beta}[i] - k) * \hyperlink{classgraph__encoder_a40880adecfd63fb86e94b4b0fc3f6bc2}{beta}[x[k]]; \textcolor{comment}{// we are zero based here, so instead of -k + 1, we have -k}
65       li *= lik;
66       \textcolor{comment}{//logger::item\_stop("simple\_ar");}
67       \hyperlink{classgraph__encoder_a40880adecfd63fb86e94b4b0fc3f6bc2}{beta}[x[k]] --;
68       \hyperlink{classgraph__encoder_a3314c40920f2ee132958a6b0ce7e7995}{U}.\hyperlink{classreverse__fenwick__tree_a942d7f49b37e53ebfec3076d177691d7}{add}(x[k], -1);
69     \}
70     \textcolor{comment}{//cerr << " returning (" << i << " , " << j << ") N " << zi << " l " << li << endl;}
71     \textcolor{keywordflow}{return} pair<mpz\_class, mpz\_class>(zi, li);
72   \}\textcolor{keywordflow}{else}\{
73     \textcolor{keywordtype}{int} t = (i+j) / 2;
74     mpz\_class Nit, lit; \textcolor{comment}{// \(\backslash\)f$N\_\{i,t\}\(\backslash\)f$ and \(\backslash\)f$l\_\{[i:t]\}\(\backslash\)f$}
75     mpz\_class Ntj, ltj; \textcolor{comment}{// \(\backslash\)f$N\_\{t+1,j\}\(\backslash\)f$ and \(\backslash\)f$l\_\{[t+1:j]\}\(\backslash\)f$}
76     mpz\_class Nij, lij; \textcolor{comment}{// \(\backslash\)f$N\_\{i,j\}\(\backslash\)f$ and \(\backslash\)f$l\_\{[i:j]\}\(\backslash\)f$}
77     \textcolor{keywordtype}{int} St, Sj; \textcolor{comment}{// \(\backslash\)f$S\_\{t+1\}\(\backslash\)f$ and \(\backslash\)f$S\_\{j+1\}\(\backslash\)f$}
78     mpz\_class rtj; \textcolor{comment}{// \(\backslash\)f$r\_\{[t+1:j]\}\(\backslash\)f$}
79 
80     pair<mpz\_class, mpz\_class> return\_left = \hyperlink{classgraph__encoder_ae7273c47d6dab8367daa5ee6a9cdbc72}{compute\_N}(i,t, 2*I, G); \textcolor{comment}{// calling for the interval
       i,t}
81     Nit = return\_left.first;
82     lit = return\_left.second;
83     St = \hyperlink{classgraph__encoder_a3314c40920f2ee132958a6b0ce7e7995}{U}.\hyperlink{classreverse__fenwick__tree_a672731fd6395b4853430073a099a80e6}{sum}(t+1);
84 
85     \textcolor{keywordflow}{if} (j - i > \hyperlink{classgraph__encoder_a27fde3a95a280304877b1e37fc4d8553}{logn2})\{\textcolor{comment}{// we should save the midpoint sum St}
86       \textcolor{comment}{//cerr << " i " << i << " j " << j << " I " << I << " storing St " << St << endl;}
87       \textcolor{keywordflow}{if} (I >= \hyperlink{classgraph__encoder_a342688a3fdee511b7fae3f155cfb10cf}{Stilde}.size() )\{
88         cerr << \textcolor{stringliteral}{" WARNING graph\_encoder::compute\_N index I is out of range.  I= "} << I << \textcolor{stringliteral}{" Stilde.size()= 
      "}<< \hyperlink{classgraph__encoder_a342688a3fdee511b7fae3f155cfb10cf}{Stilde}.size() <<  \textcolor{stringliteral}{" i= "} << i << \textcolor{stringliteral}{" j= "} << j << \textcolor{stringliteral}{" logn2= "} << \hyperlink{classgraph__encoder_a27fde3a95a280304877b1e37fc4d8553}{logn2} << endl;
89       \}
90       \hyperlink{classgraph__encoder_a342688a3fdee511b7fae3f155cfb10cf}{Stilde}[I] = St;
91     \}
92 
93     pair<mpz\_class, mpz\_class> return\_right = \hyperlink{classgraph__encoder_ae7273c47d6dab8367daa5ee6a9cdbc72}{compute\_N}(t+1, j, 2*I + 1, G); \textcolor{comment}{// calling for the
       interval t+1, j}
94     Ntj = return\_right.first;
95     ltj = return\_right.second;
96     Sj = \hyperlink{classgraph__encoder_a3314c40920f2ee132958a6b0ce7e7995}{U}.\hyperlink{classreverse__fenwick__tree_a672731fd6395b4853430073a099a80e6}{sum}(j+1);
97     \textcolor{comment}{//logger::item\_start("simple\_cp"); }
98     rtj = \hyperlink{compression__helper_8cpp_ae2afb43aabe50f7d42aae8f82b5a35f4}{compute\_product}(St-1, (St - Sj)/2, 2);
99     \textcolor{comment}{//logger::item\_stop("simple\_cp");}
100     \textcolor{comment}{//cerr << "( " << i << " , " << j << ") St " << St << " Sj " << Sj << " rtj " << rtj << endl;}
101     \textcolor{comment}{//logger::item\_start("simple\_ar");}
102     Nij = Nit * rtj + lit * Ntj ;
103     lij = lit * ltj;
104     \textcolor{comment}{//logger::item\_stop("simple\_ar");}
105     \textcolor{comment}{//cerr << " returning (" << i << " , " << j << ") N " << Nij << " l " << lij << endl;}
106     \textcolor{keywordflow}{return} pair<mpz\_class, mpz\_class> (Nij, lij);
107   \}
108 \}
\end{DoxyCode}
\mbox{\Hypertarget{classgraph__encoder_aeab221523400ec73da6146fdbbd11274}\label{classgraph__encoder_aeab221523400ec73da6146fdbbd11274}} 
\index{graph\+\_\+encoder@{graph\+\_\+encoder}!compute\+\_\+\+N\+\_\+new@{compute\+\_\+\+N\+\_\+new}}
\index{compute\+\_\+\+N\+\_\+new@{compute\+\_\+\+N\+\_\+new}!graph\+\_\+encoder@{graph\+\_\+encoder}}
\subsubsection{\texorpdfstring{compute\+\_\+\+N\+\_\+new()}{compute\_N\_new()}}
{\footnotesize\ttfamily pair$<$ mpz\+\_\+class, mpz\+\_\+class $>$ graph\+\_\+encoder\+::compute\+\_\+\+N\+\_\+new (\begin{DoxyParamCaption}\item[{const \hyperlink{classgraph}{graph} \&}]{G }\end{DoxyParamCaption})}


\begin{DoxyCode}
111 \{
112 
113   \textcolor{keywordtype}{int} \hyperlink{classgraph__encoder_a7fedc9ace19e34abb32f1851c8597591}{n} = G.\hyperlink{classgraph_a70a6e0e4e0a874ab122405abd38f83cd}{nu\_vertices}();
114   \textcolor{keywordtype}{int} n\_bits = 0;
115   \textcolor{keywordtype}{int} n\_copy = \hyperlink{classgraph__encoder_a7fedc9ace19e34abb32f1851c8597591}{n};
116   \textcolor{keywordflow}{while} (n\_copy > 0)\{
117     n\_bits ++;
118     n\_copy >>= 1;
119   \}
120   n\_bits += 2;
121 
122   vector<pair<pair<int, int>, \textcolor{keywordtype}{int} > > call\_stack(2 * n\_bits);
123   vector<pair<mpz\_class, mpz\_class> > \hyperlink{namespacehelper__vars_a36577c81e805c58ec2ec7ed63882317f}{return\_stack}(2 * n\_bits); \textcolor{comment}{// first = N, second = l}
124   vector<int> status\_stack(2 * n\_bits);
125   vector<int> St\_stack(2 * n\_bits); \textcolor{comment}{// stack to store values of St}
126 
127   call\_stack[0].first = pair<int, int> (0,n-1); \textcolor{comment}{// i j }
128   call\_stack[0].second = 1; \textcolor{comment}{// I}
129   status\_stack[0] = 0; \textcolor{comment}{// newly added}
130 
131   \textcolor{keywordtype}{int} call\_size = 1; \textcolor{comment}{// the size of the call stack}
132   \textcolor{keywordtype}{int} return\_size = 0; \textcolor{comment}{// the size of the return stack}
133 
134   \textcolor{keywordtype}{int} i, j, I, t, Sj;
135   \textcolor{keywordtype}{int} status;
136 
137   vector<int> gamma; \textcolor{comment}{// forward list  of the graph}
138   mpz\_class zik, lik, rtj; \textcolor{comment}{// intermediate variables}
139   mpz\_class Nit\_rtj; \textcolor{comment}{// result of Nij * rtj}
140   mpz\_class lit\_Ntj; \textcolor{comment}{// result of lit * Ntj }
141   \textcolor{keywordflow}{while} (call\_size > 0)\{
142     \textcolor{comment}{// cerr << " printing the whole stack " << endl;}
143     \textcolor{comment}{// for (int k = 0; k<call\_size; k++)\{}
144     \textcolor{comment}{//   cerr << k << " : " << call\_stack[k].first.first << " " << call\_stack[k].first.second << " I " <<
       call\_stack[k].second << "s= " << status\_stack[k] << endl;}
145     \textcolor{comment}{// \}}
146     \textcolor{comment}{// cerr << " return stack " << endl;}
147     \textcolor{comment}{// for (int k=0;k<return\_size;k++)}
148     \textcolor{comment}{//   cerr << k << ": " << return\_stack[k].first << " " << return\_stack[k].second << endl;}
149     i = call\_stack[call\_size-1].first.first;
150     j = call\_stack[call\_size-1].first.second;
151     I = call\_stack[call\_size-1].second;
152     \textcolor{keywordflow}{if} (i==j)\{
153 
154       \hyperlink{namespacehelper__vars_a36577c81e805c58ec2ec7ed63882317f}{return\_stack}[return\_size].first = 0; \textcolor{comment}{// z\_i is initialized with 0}
155       \hyperlink{namespacehelper__vars_a36577c81e805c58ec2ec7ed63882317f}{return\_stack}[return\_size].second = 1; \textcolor{comment}{// l\_i is initialize with 1}
156       gamma = G.\hyperlink{classgraph_aa8fbee52a7b3604dbbd9175040c7ead5}{get\_forward\_list}(i); \textcolor{comment}{// the forward adjacency list of vertex i}
157       \textcolor{comment}{// cerr << " i " << i << " j " << j << " gamma: " << endl;}
158       \textcolor{comment}{// for (int k=0;k<gamma.size();k++)}
159       \textcolor{comment}{//   cerr << gamma[k] << " ";}
160       \textcolor{comment}{// cerr << endl;}
161       \textcolor{comment}{// cerr << " beta " << endl;}
162       \textcolor{comment}{// for (int k=0; k<n; k++)}
163       \textcolor{comment}{//   cerr << beta[k] << " ";}
164       \textcolor{comment}{// cerr << endl;}
165 
166       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} k=0;k<gamma.size();k++)\{
167         zik = \hyperlink{compression__helper_8cpp_ae2afb43aabe50f7d42aae8f82b5a35f4}{compute\_product}(\hyperlink{classgraph__encoder_a3314c40920f2ee132958a6b0ce7e7995}{U}.\hyperlink{classreverse__fenwick__tree_a672731fd6395b4853430073a099a80e6}{sum}(1+gamma[k]), \hyperlink{classgraph__encoder_a40880adecfd63fb86e94b4b0fc3f6bc2}{beta}[i] - k, 1); \textcolor{comment}{// we are zero
       based here, so instead of -k + 1, we have -k}
168         \textcolor{comment}{//zik = helper\_vars::return\_stack[0];}
169         \hyperlink{namespacehelper__vars_a36577c81e805c58ec2ec7ed63882317f}{return\_stack}[return\_size].first += \hyperlink{namespacehelper__vars_a36577c81e805c58ec2ec7ed63882317f}{return\_stack}[return\_size].second * zik;
170         lik = (\hyperlink{classgraph__encoder_a40880adecfd63fb86e94b4b0fc3f6bc2}{beta}[i] - k) * \hyperlink{classgraph__encoder_a40880adecfd63fb86e94b4b0fc3f6bc2}{beta}[gamma[k]]; \textcolor{comment}{// we are zero based here, so instead of -k + 1, we
       have -k}
171         \textcolor{comment}{//cerr << " lik " << lik << endl;}
172         \hyperlink{namespacehelper__vars_a36577c81e805c58ec2ec7ed63882317f}{return\_stack}[return\_size].second *= lik;
173         \hyperlink{classgraph__encoder_a40880adecfd63fb86e94b4b0fc3f6bc2}{beta}[gamma[k]] -- ;
174         \hyperlink{classgraph__encoder_a3314c40920f2ee132958a6b0ce7e7995}{U}.\hyperlink{classreverse__fenwick__tree_a942d7f49b37e53ebfec3076d177691d7}{add}(gamma[k],-1);
175       \}
176       return\_size ++; \textcolor{comment}{// establish the return}
177       call\_size --;
178     \}\textcolor{keywordflow}{else}\{
179       status = status\_stack[call\_size-1];
180       \textcolor{keywordflow}{if} (status == 0)\{
181         \textcolor{comment}{// newly added node, we should call its left child}
182         t = (i+j) / 2;
183         call\_stack[call\_size].first.first = i;
184         call\_stack[call\_size].first.second = t;
185         call\_stack[call\_size].second = 2*I;
186         status\_stack[call\_size-1] = 1; \textcolor{comment}{// left is called}
187         status\_stack[call\_size] = 0; \textcolor{comment}{// newly added}
188         call\_size++;
189       \}
190       \textcolor{keywordflow}{if} (status == 1)\{
191         \textcolor{comment}{// left is returned}
192         t = (i+j) / 2;
193         St\_stack[call\_size-1] = \hyperlink{classgraph__encoder_a3314c40920f2ee132958a6b0ce7e7995}{U}.\hyperlink{classreverse__fenwick__tree_a672731fd6395b4853430073a099a80e6}{sum}(t+1);
194         \textcolor{keywordflow}{if} (j - i > \hyperlink{classgraph__encoder_a27fde3a95a280304877b1e37fc4d8553}{logn2})
195           \hyperlink{classgraph__encoder_a342688a3fdee511b7fae3f155cfb10cf}{Stilde}[I] = St\_stack[call\_size-1];
196         \textcolor{comment}{// prepare to call right}
197         
198         call\_stack[call\_size].first.first = t + 1;
199         call\_stack[call\_size].first.second = j;
200         call\_stack[call\_size].second = 2*I + 1;
201         status\_stack[call\_size-1] = 2; \textcolor{comment}{// right is called}
202         status\_stack[call\_size] = 0; \textcolor{comment}{// newly called}
203         call\_size ++;
204       \}
205 
206       \textcolor{keywordflow}{if} (status == 2)\{
207         \textcolor{comment}{// both are returned, and results can be accessed by the top two elements in return stack}
208         Sj = \hyperlink{classgraph__encoder_a3314c40920f2ee132958a6b0ce7e7995}{U}.\hyperlink{classreverse__fenwick__tree_a672731fd6395b4853430073a099a80e6}{sum}(j+1);
209         rtj = \hyperlink{compression__helper_8cpp_ae2afb43aabe50f7d42aae8f82b5a35f4}{compute\_product}(St\_stack[call\_size-1]-1, (St\_stack[call\_size-1] - Sj)/2, 2);
210         \textcolor{comment}{//rtj = helper\_vars::return\_stack[0];}
211         \textcolor{comment}{//cerr << " rtj " << rtj << endl;}
212         \textcolor{comment}{//Nij = Nit * rtj + lit * Ntj ;}
213         Nit\_rtj = \hyperlink{namespacehelper__vars_a36577c81e805c58ec2ec7ed63882317f}{return\_stack}[return\_size-2].first * rtj;
214         lit\_Ntj = \hyperlink{namespacehelper__vars_a36577c81e805c58ec2ec7ed63882317f}{return\_stack}[return\_size-2].second * \hyperlink{namespacehelper__vars_a36577c81e805c58ec2ec7ed63882317f}{return\_stack}[return\_size-1].
      first;
215         \hyperlink{namespacehelper__vars_a36577c81e805c58ec2ec7ed63882317f}{return\_stack}[return\_size-2].first = Nit\_rtj + lit\_Ntj; \textcolor{comment}{// Nij}
216         \hyperlink{namespacehelper__vars_a36577c81e805c58ec2ec7ed63882317f}{return\_stack}[return\_size-2].second = \hyperlink{namespacehelper__vars_a36577c81e805c58ec2ec7ed63882317f}{return\_stack}[return\_size-2].second * 
      \hyperlink{namespacehelper__vars_a36577c81e805c58ec2ec7ed63882317f}{return\_stack}[return\_size-1].second; \textcolor{comment}{// lij}
217         return\_size --; \textcolor{comment}{// pop 2 add 1}
218         call\_size --;
219       \}
220     \}
221 
222   \}
223 
224   \textcolor{keywordflow}{if} (return\_size != 1)\{
225     cerr << \textcolor{stringliteral}{" error: return\_size is not 1 it is "} << return\_size << endl;
226   \}
227   \textcolor{keywordflow}{return} \hyperlink{namespacehelper__vars_a36577c81e805c58ec2ec7ed63882317f}{return\_stack}[0];
228 \}
\end{DoxyCode}
\mbox{\Hypertarget{classgraph__encoder_a23350e4c0986763b24d14c5ef1beb37e}\label{classgraph__encoder_a23350e4c0986763b24d14c5ef1beb37e}} 
\index{graph\+\_\+encoder@{graph\+\_\+encoder}!encode@{encode}}
\index{encode@{encode}!graph\+\_\+encoder@{graph\+\_\+encoder}}
\subsubsection{\texorpdfstring{encode()}{encode()}}
{\footnotesize\ttfamily pair$<$ mpz\+\_\+class, vector$<$ int $>$ $>$ graph\+\_\+encoder\+::encode (\begin{DoxyParamCaption}\item[{const \hyperlink{classgraph}{graph} \&}]{G }\end{DoxyParamCaption})}



Encodes the graph and returns N together with Stilde. 


\begin{DoxyParams}{Parameters}
{\em G} & reference to the graph to encode \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A pair, where the first component is $\lceil N(G) / \prod_{i=1}^n a_i! \rceil$ where $N(G) = N_{0,n-1}(G)$ and $a$ is the degree sequence of the graph, and the second component is the vector Stilde which stores partial mid sum of intervals and has length roughly $n / \log^2 n$ 
\end{DoxyReturn}

\begin{DoxyCode}
230                                                                  \{
231   \textcolor{keywordflow}{if} (G.\hyperlink{classgraph_afdca627df7fb93a7d1d8a547f616e948}{get\_degree\_sequence}()!= \hyperlink{classgraph__encoder_a56eb5cf480ae5c2fca9f3a45f2ffd4f1}{a})
232     cerr << \textcolor{stringliteral}{" WARNING graph\_encoder::encode : vector a does not match with the degree sequence of the given
       graph "};
233   \textcolor{comment}{//init(G); // initialize U and beta }
234   \textcolor{comment}{//pair<mpz\_class, mpz\_class> N\_ans  = compute\_N(0,G.nu\_vertices()-1,1, G);}
235   \hyperlink{classgraph__encoder_a6cfb6fca4bc50d4e5d267060a91f43c3}{init}(G); \textcolor{comment}{// re initializing U abd beta for the second test}
236   pair<mpz\_class, mpz\_class> N\_ans = \hyperlink{classgraph__encoder_aeab221523400ec73da6146fdbbd11274}{compute\_N\_new}(G);
237   \textcolor{comment}{//if (N\_ans.first != N\_ans\_2.first or N\_ans.second != N\_ans\_2.second)}
238   \textcolor{comment}{//  cerr << " error N\_ans and N\_ans\_2 are not the same, "  << endl << "N\_ans = (" << N\_ans.first << " , "
       << N\_ans.second << ") " << endl << "N\_ans\_2 = (" << N\_ans\_2.first << " , " << N\_ans\_2.second << ")" <<
       endl;}
239   \textcolor{comment}{//else}
240   \textcolor{comment}{//  cerr << " N\_ans = N\_ans\_2 " << endl;}
241   \textcolor{comment}{//mpz\_class prod\_a\_factorial = prod\_factorial(a, 0,a.size()-1); // \(\backslash\)prod\_\{i=1\}^n a\_i!}
242   \textcolor{comment}{//if (prod\_a\_factorial!= N\_ans.second)}
243   \textcolor{comment}{//  cerr << " ERROR: not equal " << endl;}
244   \textcolor{comment}{// N\_ans.second = \(\backslash\)prod\_\{i=1\}^n a\_i!}
245   \textcolor{comment}{// we need the ceiling of the ratio of N\_ans.first and prod\_a\_factorial}
246   \textcolor{keywordtype}{bool} ceil = \textcolor{keyword}{false}; \textcolor{comment}{// if true, we will add one to the integer division}
247   \textcolor{comment}{//logger::item\_start("simple\_ar");}
248   \textcolor{keywordflow}{if} (N\_ans.first % N\_ans.second != 0)
249     ceil = \textcolor{keyword}{true};
250   N\_ans.first /= N\_ans.second;
251   \textcolor{keywordflow}{if} (ceil)
252     N\_ans.first ++;
253   \textcolor{comment}{//logger::item\_stop("simple\_ar");}
254   \textcolor{keywordflow}{return} pair<mpz\_class, vector<int> > (N\_ans.first, \hyperlink{classgraph__encoder_a342688a3fdee511b7fae3f155cfb10cf}{Stilde});
255 \}
\end{DoxyCode}
\mbox{\Hypertarget{classgraph__encoder_a6cfb6fca4bc50d4e5d267060a91f43c3}\label{classgraph__encoder_a6cfb6fca4bc50d4e5d267060a91f43c3}} 
\index{graph\+\_\+encoder@{graph\+\_\+encoder}!init@{init}}
\index{init@{init}!graph\+\_\+encoder@{graph\+\_\+encoder}}
\subsubsection{\texorpdfstring{init()}{init()}}
{\footnotesize\ttfamily void graph\+\_\+encoder\+::init (\begin{DoxyParamCaption}\item[{const \hyperlink{classgraph}{graph} \&}]{G }\end{DoxyParamCaption})}



initializes beta and U, clears Stilde for a fresh use 


\begin{DoxyCode}
29 \{
30   \textcolor{comment}{// initializing the beta sequence}
31   \hyperlink{classgraph__encoder_a40880adecfd63fb86e94b4b0fc3f6bc2}{beta} = \hyperlink{classgraph__encoder_a56eb5cf480ae5c2fca9f3a45f2ffd4f1}{a}; 
32 
33   \textcolor{comment}{//beta.resize(G.nu\_vertices());}
34   \textcolor{comment}{//for (int v=0;v<G.nu\_vertices();v++)}
35   \textcolor{comment}{//  beta[v] = G.get\_degree(v);  }
36 
37   \textcolor{comment}{// initializing the Fenwick Tree}
38   \hyperlink{classgraph__encoder_a3314c40920f2ee132958a6b0ce7e7995}{U} = \hyperlink{classreverse__fenwick__tree}{reverse\_fenwick\_tree}(\hyperlink{classgraph__encoder_a40880adecfd63fb86e94b4b0fc3f6bc2}{beta});
39 
40 
41   \textcolor{comment}{//initializing the partial sum vector Stilde}
42   \hyperlink{classgraph__encoder_a342688a3fdee511b7fae3f155cfb10cf}{Stilde}.clear();
43   \hyperlink{classgraph__encoder_a342688a3fdee511b7fae3f155cfb10cf}{Stilde}.resize(4 * \hyperlink{classgraph__encoder_a7fedc9ace19e34abb32f1851c8597591}{n} / \hyperlink{classgraph__encoder_a27fde3a95a280304877b1e37fc4d8553}{logn2}); \textcolor{comment}{// TO CHECK,
       2018-10-18\_self-compression\_Stilde-size-required-2nlogn2.pdf}
44   \hyperlink{classgraph__encoder_a342688a3fdee511b7fae3f155cfb10cf}{Stilde}[0] = 0;
45 \}
\end{DoxyCode}


\subsection{Member Data Documentation}
\mbox{\Hypertarget{classgraph__encoder_a56eb5cf480ae5c2fca9f3a45f2ffd4f1}\label{classgraph__encoder_a56eb5cf480ae5c2fca9f3a45f2ffd4f1}} 
\index{graph\+\_\+encoder@{graph\+\_\+encoder}!a@{a}}
\index{a@{a}!graph\+\_\+encoder@{graph\+\_\+encoder}}
\subsubsection{\texorpdfstring{a}{a}}
{\footnotesize\ttfamily vector$<$int$>$ graph\+\_\+encoder\+::a\hspace{0.3cm}{\ttfamily [private]}}



the degree sequence 

\mbox{\Hypertarget{classgraph__encoder_a40880adecfd63fb86e94b4b0fc3f6bc2}\label{classgraph__encoder_a40880adecfd63fb86e94b4b0fc3f6bc2}} 
\index{graph\+\_\+encoder@{graph\+\_\+encoder}!beta@{beta}}
\index{beta@{beta}!graph\+\_\+encoder@{graph\+\_\+encoder}}
\subsubsection{\texorpdfstring{beta}{beta}}
{\footnotesize\ttfamily vector$<$int$>$ graph\+\_\+encoder\+::beta\hspace{0.3cm}{\ttfamily [private]}}



When compute\+\_\+N is called for $i \leq j$, for $i \leq v \leq n$, we have $\beta_v = d_v(i)$. 

\mbox{\Hypertarget{classgraph__encoder_a27fde3a95a280304877b1e37fc4d8553}\label{classgraph__encoder_a27fde3a95a280304877b1e37fc4d8553}} 
\index{graph\+\_\+encoder@{graph\+\_\+encoder}!logn2@{logn2}}
\index{logn2@{logn2}!graph\+\_\+encoder@{graph\+\_\+encoder}}
\subsubsection{\texorpdfstring{logn2}{logn2}}
{\footnotesize\ttfamily int graph\+\_\+encoder\+::logn2\hspace{0.3cm}{\ttfamily [private]}}



$\lfloor \log_2 n \rfloor^2$ where $n$ is the number of vertices 

\mbox{\Hypertarget{classgraph__encoder_a7fedc9ace19e34abb32f1851c8597591}\label{classgraph__encoder_a7fedc9ace19e34abb32f1851c8597591}} 
\index{graph\+\_\+encoder@{graph\+\_\+encoder}!n@{n}}
\index{n@{n}!graph\+\_\+encoder@{graph\+\_\+encoder}}
\subsubsection{\texorpdfstring{n}{n}}
{\footnotesize\ttfamily int graph\+\_\+encoder\+::n\hspace{0.3cm}{\ttfamily [private]}}



the number of vertices 

\mbox{\Hypertarget{classgraph__encoder_a342688a3fdee511b7fae3f155cfb10cf}\label{classgraph__encoder_a342688a3fdee511b7fae3f155cfb10cf}} 
\index{graph\+\_\+encoder@{graph\+\_\+encoder}!Stilde@{Stilde}}
\index{Stilde@{Stilde}!graph\+\_\+encoder@{graph\+\_\+encoder}}
\subsubsection{\texorpdfstring{Stilde}{Stilde}}
{\footnotesize\ttfamily vector$<$int$>$ graph\+\_\+encoder\+::\+Stilde\hspace{0.3cm}{\ttfamily [private]}}



Summation of forward degrees at $n / \log^2 n$ many points. 

\mbox{\Hypertarget{classgraph__encoder_a3314c40920f2ee132958a6b0ce7e7995}\label{classgraph__encoder_a3314c40920f2ee132958a6b0ce7e7995}} 
\index{graph\+\_\+encoder@{graph\+\_\+encoder}!U@{U}}
\index{U@{U}!graph\+\_\+encoder@{graph\+\_\+encoder}}
\subsubsection{\texorpdfstring{U}{U}}
{\footnotesize\ttfamily \hyperlink{classreverse__fenwick__tree}{reverse\+\_\+fenwick\+\_\+tree} graph\+\_\+encoder\+::U\hspace{0.3cm}{\ttfamily [private]}}



a Fenwick tree which encodes the forward degrees to the right. When compute\+\_\+N is called for $i \leq j$, for $i \leq v$, we have $U_v = \sum_{k=v}^n d_k(i)$. 



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
\hyperlink{simple__graph__compression_8h}{simple\+\_\+graph\+\_\+compression.\+h}\item 
\hyperlink{simple__graph__compression_8cpp}{simple\+\_\+graph\+\_\+compression.\+cpp}\end{DoxyCompactItemize}
