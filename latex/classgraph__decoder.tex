\hypertarget{classgraph__decoder}{}\section{graph\+\_\+decoder Class Reference}
\label{classgraph__decoder}\index{graph\+\_\+decoder@{graph\+\_\+decoder}}


Decodes a simple unmarked graph.  




{\ttfamily \#include $<$simple\+\_\+graph\+\_\+compression.\+h$>$}

\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classgraph__decoder_a41aa2f322a170376a7904b008e9cdfe0}{graph\+\_\+decoder} (vector$<$ int $>$ a\+\_\+)
\begin{DoxyCompactList}\small\item\em constructor given the degree sequence \end{DoxyCompactList}\item 
void \hyperlink{classgraph__decoder_a97a9dcd5af21ece86fa91adcb41ca9cc}{init} ()
\begin{DoxyCompactList}\small\item\em initializes x to be empty vector of size n, and U and beta by a \end{DoxyCompactList}\item 
\hyperlink{classgraph}{graph} \hyperlink{classgraph__decoder_a3d2ef81ec6ac66e50c1809f361143922}{decode} (mpz\+\_\+class f, vector$<$ int $>$ t\+S\+\_\+)
\begin{DoxyCompactList}\small\item\em given $\tilde{N}$ and a vector $\tilde{S}$, decodes the graph and returns an object of type graph \end{DoxyCompactList}\item 
pair$<$ mpz\+\_\+class, mpz\+\_\+class $>$ \hyperlink{classgraph__decoder_af3ff99a4de6035ad257ebd7c6519cdd8}{decode\+\_\+node} (int i, mpz\+\_\+class tN)
\begin{DoxyCompactList}\small\item\em decode the node i \end{DoxyCompactList}\item 
pair$<$ mpz\+\_\+class, mpz\+\_\+class $>$ \hyperlink{classgraph__decoder_a2cb0bd279889a833d4c825e99eb72410}{decode\+\_\+interval} (int i, int j, int I, mpz\+\_\+class tN, int Sj)
\begin{DoxyCompactList}\small\item\em decodes the interval $[i,j]$ with interval index $I$. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
vector$<$ int $>$ \hyperlink{classgraph__decoder_a9dd7c3c11b8a45a12cb7c3c2d2bfa2cc}{a}
\begin{DoxyCompactList}\small\item\em the degree sequence of the graph. \end{DoxyCompactList}\item 
int \hyperlink{classgraph__decoder_a6bc1e72b2f7a913d14b789a6c2d92c1e}{n}
\begin{DoxyCompactList}\small\item\em the number of vertices, which is a.\+size() \end{DoxyCompactList}\item 
int \hyperlink{classgraph__decoder_a59663482843ffa5059128bd6ed866f11}{logn2}
\begin{DoxyCompactList}\small\item\em $\lfloor \log_2 n \rfloor^2$ \end{DoxyCompactList}\item 
vector$<$ vector$<$ int $>$ $>$ \hyperlink{classgraph__decoder_aa3f2776afe387668cf7f68109428e14e}{x}
\begin{DoxyCompactList}\small\item\em the forward adjacency list of the decoded graph \end{DoxyCompactList}\item 
vector$<$ int $>$ \hyperlink{classgraph__decoder_aa57c11e4c09c52101682ff83286162f7}{beta}
\begin{DoxyCompactList}\small\item\em the sequence $\vec{\beta}$, where after decoding vertex $i$, for $i \leq v\leq n$ we have $\beta_v = d_v(i)$. \end{DoxyCompactList}\item 
\hyperlink{classreverse__fenwick__tree}{reverse\+\_\+fenwick\+\_\+tree} \hyperlink{classgraph__decoder_a2fa9fec2cef06aaa410e57fb59d5c1ad}{U}
\begin{DoxyCompactList}\small\item\em a Fenwick tree initialized with the degree sequence a, and after decoding vertex $i$, for $i \leq v$, we have $U_v = \sum_{k=v}^{n-1} d_k(i)$. \end{DoxyCompactList}\item 
vector$<$ int $>$ \hyperlink{classgraph__decoder_ac466636b9b21122f4fa0246aa624978c}{tS}
\begin{DoxyCompactList}\small\item\em the $\tilde{S}$ vector, which stores the partial sums for the midpoints of intervals with length more than $\log^2 n$. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
Decodes a simple unmarked graph. 

Decodes a simple graph given its encoded version. We assume that the decoder knows the degree sequences of the encoded graph, hence these sequences must be given when a decoder object is being constructed. For instance, borrowing the degree sequence of the example we used to explain the \hyperlink{classgraph__encoder}{graph\+\_\+encoder} class\+:


\begin{DoxyCode}
vector<int> a = \{3,2,2,3\};
\hyperlink{classb__graph__decoder}{b\_graph\_decoder} D(a);
\end{DoxyCode}


Then, if variable f of type {\ttfamily pair$<$mpz\+\_\+class, vector$<$int$>$ $>$} is obtained from a \hyperlink{classgraph__encoder}{graph\+\_\+encoder} class, we can reconstruct the graph using f\+:


\begin{DoxyCode}
\hyperlink{classgraph}{graph} Ghat = D.decode(f.first, f.second);
\end{DoxyCode}


Then, the graph Ghat will be equal to the graph G. Here is a full example showing the procedure of compression and decompression together\+:


\begin{DoxyCode}
vector<int> a = \{3,2,2,3\}; \textcolor{comment}{// degree sequence}

\hyperlink{classgraph}{graph} G(\{1,2,3\},\{3\},\{3\},\{\}); \textcolor{comment}{// defining the graph}

\hyperlink{classgraph__encoder}{graph\_encoder} E(a); \textcolor{comment}{// constructing the encoder object}
pair<mpz\_class, vector<int> > f = E.encode(G);

\hyperlink{classgraph__decoder}{graph\_decoder} D(a);
\hyperlink{classgraph}{graph} Ghat = D.decode(f.first, f.second);

\textcolor{keywordflow}{if} (Ghat == G)
   cout << \textcolor{stringliteral}{" we successfully reconstructed the graph! "} << endl;
\end{DoxyCode}
 

\subsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classgraph__decoder_a41aa2f322a170376a7904b008e9cdfe0}\label{classgraph__decoder_a41aa2f322a170376a7904b008e9cdfe0}} 
\index{graph\+\_\+decoder@{graph\+\_\+decoder}!graph\+\_\+decoder@{graph\+\_\+decoder}}
\index{graph\+\_\+decoder@{graph\+\_\+decoder}!graph\+\_\+decoder@{graph\+\_\+decoder}}
\subsubsection{\texorpdfstring{graph\+\_\+decoder()}{graph\_decoder()}}
{\footnotesize\ttfamily graph\+\_\+decoder\+::graph\+\_\+decoder (\begin{DoxyParamCaption}\item[{vector$<$ int $>$}]{a\+\_\+ }\end{DoxyParamCaption})}



constructor given the degree sequence 


\begin{DoxyCode}
408 \{
409   \hyperlink{classgraph__decoder_a9dd7c3c11b8a45a12cb7c3c2d2bfa2cc}{a} = a\_;
410   \hyperlink{classgraph__decoder_a6bc1e72b2f7a913d14b789a6c2d92c1e}{n} = \hyperlink{classgraph__decoder_a9dd7c3c11b8a45a12cb7c3c2d2bfa2cc}{a}.size();
411 
412   \textcolor{keywordtype}{int} log2n = 0; \textcolor{comment}{// log of n in base 2}
413   \textcolor{keywordtype}{int} nn = \hyperlink{classgraph__decoder_a6bc1e72b2f7a913d14b789a6c2d92c1e}{n}; \textcolor{comment}{// a copy of n}
414   \textcolor{keywordflow}{while} (nn>0)\{
415     log2n ++;
416     nn = nn >> 1; \textcolor{comment}{// divide by 2}
417   \} \textcolor{comment}{// eventually, we count the number of bits in n}
418   log2n --; \textcolor{comment}{// we count extra, e.g. when n = 1, we end up having 1, rather than 0}
419   \hyperlink{classgraph__decoder_a59663482843ffa5059128bd6ed866f11}{logn2} = log2n * log2n;
420 
421   \hyperlink{classgraph__decoder_a97a9dcd5af21ece86fa91adcb41ca9cc}{init}(); \textcolor{comment}{// init x, beta and U}
422 \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\mbox{\Hypertarget{classgraph__decoder_a3d2ef81ec6ac66e50c1809f361143922}\label{classgraph__decoder_a3d2ef81ec6ac66e50c1809f361143922}} 
\index{graph\+\_\+decoder@{graph\+\_\+decoder}!decode@{decode}}
\index{decode@{decode}!graph\+\_\+decoder@{graph\+\_\+decoder}}
\subsubsection{\texorpdfstring{decode()}{decode()}}
{\footnotesize\ttfamily \hyperlink{classgraph}{graph} graph\+\_\+decoder\+::decode (\begin{DoxyParamCaption}\item[{mpz\+\_\+class}]{f,  }\item[{vector$<$ int $>$}]{t\+S\+\_\+ }\end{DoxyParamCaption})}



given $\tilde{N}$ and a vector $\tilde{S}$, decodes the graph and returns an object of type graph 


\begin{DoxyCode}
433 \{
434   \hyperlink{classgraph__decoder_a97a9dcd5af21ece86fa91adcb41ca9cc}{init}(); \textcolor{comment}{// make x, U and beta ready for decoding }
435   \hyperlink{classgraph__decoder_ac466636b9b21122f4fa0246aa624978c}{tS} = tS\_;
436   \textcolor{comment}{//mpz\_class prod\_a\_factorial = 1; // \(\backslash\)prod\_\{i=1\}^n a\_i!}
437   \textcolor{comment}{//for (int i=0; i<a.size();i++)}
438   \textcolor{comment}{//  prod\_a\_factorial *= compute\_product(a[i], a[i], 1);}
439 
440   mpz\_class prod\_a\_factorial = \hyperlink{compression__helper_8cpp_a86d8a20e022dc06b23df3b08ac10b7d1}{prod\_factorial}(\hyperlink{classgraph__decoder_a9dd7c3c11b8a45a12cb7c3c2d2bfa2cc}{a}, 0,\hyperlink{classgraph__decoder_a9dd7c3c11b8a45a12cb7c3c2d2bfa2cc}{a}.size()-1); \textcolor{comment}{// \(\backslash\)prod\_\{i=0\}^\{n-1\} a\_i!}
441   mpz\_class tN = f * prod\_a\_factorial;
442   \hyperlink{classgraph__decoder_a2cb0bd279889a833d4c825e99eb72410}{decode\_interval}(0,\hyperlink{classgraph__decoder_a6bc1e72b2f7a913d14b789a6c2d92c1e}{n}-1,1,tN,0);
443   \textcolor{keywordflow}{return} \hyperlink{classgraph}{graph}(\hyperlink{classgraph__decoder_aa3f2776afe387668cf7f68109428e14e}{x}, \hyperlink{classgraph__decoder_a9dd7c3c11b8a45a12cb7c3c2d2bfa2cc}{a});
444 \}
\end{DoxyCode}
\mbox{\Hypertarget{classgraph__decoder_a2cb0bd279889a833d4c825e99eb72410}\label{classgraph__decoder_a2cb0bd279889a833d4c825e99eb72410}} 
\index{graph\+\_\+decoder@{graph\+\_\+decoder}!decode\+\_\+interval@{decode\+\_\+interval}}
\index{decode\+\_\+interval@{decode\+\_\+interval}!graph\+\_\+decoder@{graph\+\_\+decoder}}
\subsubsection{\texorpdfstring{decode\+\_\+interval()}{decode\_interval()}}
{\footnotesize\ttfamily pair$<$ mpz\+\_\+class, mpz\+\_\+class $>$ graph\+\_\+decoder\+::decode\+\_\+interval (\begin{DoxyParamCaption}\item[{int}]{i,  }\item[{int}]{j,  }\item[{int}]{I,  }\item[{mpz\+\_\+class}]{tN,  }\item[{int}]{Sj }\end{DoxyParamCaption})}



decodes the interval $[i,j]$ with interval index $I$. 


\begin{DoxyParams}{Parameters}
{\em i,j} & intervals endpoints \\
\hline
{\em I} & the index of the interval \\
\hline
{\em tN} & $\tilde{N}_{i,j}$ \\
\hline
{\em Sj} & $S_{j+1}$ \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a pair $N_{i,j}, l_{i,j}$ where $N_{i,j} = N_{i,j}(G)$ and $l_{i,j} = l_{i,j}(G)$ 
\end{DoxyReturn}

\begin{DoxyCode}
499 \{
500   \textcolor{comment}{//cerr << " decode interval " << i << " " << j << " tN " << tN << endl;}
501   \textcolor{keywordflow}{if} (i == j)
502     \textcolor{keywordflow}{return} \hyperlink{classgraph__decoder_af3ff99a4de6035ad257ebd7c6519cdd8}{decode\_node}(i, tN);
503 
504   \textcolor{comment}{// sweeping for zero nodes}
505 
506   \textcolor{keywordtype}{int} t; \textcolor{comment}{// place to break}
507   \textcolor{keywordtype}{int} St; \textcolor{comment}{// S\_\{t+1\}}
508   \textcolor{keywordflow}{if} ((j-i) > \hyperlink{classgraph__decoder_a59663482843ffa5059128bd6ed866f11}{logn2})\{
509     \textcolor{comment}{//cerr << " long interval I = " << I << endl;}
510     t = (i+j) / 2; \textcolor{comment}{// break at middle, since we have \(\backslash\)tilde\{S\}}
511     St = \hyperlink{classgraph__decoder_ac466636b9b21122f4fa0246aa624978c}{tS}[I]; \textcolor{comment}{// looking at the \(\backslash\)f$\(\backslash\)tilde\{S\}\(\backslash\)f$ vector}
512   \}\textcolor{keywordflow}{else}\{
513     \textcolor{comment}{//cerr << " short interval " << endl;}
514     t = i;
515     St = \hyperlink{classgraph__decoder_a2fa9fec2cef06aaa410e57fb59d5c1ad}{U}.\hyperlink{classreverse__fenwick__tree_a672731fd6395b4853430073a099a80e6}{sum}(i) - 2 * \hyperlink{classgraph__decoder_aa57c11e4c09c52101682ff83286162f7}{beta}[i];
516   \}
517 
518   \textcolor{comment}{//cerr << " decode interval " << i << " " << j << " t " << t << " St " << St << " Sj " << Sj << endl;}
519   mpz\_class rtj; \textcolor{comment}{// \(\backslash\)f$t\_\{t+1, j\}\(\backslash\)f$}
520   mpz\_class tNit; \textcolor{comment}{// \(\backslash\)f$\(\backslash\)tilde\{N\}\_\{i,t\}\(\backslash\)f$ for the left decoder}
521   mpz\_class tNtj; \textcolor{comment}{// \(\backslash\)f$\(\backslash\)tilde\{N\}\_\{t+1, j\}\(\backslash\)f$ for the right decoder }
522   mpz\_class Nit; \textcolor{comment}{// the true N\_\{i,t\} returned by the left decoder}
523   mpz\_class lit; \textcolor{comment}{// the true l\_\{i,t\} returned by the left decoder}
524   mpz\_class Ntj; \textcolor{comment}{// the true N\_\{t+1, j\} returned by the right decoder}
525   mpz\_class ltj; \textcolor{comment}{// the true l\_\{t+1,j\} returned by the right decoder}
526   mpz\_class Nij; \textcolor{comment}{// the true N\_\{i,j\} to return}
527   mpz\_class lij; \textcolor{comment}{// the true l\_\{i,j\} to return}
528 
529   pair<mpz\_class, mpz\_class> ans; \textcolor{comment}{// returned by subintervals }
530 
531 
532   rtj = \hyperlink{compression__helper_8cpp_ae2afb43aabe50f7d42aae8f82b5a35f4}{compute\_product}(St - 1, (St - Sj)/2, 2);
533   \textcolor{comment}{//cerr << " interval " << i << " " << j << " t " << t << " St " << St << " rtj " << rtj << endl;}
534   tNit = tN / rtj;
535 
536   \textcolor{comment}{// calling the left decoder }
537   ans = \hyperlink{classgraph__decoder_a2cb0bd279889a833d4c825e99eb72410}{decode\_interval}(i,t,2*I,tNit, St); 
538   Nit = ans.first;
539   lit = ans.second;
540 
541   \textcolor{comment}{// reducing the contribution of the left decoder to prepare for the right decoder}
542   tNtj = (tN - Nit * rtj) / lit;
543 
544   \textcolor{comment}{// calling the right decoder}
545   ans = \hyperlink{classgraph__decoder_a2cb0bd279889a833d4c825e99eb72410}{decode\_interval}(t+1, j, 2*I + 1, tNtj, Sj);
546   Ntj = ans.first;
547   ltj = ans.second;
548 
549   \textcolor{comment}{// preparing Nij and lij to return}
550   Nij = Nit * rtj + lit * Ntj;
551   lij = lit * ltj;
552   \textcolor{keywordflow}{return} pair<mpz\_class, mpz\_class> (Nij, lij);
553 \}
\end{DoxyCode}
\mbox{\Hypertarget{classgraph__decoder_af3ff99a4de6035ad257ebd7c6519cdd8}\label{classgraph__decoder_af3ff99a4de6035ad257ebd7c6519cdd8}} 
\index{graph\+\_\+decoder@{graph\+\_\+decoder}!decode\+\_\+node@{decode\+\_\+node}}
\index{decode\+\_\+node@{decode\+\_\+node}!graph\+\_\+decoder@{graph\+\_\+decoder}}
\subsubsection{\texorpdfstring{decode\+\_\+node()}{decode\_node()}}
{\footnotesize\ttfamily pair$<$ mpz\+\_\+class, mpz\+\_\+class $>$ graph\+\_\+decoder\+::decode\+\_\+node (\begin{DoxyParamCaption}\item[{int}]{i,  }\item[{mpz\+\_\+class}]{tN }\end{DoxyParamCaption})}



decode the node i 


\begin{DoxyParams}{Parameters}
{\em i} & the vertex index \\
\hline
{\em tN} & $\tilde{N}_{i,i}$ \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a pair $(N_{i,i}, l_i)$ where $l_i = l_i(G)$ and $N_{i,i} = N_{i,i}(G)$ 
\end{DoxyReturn}

\begin{DoxyCode}
447 \{
448   \textcolor{comment}{//cerr << " decode node " << i << " tN " << tN << endl;}
449   \textcolor{comment}{//cerr << " beta[i] " << beta[i] << endl;}
450   \textcolor{comment}{//cerr << " beta " << endl;}
451   \textcolor{comment}{//for (int k = i; k< n;k++)}
452   \textcolor{comment}{//  cerr << k << " " << beta[k] << endl;}
453   \textcolor{comment}{//cerr << " U " << endl;}
454   \textcolor{comment}{//for (int k=i;k<n;k++)}
455   \textcolor{comment}{//  cerr << k << " " << U.sum(k) << endl;}
456 
457   \textcolor{keywordflow}{if} (\hyperlink{classgraph__decoder_aa57c11e4c09c52101682ff83286162f7}{beta}[i] == 0)
458     \textcolor{keywordflow}{return} pair<mpz\_class, mpz\_class> (0,1);
459 
460   mpz\_class li = 1; \textcolor{comment}{// l\_i(G)}
461   mpz\_class Ni = 0; \textcolor{comment}{// N\_\{i,i\}(G)}
462   \textcolor{keywordtype}{int} f, g; \textcolor{comment}{// endpoints for the binary search}
463   \textcolor{keywordtype}{int} t; \textcolor{comment}{// midpoint for the binary search}
464   mpz\_class zik, lik; 
465   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} k=0;k<\hyperlink{classgraph__decoder_aa57c11e4c09c52101682ff83286162f7}{beta}[i];k++)\{
466     \textcolor{keywordflow}{if} (k==0)
467       f = i+1;
468     \textcolor{keywordflow}{else}
469       f = \hyperlink{classgraph__decoder_aa3f2776afe387668cf7f68109428e14e}{x}[i][k-1]+1;
470     g = \hyperlink{classgraph__decoder_a6bc1e72b2f7a913d14b789a6c2d92c1e}{n}-1;
471     \textcolor{keywordflow}{while}(g > f)\{
472       \textcolor{comment}{//cerr << " f , g " << f << " " << g << endl;}
473       t = (f+g)/2;
474       \textcolor{comment}{// binary search:}
475       \textcolor{keywordflow}{if}(\hyperlink{compression__helper_8cpp_ae2afb43aabe50f7d42aae8f82b5a35f4}{compute\_product}(\hyperlink{classgraph__decoder_a2fa9fec2cef06aaa410e57fb59d5c1ad}{U}.\hyperlink{classreverse__fenwick__tree_a672731fd6395b4853430073a099a80e6}{sum}(t+1), beta[i] - k, 1) <= tN)
476         g = t;
477       \textcolor{keywordflow}{else}
478         f = t+1;
479     \}
480     \hyperlink{classgraph__decoder_aa3f2776afe387668cf7f68109428e14e}{x}[i].push\_back(f);
481     zik = \hyperlink{compression__helper_8cpp_ae2afb43aabe50f7d42aae8f82b5a35f4}{compute\_product}(\hyperlink{classgraph__decoder_a2fa9fec2cef06aaa410e57fb59d5c1ad}{U}.\hyperlink{classreverse__fenwick__tree_a672731fd6395b4853430073a099a80e6}{sum}(\hyperlink{classgraph__decoder_aa3f2776afe387668cf7f68109428e14e}{x}[i][k]+1), beta[i] - k, 1);
482     Ni += li * zik;
483     lik = (beta[i] - k) * beta[\hyperlink{classgraph__decoder_aa3f2776afe387668cf7f68109428e14e}{x}[i][k]];
484     li *= lik;
485     tN -= zik;
486     tN /= lik;
487     \hyperlink{classgraph__decoder_a2fa9fec2cef06aaa410e57fb59d5c1ad}{U}.\hyperlink{classreverse__fenwick__tree_a942d7f49b37e53ebfec3076d177691d7}{add}(\hyperlink{classgraph__decoder_aa3f2776afe387668cf7f68109428e14e}{x}[i][k],-1);
488     beta[\hyperlink{classgraph__decoder_aa3f2776afe387668cf7f68109428e14e}{x}[i][k]] --;
489   \}
490   \textcolor{comment}{//cerr << " decoded for " << i << " x: " << endl;}
491   \textcolor{comment}{//for (int j=0;j<x[i].size(); j++)}
492   \textcolor{comment}{//  cerr << x[i][j] << " " ;}
493   \textcolor{comment}{//cerr << endl;}
494   \textcolor{keywordflow}{return} pair<mpz\_class, mpz\_class> (Ni, li);
495 \}
\end{DoxyCode}
\mbox{\Hypertarget{classgraph__decoder_a97a9dcd5af21ece86fa91adcb41ca9cc}\label{classgraph__decoder_a97a9dcd5af21ece86fa91adcb41ca9cc}} 
\index{graph\+\_\+decoder@{graph\+\_\+decoder}!init@{init}}
\index{init@{init}!graph\+\_\+decoder@{graph\+\_\+decoder}}
\subsubsection{\texorpdfstring{init()}{init()}}
{\footnotesize\ttfamily void graph\+\_\+decoder\+::init (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



initializes x to be empty vector of size n, and U and beta by a 


\begin{DoxyCode}
425 \{
426   \hyperlink{classgraph__decoder_aa3f2776afe387668cf7f68109428e14e}{x}.clear();
427   \hyperlink{classgraph__decoder_aa3f2776afe387668cf7f68109428e14e}{x}.resize(\hyperlink{classgraph__decoder_a6bc1e72b2f7a913d14b789a6c2d92c1e}{n});
428   \hyperlink{classgraph__decoder_aa57c11e4c09c52101682ff83286162f7}{beta} = \hyperlink{classgraph__decoder_a9dd7c3c11b8a45a12cb7c3c2d2bfa2cc}{a};
429   \hyperlink{classgraph__decoder_a2fa9fec2cef06aaa410e57fb59d5c1ad}{U} = \hyperlink{classreverse__fenwick__tree}{reverse\_fenwick\_tree}(\hyperlink{classgraph__decoder_a9dd7c3c11b8a45a12cb7c3c2d2bfa2cc}{a});
430 \}
\end{DoxyCode}


\subsection{Member Data Documentation}
\mbox{\Hypertarget{classgraph__decoder_a9dd7c3c11b8a45a12cb7c3c2d2bfa2cc}\label{classgraph__decoder_a9dd7c3c11b8a45a12cb7c3c2d2bfa2cc}} 
\index{graph\+\_\+decoder@{graph\+\_\+decoder}!a@{a}}
\index{a@{a}!graph\+\_\+decoder@{graph\+\_\+decoder}}
\subsubsection{\texorpdfstring{a}{a}}
{\footnotesize\ttfamily vector$<$int$>$ graph\+\_\+decoder\+::a\hspace{0.3cm}{\ttfamily [private]}}



the degree sequence of the graph. 

\mbox{\Hypertarget{classgraph__decoder_aa57c11e4c09c52101682ff83286162f7}\label{classgraph__decoder_aa57c11e4c09c52101682ff83286162f7}} 
\index{graph\+\_\+decoder@{graph\+\_\+decoder}!beta@{beta}}
\index{beta@{beta}!graph\+\_\+decoder@{graph\+\_\+decoder}}
\subsubsection{\texorpdfstring{beta}{beta}}
{\footnotesize\ttfamily vector$<$int$>$ graph\+\_\+decoder\+::beta\hspace{0.3cm}{\ttfamily [private]}}



the sequence $\vec{\beta}$, where after decoding vertex $i$, for $i \leq v\leq n$ we have $\beta_v = d_v(i)$. 

\mbox{\Hypertarget{classgraph__decoder_a59663482843ffa5059128bd6ed866f11}\label{classgraph__decoder_a59663482843ffa5059128bd6ed866f11}} 
\index{graph\+\_\+decoder@{graph\+\_\+decoder}!logn2@{logn2}}
\index{logn2@{logn2}!graph\+\_\+decoder@{graph\+\_\+decoder}}
\subsubsection{\texorpdfstring{logn2}{logn2}}
{\footnotesize\ttfamily int graph\+\_\+decoder\+::logn2\hspace{0.3cm}{\ttfamily [private]}}



$\lfloor \log_2 n \rfloor^2$ 

\mbox{\Hypertarget{classgraph__decoder_a6bc1e72b2f7a913d14b789a6c2d92c1e}\label{classgraph__decoder_a6bc1e72b2f7a913d14b789a6c2d92c1e}} 
\index{graph\+\_\+decoder@{graph\+\_\+decoder}!n@{n}}
\index{n@{n}!graph\+\_\+decoder@{graph\+\_\+decoder}}
\subsubsection{\texorpdfstring{n}{n}}
{\footnotesize\ttfamily int graph\+\_\+decoder\+::n\hspace{0.3cm}{\ttfamily [private]}}



the number of vertices, which is a.\+size() 

\mbox{\Hypertarget{classgraph__decoder_ac466636b9b21122f4fa0246aa624978c}\label{classgraph__decoder_ac466636b9b21122f4fa0246aa624978c}} 
\index{graph\+\_\+decoder@{graph\+\_\+decoder}!tS@{tS}}
\index{tS@{tS}!graph\+\_\+decoder@{graph\+\_\+decoder}}
\subsubsection{\texorpdfstring{tS}{tS}}
{\footnotesize\ttfamily vector$<$int$>$ graph\+\_\+decoder\+::tS\hspace{0.3cm}{\ttfamily [private]}}



the $\tilde{S}$ vector, which stores the partial sums for the midpoints of intervals with length more than $\log^2 n$. 

\mbox{\Hypertarget{classgraph__decoder_a2fa9fec2cef06aaa410e57fb59d5c1ad}\label{classgraph__decoder_a2fa9fec2cef06aaa410e57fb59d5c1ad}} 
\index{graph\+\_\+decoder@{graph\+\_\+decoder}!U@{U}}
\index{U@{U}!graph\+\_\+decoder@{graph\+\_\+decoder}}
\subsubsection{\texorpdfstring{U}{U}}
{\footnotesize\ttfamily \hyperlink{classreverse__fenwick__tree}{reverse\+\_\+fenwick\+\_\+tree} graph\+\_\+decoder\+::U\hspace{0.3cm}{\ttfamily [private]}}



a Fenwick tree initialized with the degree sequence a, and after decoding vertex $i$, for $i \leq v$, we have $U_v = \sum_{k=v}^{n-1} d_k(i)$. 

\mbox{\Hypertarget{classgraph__decoder_aa3f2776afe387668cf7f68109428e14e}\label{classgraph__decoder_aa3f2776afe387668cf7f68109428e14e}} 
\index{graph\+\_\+decoder@{graph\+\_\+decoder}!x@{x}}
\index{x@{x}!graph\+\_\+decoder@{graph\+\_\+decoder}}
\subsubsection{\texorpdfstring{x}{x}}
{\footnotesize\ttfamily vector$<$vector$<$int$>$ $>$ graph\+\_\+decoder\+::x\hspace{0.3cm}{\ttfamily [private]}}



the forward adjacency list of the decoded graph 



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
\hyperlink{simple__graph__compression_8h}{simple\+\_\+graph\+\_\+compression.\+h}\item 
\hyperlink{simple__graph__compression_8cpp}{simple\+\_\+graph\+\_\+compression.\+cpp}\end{DoxyCompactItemize}
