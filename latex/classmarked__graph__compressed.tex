\hypertarget{classmarked__graph__compressed}{}\section{marked\+\_\+graph\+\_\+compressed Class Reference}
\label{classmarked__graph__compressed}\index{marked\+\_\+graph\+\_\+compressed@{marked\+\_\+graph\+\_\+compressed}}


{\ttfamily \#include $<$marked\+\_\+graph\+\_\+compression.\+h$>$}

\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classmarked__graph__compressed_af58307bfadcaa4c3ca6dd594c2f9b3a9}{clear} ()
\item 
void \hyperlink{classmarked__graph__compressed_ab9cdb7fc43badd58fb5202f74ffac723}{binary\+\_\+write} (F\+I\+LE $\ast$f)
\begin{DoxyCompactList}\small\item\em writes the compressed data to a binary file \end{DoxyCompactList}\item 
void \hyperlink{classmarked__graph__compressed_a13ab09e4b399f179ec91746ae2b8b38c}{binary\+\_\+write} (string s)
\item 
void \hyperlink{classmarked__graph__compressed_a9db2d11bd63ad3d5a75e47b4023a89dd}{binary\+\_\+read} (F\+I\+LE $\ast$f)
\begin{DoxyCompactList}\small\item\em read the compressed data from a binary file \end{DoxyCompactList}\item 
void \hyperlink{classmarked__graph__compressed_a01c67fe4234738db6bb60459515c3ad8}{binary\+\_\+read} (string s)
\end{DoxyCompactItemize}
\subsection*{Public Attributes}
\begin{DoxyCompactItemize}
\item 
int \hyperlink{classmarked__graph__compressed_a8d841016ddb11cfd33748c8deb6277ba}{n}
\begin{DoxyCompactList}\small\item\em the number of vertices \end{DoxyCompactList}\item 
int \hyperlink{classmarked__graph__compressed_af6ff623407b673d08d0cab77b39c2193}{h}
\begin{DoxyCompactList}\small\item\em the depth up to which the compression was performed \end{DoxyCompactList}\item 
int \hyperlink{classmarked__graph__compressed_a8b2aaac68e9332ddc78d88eb60b323a7}{delta}
\begin{DoxyCompactList}\small\item\em the degree threshold used when compression was performed \end{DoxyCompactList}\item 
pair$<$ vector$<$ int $>$, mpz\+\_\+class $>$ \hyperlink{classmarked__graph__compressed_a7a4ced4586e2e353f9076bd447df5208}{star\+\_\+vertices}
\begin{DoxyCompactList}\small\item\em the compressed form of the star\+\_\+vertices list \end{DoxyCompactList}\item 
map$<$ pair$<$ int, int $>$, vector$<$ vector$<$ int $>$ $>$ $>$ \hyperlink{classmarked__graph__compressed_a7df5779d313486644132bd816937f532}{star\+\_\+edges}
\begin{DoxyCompactList}\small\item\em for each pair of edge marks x,x\textquotesingle{}, and integer $k$, star\+\_\+edges\mbox{[}pair$<$int,int$>$(x,x\textquotesingle{})\mbox{]}\mbox{[}k\mbox{]} is a list of neighbors $w$ of the $k$th star vertex (say $v$) so that $v$ shares a star edge with $w$ so that the mark towards $v$ is x and the mark towards $w$ is xp. \end{DoxyCompactList}\item 
vector$<$ int $>$ \hyperlink{classmarked__graph__compressed_a86b00223525703e973415cbc9c94da68}{type\+\_\+mark}
\begin{DoxyCompactList}\small\item\em for an edge type t, type\+\_\+mark\mbox{[}t\mbox{]} denotes the mark component of t \end{DoxyCompactList}\item 
vector$<$ vector$<$ int $>$ $>$ \hyperlink{classmarked__graph__compressed_af2e3e55223d436628a02758dfae88493}{ver\+\_\+type\+\_\+list}
\begin{DoxyCompactList}\small\item\em the list of all vertex types that appear in the graph, where the type of a vertex is a vector of integers, where its index 0 is the mark of the vertex, and indices $3k+1$, $3k+2$, $3k+3$ are $m$, $m'$ and $n_{m,m'}$, where $(m,m')$ is a type pair, and $n_{m,m'}$ is the number of edges connected to the vertex with that type. The list is sorted lexicographically to ensure unique representation. \end{DoxyCompactList}\item 
pair$<$ vector$<$ int $>$, mpz\+\_\+class $>$ \hyperlink{classmarked__graph__compressed_af446cc5e23c241a92b76642fd5ebc403}{ver\+\_\+types}
\begin{DoxyCompactList}\small\item\em the compressed form of vertex types, where the type of a vertex is the index with respect to ver\+\_\+type\+\_\+list of the list of integers specifying the type of the vertex (mark of the vertex followed by the number of edges of each type connected to that vertex) \end{DoxyCompactList}\item 
map$<$ pair$<$ int, int $>$, mpz\+\_\+class $>$ \hyperlink{classmarked__graph__compressed_a7b3267063fba30b45eb21b3ba4e07536}{part\+\_\+bgraph}
\begin{DoxyCompactList}\small\item\em compressed form of partition bipartite graphs corresponding to colors in $C_<$. For a pair $0 \leq t < t' < L$ of half edge types, part\+\_\+bgraph\mbox{[}pair$<$int, int$>$(t,t\textquotesingle{})\mbox{]} is the compressed form of the bipartite graph with n left and right nodes, where a left node i is connected to a right node j if there is an edge connecting i to j with type t towards i and type t\textquotesingle{} towards j \end{DoxyCompactList}\item 
map$<$ int, pair$<$ mpz\+\_\+class, vector$<$ int $>$ $>$ $>$ \hyperlink{classmarked__graph__compressed_ae179a4737e6eab905c18a94d44ef64b7}{part\+\_\+graph}
\begin{DoxyCompactList}\small\item\em compressed form of partition graphs corresponding to colors in $C_=$. For a half edge type t, part\+\_\+graph\mbox{[}t\mbox{]} is the compressed form of the simple unmarked graph with n vertices, where a node i is connected to a node j where there is an edge between i and j in the original graph with color (t,t) \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Member Function Documentation}
\mbox{\Hypertarget{classmarked__graph__compressed_a9db2d11bd63ad3d5a75e47b4023a89dd}\label{classmarked__graph__compressed_a9db2d11bd63ad3d5a75e47b4023a89dd}} 
\index{marked\+\_\+graph\+\_\+compressed@{marked\+\_\+graph\+\_\+compressed}!binary\+\_\+read@{binary\+\_\+read}}
\index{binary\+\_\+read@{binary\+\_\+read}!marked\+\_\+graph\+\_\+compressed@{marked\+\_\+graph\+\_\+compressed}}
\subsubsection{\texorpdfstring{binary\+\_\+read()}{binary\_read()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void marked\+\_\+graph\+\_\+compressed\+::binary\+\_\+read (\begin{DoxyParamCaption}\item[{F\+I\+LE $\ast$}]{f }\end{DoxyParamCaption})}



read the compressed data from a binary file 


\begin{DoxyParams}{Parameters}
{\em f} & a {\ttfamily F\+I\+L\+E$\ast$} object which is the address of the binary file to write \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
595                                                 \{
596   \hyperlink{classmarked__graph__compressed_af58307bfadcaa4c3ca6dd594c2f9b3a9}{clear}(); \textcolor{comment}{// to make sure nothing is stored inside me before reading}
597 
598   \textcolor{comment}{// ==== read n, h, delta}
599   fread(&\hyperlink{classmarked__graph__compressed_a8d841016ddb11cfd33748c8deb6277ba}{n}, \textcolor{keyword}{sizeof} \hyperlink{classmarked__graph__compressed_a8d841016ddb11cfd33748c8deb6277ba}{n}, 1, f);
600   fread(&\hyperlink{classmarked__graph__compressed_af6ff623407b673d08d0cab77b39c2193}{h}, \textcolor{keyword}{sizeof} \hyperlink{classmarked__graph__compressed_af6ff623407b673d08d0cab77b39c2193}{h}, 1, f);
601   fread(&\hyperlink{classmarked__graph__compressed_a8b2aaac68e9332ddc78d88eb60b323a7}{delta}, \textcolor{keyword}{sizeof} \hyperlink{classmarked__graph__compressed_a8b2aaac68e9332ddc78d88eb60b323a7}{delta}, 1, f);
602 
603   \textcolor{keywordtype}{int} int\_in; \textcolor{comment}{// auxiliary input integer}
604   \textcolor{comment}{// ===== read type\_mark}
605   \textcolor{comment}{// read number of types}
606   fread(&int\_in, \textcolor{keyword}{sizeof} int\_in, 1, f);
607   \hyperlink{classmarked__graph__compressed_a86b00223525703e973415cbc9c94da68}{type\_mark}.resize(int\_in);
608   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0;i<\hyperlink{classmarked__graph__compressed_a86b00223525703e973415cbc9c94da68}{type\_mark}.size();i++)\{
609     fread(&int\_in, \textcolor{keyword}{sizeof} int\_in, 1, f);
610     \hyperlink{classmarked__graph__compressed_a86b00223525703e973415cbc9c94da68}{type\_mark}[i] = int\_in;
611   \}
612 
613   \textcolor{comment}{// ==== read star\_vertices}
614   \textcolor{comment}{// first, read the frequency.}
615   \hyperlink{classmarked__graph__compressed_a7a4ced4586e2e353f9076bd447df5208}{star\_vertices}.first = vector<int>(2); \textcolor{comment}{// frequency,}
616   \textcolor{comment}{// we read its first index which is number of zeros, and the second is n - the first.}
617   fread(&int\_in, \textcolor{keyword}{sizeof} int\_in, 1, f);
618   \hyperlink{classmarked__graph__compressed_a7a4ced4586e2e353f9076bd447df5208}{star\_vertices}.first[0] = int\_in;
619   \hyperlink{classmarked__graph__compressed_a7a4ced4586e2e353f9076bd447df5208}{star\_vertices}.first[1] = \hyperlink{classmarked__graph__compressed_a8d841016ddb11cfd33748c8deb6277ba}{n} - int\_in;
620 
621   \textcolor{comment}{// the integer representation which is star\_vertices.second}
622   mpz\_inp\_raw(\hyperlink{classmarked__graph__compressed_a7a4ced4586e2e353f9076bd447df5208}{star\_vertices}.second.get\_mpz\_t(), f);
623 
624   \textcolor{comment}{// ==== read star\_edges}
625 
626   \textcolor{keywordtype}{int} log2n = 0; \textcolor{comment}{// the ceiling of log (n+1) in base 2 (which is equal to 1 + the floor of log\_2 n), which
       is the number of bits to encode vertices}
627   \textcolor{keywordtype}{int} n\_copy = \hyperlink{classmarked__graph__compressed_a8d841016ddb11cfd33748c8deb6277ba}{n};
628   \textcolor{keywordflow}{while}(n\_copy > 0)\{
629     n\_copy >>= 1;
630     log2n ++;
631   \}
632   bitset<8*sizeof(int)> B; \textcolor{comment}{// a bit stream with maximum length of int to store a vertex index}
633 
634   \textcolor{keywordtype}{string} s;
635   stringstream ss;
636   \textcolor{keywordtype}{int} sp; \textcolor{comment}{// the index of the string s we are studying }
637 
638   \textcolor{comment}{// read the size of star\_edges}
639 
640   \textcolor{keywordtype}{int} star\_edges\_size;
641   fread(&star\_edges\_size, \textcolor{keyword}{sizeof} star\_edges\_size, 1, f);
642 
643   \textcolor{keywordtype}{int} x, xp; \textcolor{comment}{// edge marks}
644   \textcolor{keywordtype}{int} nu\_star\_vertices = \hyperlink{classmarked__graph__compressed_a7a4ced4586e2e353f9076bd447df5208}{star\_vertices}.first[1];
645 
646   vector<vector<int> > V; \textcolor{comment}{// the list of star edges corresponding to each mark pair}
647   V.resize(nu\_star\_vertices);
648 
649   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0;i<star\_edges\_size;i++)\{
650     fread(&x, \textcolor{keyword}{sizeof} x, 1, f);
651     fread(&xp, \textcolor{keyword}{sizeof} xp, 1, f);
652   
653     s = \hyperlink{compression__helper_8cpp_a40e8dcbc036f96b28e003e882c4890b7}{bit\_string\_read}(f);
654     \textcolor{comment}{//cerr << " read  x " << x << " xp " << xp << " s " << s << endl;}
655     sp = 0; \textcolor{comment}{// starting from zero }
656     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j=0; j<nu\_star\_vertices; j++)\{ \textcolor{comment}{// }
657       V[j].clear(); \textcolor{comment}{// make it fresh}
658       \textcolor{keywordflow}{while}(s[sp++] == \textcolor{charliteral}{'1'})\{ \textcolor{comment}{// there is still some edge connected to this vertex }
659         \textcolor{comment}{// read log2n many bits}
660         \textcolor{comment}{//cerr << " s subtr " << s.substr(sp, log2n);}
661         \textcolor{comment}{//ss << s.substr(sp, log2n);}
662         B = bitset<8*sizeof(int)>(s.substr(sp, log2n));
663         \textcolor{comment}{//cerr << " ss " << ss.str() << endl;}
664         sp += log2n;
665         \textcolor{comment}{//ss >> B;}
666 
667         V[j].push\_back(B.to\_ulong());
668       \}
669       \textcolor{comment}{//for (int k=0;k<V[j].size();k++)}
670       \textcolor{comment}{//  cerr << " , " << V[j][k];}
671       \textcolor{comment}{//cerr << endl;}
672     \}
673 
674 
675     \hyperlink{classmarked__graph__compressed_a7df5779d313486644132bd816937f532}{star\_edges}.insert(pair< pair<int, int> , vector<vector<int> > > (pair<int, int>(x, xp), V));
676   \}
677 
678   \textcolor{comment}{// ==== read vertex\_types}
679 
680   \textcolor{comment}{// read ver\_type\_list}
681   fread(&int\_in, \textcolor{keyword}{sizeof} int\_in, 1, f); \textcolor{comment}{// size of ver\_type\_list}
682   \hyperlink{classmarked__graph__compressed_af2e3e55223d436628a02758dfae88493}{ver\_type\_list}.resize(int\_in);
683   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0; i<\hyperlink{classmarked__graph__compressed_af2e3e55223d436628a02758dfae88493}{ver\_type\_list}.size();i++)\{
684     fread(&int\_in, \textcolor{keyword}{sizeof} int\_in, 1, f); \textcolor{comment}{// size of ver\_type\_list[i]}
685     \hyperlink{classmarked__graph__compressed_af2e3e55223d436628a02758dfae88493}{ver\_type\_list}[i].resize(int\_in);
686     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j=0;j<\hyperlink{classmarked__graph__compressed_af2e3e55223d436628a02758dfae88493}{ver\_type\_list}[i].size();j++)\{
687       fread(&int\_in, \textcolor{keyword}{sizeof} int\_in, 1, f);
688       \hyperlink{classmarked__graph__compressed_af2e3e55223d436628a02758dfae88493}{ver\_type\_list}[i][j] = int\_in;
689     \}
690   \}
691 
692   \textcolor{comment}{// ver\_types}
693   \textcolor{comment}{// ver\_types.first}
694   \textcolor{comment}{// ver\_types.first.size()}
695   fread(&int\_in, \textcolor{keyword}{sizeof} int\_in, 1, f);
696   \hyperlink{classmarked__graph__compressed_af446cc5e23c241a92b76642fd5ebc403}{ver\_types}.first.resize(int\_in);
697   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0;i<\hyperlink{classmarked__graph__compressed_af446cc5e23c241a92b76642fd5ebc403}{ver\_types}.first.size();i++)\{
698     fread(&int\_in, \textcolor{keyword}{sizeof} int\_in, 1, f);
699     \hyperlink{classmarked__graph__compressed_af446cc5e23c241a92b76642fd5ebc403}{ver\_types}.first[i] = int\_in;
700   \}
701   \textcolor{comment}{// ver\_types.second}
702   mpz\_inp\_raw(\hyperlink{classmarked__graph__compressed_af446cc5e23c241a92b76642fd5ebc403}{ver\_types}.second.get\_mpz\_t(), f);
703 
704 
705   \textcolor{comment}{// === part bgraphs}
706   \textcolor{keywordtype}{int} part\_bgraph\_size;
707   \textcolor{keywordtype}{int} t, tp;
708   pair<int, int> type; 
709   mpz\_class part\_g; 
710   fread(&part\_bgraph\_size, \textcolor{keyword}{sizeof} part\_bgraph\_size, 1, f);
711   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0;i<part\_bgraph\_size;i++)\{
712     \textcolor{comment}{// read t, t'}
713     fread(&t, \textcolor{keyword}{sizeof} t, 1, f);
714     fread(&tp, \textcolor{keyword}{sizeof} tp, 1, f);
715     type = pair<int, int>(t, tp);
716     mpz\_inp\_raw(part\_g.get\_mpz\_t(), f);
717     \hyperlink{classmarked__graph__compressed_a7b3267063fba30b45eb21b3ba4e07536}{part\_bgraph}.insert(pair<pair<int, int>, mpz\_class> (type, part\_g));
718   \}
719 
720   \textcolor{comment}{// === part graphs}
721 
722   \textcolor{comment}{// first, the size}
723   \textcolor{keywordtype}{int} part\_graph\_size;
724   \textcolor{keywordtype}{int} v\_size;
725   vector<int> W; 
726   fread(&part\_graph\_size, \textcolor{keyword}{sizeof} part\_graph\_size, 1, f);
727   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0;i<part\_graph\_size; i++)\{
728     \textcolor{comment}{// first, the type}
729     fread(&t, \textcolor{keyword}{sizeof} t, 1, f);
730     \textcolor{comment}{// then, the mpz part}
731     mpz\_inp\_raw(part\_g.get\_mpz\_t(), f);
732     \textcolor{comment}{// then, the vector size}
733     fread(&v\_size, \textcolor{keyword}{sizeof} v\_size, 1, f);
734     W.resize(v\_size);
735     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j=0;j<v\_size; j++)\{
736       fread(&int\_in, \textcolor{keyword}{sizeof} int\_in, 1, f);
737       W[j] = int\_in;
738     \}
739     \hyperlink{classmarked__graph__compressed_ae179a4737e6eab905c18a94d44ef64b7}{part\_graph}.insert(pair<\textcolor{keywordtype}{int}, pair< mpz\_class, vector< int > > >(t, pair<mpz\_class, vector<int>
       >(part\_g, W)));
740   \}
741 \}
\end{DoxyCode}
\mbox{\Hypertarget{classmarked__graph__compressed_a01c67fe4234738db6bb60459515c3ad8}\label{classmarked__graph__compressed_a01c67fe4234738db6bb60459515c3ad8}} 
\index{marked\+\_\+graph\+\_\+compressed@{marked\+\_\+graph\+\_\+compressed}!binary\+\_\+read@{binary\+\_\+read}}
\index{binary\+\_\+read@{binary\+\_\+read}!marked\+\_\+graph\+\_\+compressed@{marked\+\_\+graph\+\_\+compressed}}
\subsubsection{\texorpdfstring{binary\+\_\+read()}{binary\_read()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void marked\+\_\+graph\+\_\+compressed\+::binary\+\_\+read (\begin{DoxyParamCaption}\item[{string}]{s }\end{DoxyParamCaption})}

read the compressed data from a binary file 
\begin{DoxyParams}{Parameters}
{\em s} & string containing the name of the binary file \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
744                                                  \{
745   \hyperlink{classlogger_a9d29b49bd318a719a8e85b59eac54fe0}{logger::current\_depth}++;
746   \hyperlink{classmarked__graph__compressed_af58307bfadcaa4c3ca6dd594c2f9b3a9}{clear}(); \textcolor{comment}{// to make sure nothing is stored inside me before reading}
747   \hyperlink{classibitstream}{ibitstream} inp(s);
748 
749   \textcolor{comment}{// ==== read n, h, delta}
750   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} int\_in; \textcolor{comment}{// auxiliary input integer}
751   \hyperlink{classlogger_a710163deb17bc81f70d53d285b8ac9ac}{logger::add\_entry}(\textcolor{stringliteral}{"n"}, \textcolor{stringliteral}{""});
752   inp >> int\_in; 
753   \hyperlink{classmarked__graph__compressed_a8d841016ddb11cfd33748c8deb6277ba}{n} = int\_in; \textcolor{comment}{// I need to do this, since ibitstream::operator >> gets unsigned int& and the compile can
       not cast int& to unsigned int&}
754   \hyperlink{classlogger_a710163deb17bc81f70d53d285b8ac9ac}{logger::add\_entry}(\textcolor{stringliteral}{"h"}, \textcolor{stringliteral}{""});
755   inp >> int\_in;
756   \hyperlink{classmarked__graph__compressed_af6ff623407b673d08d0cab77b39c2193}{h} = int\_in;
757   \hyperlink{classlogger_a710163deb17bc81f70d53d285b8ac9ac}{logger::add\_entry}(\textcolor{stringliteral}{"delta"}, \textcolor{stringliteral}{""});
758   inp >> int\_in;
759   \hyperlink{classmarked__graph__compressed_a8b2aaac68e9332ddc78d88eb60b323a7}{delta} = int\_in;
760 
761   \textcolor{comment}{//fread(&n, sizeof n, 1, f);}
762   \textcolor{comment}{//fread(&h, sizeof h, 1, f);}
763   \textcolor{comment}{//fread(&delta, sizeof delta, 1, f);}
764 
765   \hyperlink{classlogger_a710163deb17bc81f70d53d285b8ac9ac}{logger::add\_entry}(\textcolor{stringliteral}{"type\_mark"}, \textcolor{stringliteral}{""});
766   \textcolor{comment}{// ===== read type\_mark}
767   \textcolor{comment}{// read number of types}
768   inp >> int\_in;
769   \textcolor{comment}{//fread(&int\_in, sizeof int\_in, 1, f);}
770   \hyperlink{classmarked__graph__compressed_a86b00223525703e973415cbc9c94da68}{type\_mark}.resize(int\_in);
771   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0;i<\hyperlink{classmarked__graph__compressed_a86b00223525703e973415cbc9c94da68}{type\_mark}.size();i++)\{
772     inp >> int\_in;
773     \hyperlink{classmarked__graph__compressed_a86b00223525703e973415cbc9c94da68}{type\_mark}[i] = int\_in;
774     \textcolor{comment}{//fread(&int\_in, sizeof int\_in, 1, f);}
775     \textcolor{comment}{//type\_mark[i] = int\_in;}
776   \}
777 
778   \hyperlink{classlogger_a710163deb17bc81f70d53d285b8ac9ac}{logger::add\_entry}(\textcolor{stringliteral}{"star vertices"}, \textcolor{stringliteral}{""});
779   \textcolor{comment}{// ==== read star\_vertices}
780   \textcolor{comment}{// first, read the frequency.}
781   \hyperlink{classmarked__graph__compressed_a7a4ced4586e2e353f9076bd447df5208}{star\_vertices}.first = vector<int>(2); \textcolor{comment}{// frequency,}
782   \textcolor{comment}{// we read its first index which is number of zeros, and the second is n - the first.}
783   inp >> int\_in;
784   \textcolor{comment}{//fread(&int\_in, sizeof int\_in, 1, f);}
785   \hyperlink{classmarked__graph__compressed_a7a4ced4586e2e353f9076bd447df5208}{star\_vertices}.first[0] = int\_in;
786   \hyperlink{classmarked__graph__compressed_a7a4ced4586e2e353f9076bd447df5208}{star\_vertices}.first[1] = \hyperlink{classmarked__graph__compressed_a8d841016ddb11cfd33748c8deb6277ba}{n} - int\_in;
787 
788   \textcolor{comment}{// the integer representation which is star\_vertices.second}
789   inp >> \hyperlink{classmarked__graph__compressed_a7a4ced4586e2e353f9076bd447df5208}{star\_vertices}.second;
790   \textcolor{comment}{//mpz\_inp\_raw(star\_vertices.second.get\_mpz\_t(), f);}
791 
792   \hyperlink{classlogger_a710163deb17bc81f70d53d285b8ac9ac}{logger::add\_entry}(\textcolor{stringliteral}{"star edges"}, \textcolor{stringliteral}{""});
793 
794   \textcolor{comment}{// ==== read star\_edges}
795 
796   \textcolor{comment}{//int log2n = 0; // the ceiling of log (n+1) in base 2 (which is equal to 1 + the floor of log\_2 n),
       which is the number of bits to encode vertices}
797   \textcolor{comment}{//int n\_copy = n;}
798   \textcolor{comment}{//while(n\_copy > 0)\{}
799   \textcolor{comment}{//n\_copy >>= 1;}
800   \textcolor{comment}{//log2n ++;}
801   \textcolor{comment}{//\}}
802   \textcolor{comment}{//bitset<8*sizeof(int)> B; // a bit stream with maximum length of int to store a vertex index}
803 
804   \textcolor{comment}{//string s;}
805   \textcolor{comment}{//stringstream ss;}
806   \textcolor{comment}{//int sp; // the index of the string s we are studying }
807 
808   \textcolor{comment}{// read the size of star\_edges}
809 
810   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} star\_edges\_size;
811   inp >> star\_edges\_size;
812   \textcolor{comment}{//cerr << " star edges size " << star\_edges\_size << endl;}
813   \textcolor{comment}{//fread(&star\_edges\_size, sizeof star\_edges\_size, 1, f);}
814 
815   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} x, xp; \textcolor{comment}{// edge marks}
816   \textcolor{keywordtype}{int} nu\_star\_vertices = \hyperlink{classmarked__graph__compressed_a7a4ced4586e2e353f9076bd447df5208}{star\_vertices}.first[1];
817   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} nb\_nsv = \hyperlink{bitstream_8cpp_a9dfce6f51e3febb3973aa3b16c2fecb4}{nu\_bits}(nu\_star\_vertices-1); \textcolor{comment}{// defined to chose compression method, see
       below}
818   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} nb\_nb\_nsv = \hyperlink{bitstream_8cpp_a9dfce6f51e3febb3973aa3b16c2fecb4}{nu\_bits}(nb\_nsv); \textcolor{comment}{// defined to chose compression method, see below}
819   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} diff\_threshold = nb\_nsv - nb\_nb\_nsv;
820   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} nb\_diff; \textcolor{comment}{// number of bits in diff}
821 
822 
823   vector<vector<int> > V; \textcolor{comment}{// the list of star edges corresponding to each mark pair}
824   V.resize(nu\_star\_vertices);
825 
826   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} n\_bits = \hyperlink{bitstream_8cpp_a9dfce6f51e3febb3973aa3b16c2fecb4}{nu\_bits}(\hyperlink{classmarked__graph__compressed_a8d841016ddb11cfd33748c8deb6277ba}{n}); \textcolor{comment}{// the number of bits in n, i.e. \(\backslash\)f$1 + \(\backslash\)lfloor \(\backslash\)log\_2 n
       \(\backslash\)rfloor\(\backslash\)f$}
827   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} diff; \textcolor{comment}{// to decode differences between star vertex indices in star edges}
828 
829   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0;i<star\_edges\_size;i++)\{
830 
831     inp >> x;
832     inp >> xp;
833     \textcolor{comment}{//cerr << " x  " << x << " xp " << xp << " i = " << i << endl; }
834     \textcolor{comment}{//fread(&x, sizeof x, 1, f);}
835     \textcolor{comment}{//fread(&xp, sizeof xp, 1, f);}
836   
837     \textcolor{comment}{//s = bit\_string\_read(f);}
838     \textcolor{comment}{//cerr << " read  x " << x << " xp " << xp << " s " << s << endl;}
839     \textcolor{comment}{//sp = 0; // starting from zero }
840     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j=0; j<nu\_star\_vertices; j++)\{ \textcolor{comment}{// }
841       V[j].clear(); \textcolor{comment}{// make it fresh}
842       \textcolor{comment}{//inp.bin\_inter\_decode(V[j], n\_bits); // use binary interpolative decoding}
843       \textcolor{comment}{//cerr << "  jth star vertex j = " << j<< endl; }
844       inp >> int\_in; \textcolor{comment}{// the number of star edges connected to jth star vertex}
845       \textcolor{comment}{//cerr << " number of star edges " << int\_in << endl;}
846       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} k=0; k<int\_in; k++)\{
847         \textcolor{comment}{// read diff}
848         \textcolor{comment}{//cerr << " k " << k << endl;}
849         \textcolor{keywordflow}{if} (inp.read\_bit())\{ \textcolor{comment}{// the flag bit is one, we have used the first method }
850           nb\_diff = inp.read\_bits(nb\_nb\_nsv);
851           diff = 0; \textcolor{comment}{// initialize}
852           \textcolor{keywordflow}{if} (nb\_diff > 1) \textcolor{comment}{// otherwise, reading zero bits is as iff diff = 0 (before adding the leading
       one) this is important when real diff is 1}
853             diff = inp.read\_bits(nb\_diff-1);
854           diff += (1<<(nb\_diff-1)); \textcolor{comment}{// bring the lading bit in diff back }
855         \}\textcolor{keywordflow}{else}\{ \textcolor{comment}{// use the second method to read diff}
856           diff = inp.read\_bits(nb\_nsv);
857         \}
858         \textcolor{comment}{//if (int\_in < 100)}
859         \textcolor{comment}{//  cerr << diff << " ";}
860         \textcolor{comment}{//cerr << " diff " << diff << endl;}
861         \textcolor{keywordflow}{if}(k==0)
862           V[j].push\_back(j+diff);
863         \textcolor{keywordflow}{else}
864           V[j].push\_back(V[j][k-1]+diff);
865       \}
866       \textcolor{comment}{//if (int\_in < 100)}
867       \textcolor{comment}{//  cerr << endl;}
868     \}
869 
870 
871     \hyperlink{classmarked__graph__compressed_a7df5779d313486644132bd816937f532}{star\_edges}.insert(pair< pair<int, int> , vector<vector<int> > > (pair<int, int>(x, xp), V));
872   \}
873 
874   \hyperlink{classlogger_a710163deb17bc81f70d53d285b8ac9ac}{logger::add\_entry}(\textcolor{stringliteral}{"vertex types"}, \textcolor{stringliteral}{""});
875   \textcolor{comment}{// ==== read vertex\_types}
876 
877   \textcolor{comment}{// read ver\_type\_list}
878   inp >> int\_in;
879   \textcolor{comment}{//fread(&int\_in, sizeof int\_in, 1, f); // size of ver\_type\_list}
880   \hyperlink{classmarked__graph__compressed_af2e3e55223d436628a02758dfae88493}{ver\_type\_list}.resize(int\_in);
881   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0; i<\hyperlink{classmarked__graph__compressed_af2e3e55223d436628a02758dfae88493}{ver\_type\_list}.size();i++)\{
882     inp >> int\_in;
883     \textcolor{comment}{//fread(&int\_in, sizeof int\_in, 1, f); // size of ver\_type\_list[i]}
884     \hyperlink{classmarked__graph__compressed_af2e3e55223d436628a02758dfae88493}{ver\_type\_list}[i].resize(int\_in);
885     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j=0;j<\hyperlink{classmarked__graph__compressed_af2e3e55223d436628a02758dfae88493}{ver\_type\_list}[i].size();j++)\{
886       \textcolor{comment}{//fread(&int\_in, sizeof int\_in, 1, f);}
887       inp >> int\_in;
888       \textcolor{keywordflow}{if} (j%3 == 0 and j > 0) \textcolor{comment}{// we know that the cont part is positive, so no need to add one during
       compression. So during compression, we subtract one to make it nonnegative}
889         int\_in ++;
890       \hyperlink{classmarked__graph__compressed_af2e3e55223d436628a02758dfae88493}{ver\_type\_list}[i][j] = int\_in;
891     \}
892   \}
893 
894   \textcolor{comment}{// ver\_types}
895   \textcolor{comment}{// ver\_types.first}
896   \textcolor{comment}{// ver\_types.first.size()}
897   inp >> int\_in;
898   \textcolor{comment}{//fread(&int\_in, sizeof int\_in, 1, f);}
899   \hyperlink{classmarked__graph__compressed_af446cc5e23c241a92b76642fd5ebc403}{ver\_types}.first.resize(int\_in);
900   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0;i<\hyperlink{classmarked__graph__compressed_af446cc5e23c241a92b76642fd5ebc403}{ver\_types}.first.size();i++)\{
901     \textcolor{comment}{//fread(&int\_in, sizeof int\_in, 1, f);}
902     inp >> int\_in;
903     \hyperlink{classmarked__graph__compressed_af446cc5e23c241a92b76642fd5ebc403}{ver\_types}.first[i] = int\_in;\textcolor{comment}{// = int\_in;}
904   \}
905   \textcolor{comment}{// ver\_types.second}
906   inp >> \hyperlink{classmarked__graph__compressed_af446cc5e23c241a92b76642fd5ebc403}{ver\_types}.second;
907   \textcolor{comment}{//mpz\_inp\_raw(ver\_types.second.get\_mpz\_t(), f);}
908 
909 
910   \hyperlink{classlogger_a710163deb17bc81f70d53d285b8ac9ac}{logger::add\_entry}(\textcolor{stringliteral}{"partition bipartite graphs"}, \textcolor{stringliteral}{""});
911   \textcolor{comment}{// === part bgraphs}
912   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} part\_bgraph\_size;
913   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} t, tp;
914   pair<int, int> type; 
915   mpz\_class part\_g;
916   inp >> part\_bgraph\_size;
917   \textcolor{comment}{//fread(&part\_bgraph\_size, sizeof part\_bgraph\_size, 1, f);}
918   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0;i<part\_bgraph\_size;i++)\{
919     \textcolor{comment}{// read t, t'}
920     inp >> t;
921     inp >> tp;
922     \textcolor{comment}{//fread(&t, sizeof t, 1, f);}
923     \textcolor{comment}{//fread(&tp, sizeof tp, 1, f);}
924     type = pair<int, int>(t, tp);
925     inp >> part\_g;
926     \textcolor{comment}{//mpz\_inp\_raw(part\_g.get\_mpz\_t(), f);}
927     \hyperlink{classmarked__graph__compressed_a7b3267063fba30b45eb21b3ba4e07536}{part\_bgraph}.insert(pair<pair<int, int>, mpz\_class> (type, part\_g));
928   \}
929 
930   \hyperlink{classlogger_a710163deb17bc81f70d53d285b8ac9ac}{logger::add\_entry}(\textcolor{stringliteral}{"partition graphs"}, \textcolor{stringliteral}{""});
931   \textcolor{comment}{// === part graphs}
932 
933   \textcolor{comment}{// first, the size}
934   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} part\_graph\_size;
935   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} v\_size;
936   vector<int> W; 
937   inp >> part\_graph\_size;
938   \textcolor{comment}{//fread(&part\_graph\_size, sizeof part\_graph\_size, 1, f);}
939   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0;i<part\_graph\_size; i++)\{
940     \textcolor{comment}{// first, the type}
941     inp >> t; 
942     \textcolor{comment}{//fread(&t, sizeof t, 1, f);}
943     \textcolor{comment}{// then, the mpz part}
944     inp >> part\_g;
945     \textcolor{comment}{//mpz\_inp\_raw(part\_g.get\_mpz\_t(), f);}
946     \textcolor{comment}{// then, the vector size}
947     inp >> v\_size;
948     \textcolor{comment}{//fread(&v\_size, sizeof v\_size, 1, f);}
949     W.resize(v\_size);
950     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j=0;j<v\_size; j++)\{
951       \textcolor{comment}{//fread(&int\_in, sizeof int\_in, 1, f);}
952       inp >> int\_in;
953       W[j] = int\_in; \textcolor{comment}{//= int\_in;}
954     \}
955     \hyperlink{classmarked__graph__compressed_ae179a4737e6eab905c18a94d44ef64b7}{part\_graph}.insert(pair<\textcolor{keywordtype}{int}, pair< mpz\_class, vector< int > > >(t, pair<mpz\_class, vector<int>
       >(part\_g, W)));
956   \}
957   inp.close();
958   \hyperlink{classlogger_a9d29b49bd318a719a8e85b59eac54fe0}{logger::current\_depth}--;
959 \}
\end{DoxyCode}
\mbox{\Hypertarget{classmarked__graph__compressed_ab9cdb7fc43badd58fb5202f74ffac723}\label{classmarked__graph__compressed_ab9cdb7fc43badd58fb5202f74ffac723}} 
\index{marked\+\_\+graph\+\_\+compressed@{marked\+\_\+graph\+\_\+compressed}!binary\+\_\+write@{binary\+\_\+write}}
\index{binary\+\_\+write@{binary\+\_\+write}!marked\+\_\+graph\+\_\+compressed@{marked\+\_\+graph\+\_\+compressed}}
\subsubsection{\texorpdfstring{binary\+\_\+write()}{binary\_write()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void marked\+\_\+graph\+\_\+compressed\+::binary\+\_\+write (\begin{DoxyParamCaption}\item[{F\+I\+LE $\ast$}]{f }\end{DoxyParamCaption})}



writes the compressed data to a binary file 


\begin{DoxyParams}{Parameters}
{\em f} & a {\ttfamily F\+I\+L\+E$\ast$} object which is the address of the binary file to write \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
20                                                  \{
21 
22   vector<pair<string, int> > space\_log; \textcolor{comment}{// stores the number of bits used to store each category. The
       string part is description of the category, and the int part is the number of bits of output used to express that
       part.}
23 
24   \textcolor{keywordtype}{int} output\_bits; \textcolor{comment}{// the number of bits in the output corresponding to the current category under
       investigation, to be zeroed at each step.}
25 
26   \hyperlink{classlogger_a9d29b49bd318a719a8e85b59eac54fe0}{logger::current\_depth}++;
27   \textcolor{comment}{// ==== write n, h, delta}
28   output\_bits = 0;
29   \hyperlink{classlogger_a710163deb17bc81f70d53d285b8ac9ac}{logger::add\_entry}(\textcolor{stringliteral}{"n"}, \textcolor{stringliteral}{""});
30   fwrite(&\hyperlink{classmarked__graph__compressed_a8d841016ddb11cfd33748c8deb6277ba}{n}, \textcolor{keyword}{sizeof} \hyperlink{classmarked__graph__compressed_a8d841016ddb11cfd33748c8deb6277ba}{n}, 1, f);
31   output\_bits += \textcolor{keyword}{sizeof} \hyperlink{classmarked__graph__compressed_a8d841016ddb11cfd33748c8deb6277ba}{n};
32 
33   \hyperlink{classlogger_a710163deb17bc81f70d53d285b8ac9ac}{logger::add\_entry}(\textcolor{stringliteral}{"h"}, \textcolor{stringliteral}{""});
34   fwrite(&\hyperlink{classmarked__graph__compressed_af6ff623407b673d08d0cab77b39c2193}{h}, \textcolor{keyword}{sizeof} \hyperlink{classmarked__graph__compressed_af6ff623407b673d08d0cab77b39c2193}{h}, 1, f);
35   output\_bits += \textcolor{keyword}{sizeof} \hyperlink{classmarked__graph__compressed_af6ff623407b673d08d0cab77b39c2193}{h};
36 
37   \hyperlink{classlogger_a710163deb17bc81f70d53d285b8ac9ac}{logger::add\_entry}(\textcolor{stringliteral}{"delta"}, \textcolor{stringliteral}{""});
38   fwrite(&\hyperlink{classmarked__graph__compressed_a8b2aaac68e9332ddc78d88eb60b323a7}{delta}, \textcolor{keyword}{sizeof} \hyperlink{classmarked__graph__compressed_a8b2aaac68e9332ddc78d88eb60b323a7}{delta}, 1, f);
39   output\_bits += \textcolor{keyword}{sizeof} \hyperlink{classmarked__graph__compressed_a8b2aaac68e9332ddc78d88eb60b323a7}{delta};
40 
41   space\_log.push\_back(pair<string, int> (\textcolor{stringliteral}{"n, h, delta"}, output\_bits));
42 
43   \hyperlink{classlogger_a710163deb17bc81f70d53d285b8ac9ac}{logger::add\_entry}(\textcolor{stringliteral}{"type\_mark"}, \textcolor{stringliteral}{""});
44   output\_bits = 0;
45 
46   \textcolor{keywordtype}{int} int\_out; \textcolor{comment}{// auxiliary variable, an integer value to be written to output}
47   \textcolor{comment}{// ==== write type\_mark}
48   \textcolor{comment}{// first, the number of types}
49   int\_out = \hyperlink{classmarked__graph__compressed_a86b00223525703e973415cbc9c94da68}{type\_mark}.size();
50   fwrite(&int\_out, \textcolor{keyword}{sizeof} int\_out, 1, f);
51   output\_bits += \textcolor{keyword}{sizeof} int\_out;
52   \textcolor{comment}{// then, marks one by one}
53   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0;i<\hyperlink{classmarked__graph__compressed_a86b00223525703e973415cbc9c94da68}{type\_mark}.size();i++)\{
54     int\_out = \hyperlink{classmarked__graph__compressed_a86b00223525703e973415cbc9c94da68}{type\_mark}[i];
55     fwrite(&int\_out, \textcolor{keyword}{sizeof} int\_out, 1, f);
56     output\_bits += \textcolor{keyword}{sizeof} int\_out;
57   \}
58 
59   space\_log.push\_back(pair<string, int>(\textcolor{stringliteral}{"type mark"}, output\_bits));
60 
61   \hyperlink{classlogger_a710163deb17bc81f70d53d285b8ac9ac}{logger::add\_entry}(\textcolor{stringliteral}{"star\_vertices"}, \textcolor{stringliteral}{""});
62   output\_bits = 0;
63   \textcolor{comment}{// ==== write star vertices}
64   \textcolor{comment}{// first, write the frequency, note that star\_vertices.first is a vector of size 2 with the first entry
       being the number of zeros, and the second one the number of ones, so it enough to write only one of them}
65   int\_out = \hyperlink{classmarked__graph__compressed_a7a4ced4586e2e353f9076bd447df5208}{star\_vertices}.first[0];
66   fwrite(&int\_out, \textcolor{keyword}{sizeof} int\_out, 1, f);
67   output\_bits += \textcolor{keyword}{sizeof} int\_out;
68 
69   \textcolor{comment}{// then, we write the integer representation star\_vertices.second}
70   output\_bits +=  mpz\_out\_raw(f, \hyperlink{classmarked__graph__compressed_a7a4ced4586e2e353f9076bd447df5208}{star\_vertices}.second.get\_mpz\_t()); \textcolor{comment}{// mpz\_out\_raw returns the
       number of bytes written to the output}
71 
72   space\_log.push\_back(pair<string, int> (\textcolor{stringliteral}{"star vertices"}, output\_bits));
73 
74   \hyperlink{classlogger_a710163deb17bc81f70d53d285b8ac9ac}{logger::add\_entry}(\textcolor{stringliteral}{"star\_edges"}, \textcolor{stringliteral}{""});
75   \textcolor{comment}{// ==== write star edges}
76   output\_bits = 0;
77   \textcolor{keywordtype}{int} log2n = 0; \textcolor{comment}{// the ceiling of log (n+1) in base 2 (which is equal to 1 + the floor of log\_2 n), which
       is the number of bits to encode vertices}
78   \textcolor{keywordtype}{int} n\_copy = \hyperlink{classmarked__graph__compressed_a8d841016ddb11cfd33748c8deb6277ba}{n};
79   \textcolor{keywordflow}{while}(n\_copy > 0)\{
80     n\_copy >>= 1;
81     log2n ++;
82   \}
83   \textcolor{comment}{//cerr << " log2n " << log2n << endl;}
84   bitset<8*sizeof(int)> B; \textcolor{comment}{// a bit stream with maximum length of int to store a vertex index}
85 
86   map<pair<int, int>, vector<vector<int> > >::iterator it;
87   \textcolor{keywordtype}{int} x, xp;
88   \textcolor{keywordtype}{string} s; \textcolor{comment}{// the bit stream}
89 
90   \textcolor{comment}{// first, write the size of star\_edges so that the decoder knows how many blocks are coming}
91   int\_out = \hyperlink{classmarked__graph__compressed_a7df5779d313486644132bd816937f532}{star\_edges}.size();
92   fwrite(&int\_out, \textcolor{keyword}{sizeof} int\_out, 1, f);
93   output\_bits += \textcolor{keyword}{sizeof} int\_out;
94 
95   \textcolor{keywordtype}{int} nu\_star\_edges = 0; \textcolor{comment}{// number of star edges }
96   \textcolor{keywordflow}{for} (it = \hyperlink{classmarked__graph__compressed_a7df5779d313486644132bd816937f532}{star\_edges}.begin(); it!= \hyperlink{classmarked__graph__compressed_a7df5779d313486644132bd816937f532}{star\_edges}.end(); it++)\{
97     x = it->first.first;
98     xp = it->first.second;
99     \textcolor{comment}{//write x and xp}
100     fwrite(&x, \textcolor{keyword}{sizeof} x, 1, f);
101     fwrite(&xp, \textcolor{keyword}{sizeof} xp, 1, f);
102     output\_bits += \textcolor{keyword}{sizeof} x;
103     output\_bits += \textcolor{keyword}{sizeof} xp;
104     s = \textcolor{stringliteral}{""};
105     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0;i<it->second.size();i++)\{
106       \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} j=0;j<it->second[i].size();j++)\{
107         s += \textcolor{stringliteral}{"1"};
108         B = it->second[i][j]; \textcolor{comment}{// convert the index of the other endpoint to binary}
109         s += B.to\_string().substr(8*\textcolor{keyword}{sizeof}(\textcolor{keywordtype}{int}) - log2n, log2n); \textcolor{comment}{// take only log2n many bits of the
       representation (and this should be taken from the least significant bits)}
110         nu\_star\_edges ++;
111       \}
112       s += \textcolor{stringliteral}{"0"}; \textcolor{comment}{// to indicate that the neighbor list of this vertex is over now}
113     \}
114     \textcolor{comment}{//cerr << " write  x " << x << " xp " << xp << " s " << s << endl;}
115     \textcolor{comment}{//for (int i=0;i<it->second.size();i++)\{}
116     \textcolor{comment}{//  for (int j=0;j<it->second[i].size();j++)\{}
117     \textcolor{comment}{//    cerr << " , " << it->second[i][j];}
118     \textcolor{comment}{//  \}}
119     \textcolor{comment}{//  cerr << endl;}
120     \textcolor{comment}{//\}}
121     output\_bits += \hyperlink{compression__helper_8cpp_a9a2fbdf1fe0e38f631e7e242a819883b}{bit\_string\_write}(f, s); \textcolor{comment}{// write this bitstream to the output}
122   \}
123 
124   space\_log.push\_back(pair<string, int> (\textcolor{stringliteral}{"star edges"}, output\_bits));
125 
126 
127   \hyperlink{classlogger_a710163deb17bc81f70d53d285b8ac9ac}{logger::add\_entry}(\textcolor{stringliteral}{"vertex types"}, \textcolor{stringliteral}{""});
128   output\_bits = 0;
129 
130   \textcolor{comment}{// ==== write vertex types}
131 
132   \textcolor{comment}{// first, we need vertex types list (ver\_type\_list)}
133   \textcolor{comment}{// size of ver\_type\_list}
134   int\_out = \hyperlink{classmarked__graph__compressed_af2e3e55223d436628a02758dfae88493}{ver\_type\_list}.size();
135   fwrite(&int\_out, \textcolor{keyword}{sizeof} int\_out, 1, f);
136   output\_bits += \textcolor{keyword}{sizeof} int\_out;
137 
138   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0;i<\hyperlink{classmarked__graph__compressed_af2e3e55223d436628a02758dfae88493}{ver\_type\_list}.size();i++)\{
139     int\_out = \hyperlink{classmarked__graph__compressed_af2e3e55223d436628a02758dfae88493}{ver\_type\_list}[i].size();
140     fwrite(&int\_out, \textcolor{keyword}{sizeof} int\_out, 1, f);
141     output\_bits += \textcolor{keyword}{sizeof} int\_out;
142 
143     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j=0;j<\hyperlink{classmarked__graph__compressed_af2e3e55223d436628a02758dfae88493}{ver\_type\_list}[i].size();j++)\{
144       int\_out = \hyperlink{classmarked__graph__compressed_af2e3e55223d436628a02758dfae88493}{ver\_type\_list}[i][j];
145       fwrite(&int\_out, \textcolor{keyword}{sizeof} int\_out, 1, f);
146       output\_bits += \textcolor{keyword}{sizeof} int\_out;
147     \}
148   \}
149   space\_log.push\_back(pair<string, int>(\textcolor{stringliteral}{"vertex type list"}, output\_bits));
150   output\_bits = 0;
151   
152   \textcolor{comment}{// then, write ver\_types}
153 
154   \textcolor{comment}{// ver\_types.first}
155   \textcolor{comment}{// ver\_types.first.size():}
156   int\_out = \hyperlink{classmarked__graph__compressed_af446cc5e23c241a92b76642fd5ebc403}{ver\_types}.first.size();
157   fwrite(&int\_out, \textcolor{keyword}{sizeof} int\_out, 1, f);
158   output\_bits += \textcolor{keyword}{sizeof} int\_out;
159 
160   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i =0;i<\hyperlink{classmarked__graph__compressed_af446cc5e23c241a92b76642fd5ebc403}{ver\_types}.first.size(); i++)\{
161     int\_out = \hyperlink{classmarked__graph__compressed_af446cc5e23c241a92b76642fd5ebc403}{ver\_types}.first[i];
162     fwrite(&int\_out, \textcolor{keyword}{sizeof} int\_out, 1, f);
163     output\_bits += \textcolor{keyword}{sizeof} int\_out;
164   \}
165   \textcolor{comment}{// ver\_types.second}
166   output\_bits += mpz\_out\_raw(f, \hyperlink{classmarked__graph__compressed_af446cc5e23c241a92b76642fd5ebc403}{ver\_types}.second.get\_mpz\_t());
167 
168   space\_log.push\_back(pair<string, int> (\textcolor{stringliteral}{"vertex types"}, output\_bits));
169 
170   \hyperlink{classlogger_a710163deb17bc81f70d53d285b8ac9ac}{logger::add\_entry}(\textcolor{stringliteral}{"partition bipartite graphs"}, \textcolor{stringliteral}{""});
171   
172 
173   \textcolor{comment}{// ==== part bgraphs}
174   output\_bits = 0;
175 
176   \textcolor{comment}{// part\_bgraphs.size}
177   int\_out = \hyperlink{classmarked__graph__compressed_a7b3267063fba30b45eb21b3ba4e07536}{part\_bgraph}.size();
178   fwrite(&int\_out, \textcolor{keyword}{sizeof} int\_out, 1, f);
179   output\_bits += \textcolor{keyword}{sizeof} int\_out;
180 
181   map<pair<int, int>, mpz\_class>::iterator it2;
182   \textcolor{keywordflow}{if} (\hyperlink{classlogger_a26812b5ba03f130e8dae3446d5fc032f}{logger::stat})\{
183     *\hyperlink{classlogger_a7db37821f875f2ba3540980b355779f5}{logger::stat\_stream} << \textcolor{stringliteral}{" ==== statistics ==== "} << endl;
184     *\hyperlink{classlogger_a7db37821f875f2ba3540980b355779f5}{logger::stat\_stream} << \textcolor{stringliteral}{" n:                "} << \hyperlink{classmarked__graph__compressed_a8d841016ddb11cfd33748c8deb6277ba}{n} << endl;
185     *\hyperlink{classlogger_a7db37821f875f2ba3540980b355779f5}{logger::stat\_stream} << \textcolor{stringliteral}{" h:                "} << \hyperlink{classmarked__graph__compressed_af6ff623407b673d08d0cab77b39c2193}{h} << endl;
186     *\hyperlink{classlogger_a7db37821f875f2ba3540980b355779f5}{logger::stat\_stream} << \textcolor{stringliteral}{" delta:            "} << \hyperlink{classmarked__graph__compressed_a8b2aaac68e9332ddc78d88eb60b323a7}{delta} << endl;
187     *\hyperlink{classlogger_a7db37821f875f2ba3540980b355779f5}{logger::stat\_stream} << \textcolor{stringliteral}{" No. types         "} << 
      \hyperlink{classmarked__graph__compressed_a86b00223525703e973415cbc9c94da68}{type\_mark}.size() << endl;
188     *\hyperlink{classlogger_a7db37821f875f2ba3540980b355779f5}{logger::stat\_stream} << \textcolor{stringliteral}{" No. * vertices    "} << \hyperlink{classmarked__graph__compressed_a8d841016ddb11cfd33748c8deb6277ba}{n} - 
      \hyperlink{classmarked__graph__compressed_a7a4ced4586e2e353f9076bd447df5208}{star\_vertices}.first[0] << endl;
189     *\hyperlink{classlogger_a7db37821f875f2ba3540980b355779f5}{logger::stat\_stream} << \textcolor{stringliteral}{" No. * edges       "} << nu\_star\_edges << endl;
190     *\hyperlink{classlogger_a7db37821f875f2ba3540980b355779f5}{logger::stat\_stream} << \textcolor{stringliteral}{" No. part bgraphs  "} << 
      \hyperlink{classmarked__graph__compressed_a7b3267063fba30b45eb21b3ba4e07536}{part\_bgraph}.size() << endl;
191     *\hyperlink{classlogger_a7db37821f875f2ba3540980b355779f5}{logger::stat\_stream} << \textcolor{stringliteral}{" No. part graphs   "} << 
      \hyperlink{classmarked__graph__compressed_ae179a4737e6eab905c18a94d44ef64b7}{part\_graph}.size() << endl;
192   \}
193 
194   \textcolor{keywordflow}{for} (it2 = \hyperlink{classmarked__graph__compressed_a7b3267063fba30b45eb21b3ba4e07536}{part\_bgraph}.begin(); it2 != \hyperlink{classmarked__graph__compressed_a7b3267063fba30b45eb21b3ba4e07536}{part\_bgraph}.end(); it2++)\{
195     \textcolor{comment}{// first, write t, t'}
196     int\_out = it2->first.first;
197     fwrite(&int\_out, \textcolor{keyword}{sizeof} int\_out, 1, f);
198     output\_bits += \textcolor{keyword}{sizeof} int\_out;
199     int\_out = it2->first.second;
200     fwrite(&int\_out, \textcolor{keyword}{sizeof} int\_out, 1, f);
201     output\_bits += \textcolor{keyword}{sizeof} int\_out;
202     \textcolor{comment}{// then, the compressed integer}
203     output\_bits += mpz\_out\_raw(f, it2->second.get\_mpz\_t());
204   \}
205 
206   space\_log.push\_back(pair<string, int> (\textcolor{stringliteral}{"partition bipartite graphs"}, output\_bits));
207 
208   \hyperlink{classlogger_a710163deb17bc81f70d53d285b8ac9ac}{logger::add\_entry}(\textcolor{stringliteral}{"partition graphs"}, \textcolor{stringliteral}{""});
209   output\_bits = 0;
210   \textcolor{comment}{// === part graphs}
211 
212   \textcolor{comment}{// part\_graph.size}
213   int\_out = \hyperlink{classmarked__graph__compressed_ae179a4737e6eab905c18a94d44ef64b7}{part\_graph}.size();
214   fwrite(&int\_out, \textcolor{keyword}{sizeof} int\_out, 1, f);
215   output\_bits += \textcolor{keyword}{sizeof} int\_out;
216 
217   map< int, pair< mpz\_class, vector< int > > >::iterator it3;
218   \textcolor{keywordflow}{for} (it3 = \hyperlink{classmarked__graph__compressed_ae179a4737e6eab905c18a94d44ef64b7}{part\_graph}.begin(); it3 != \hyperlink{classmarked__graph__compressed_ae179a4737e6eab905c18a94d44ef64b7}{part\_graph}.end(); it3++)\{
219     int\_out = it3->first; \textcolor{comment}{// the type}
220     fwrite(&int\_out, \textcolor{keyword}{sizeof} int\_out, 1, f);
221     output\_bits += \textcolor{keyword}{sizeof} int\_out;
222 
223     \textcolor{comment}{// the mpz part}
224     output\_bits += mpz\_out\_raw(f, it3->second.first.get\_mpz\_t());
225     \textcolor{comment}{// the vector part}
226     \textcolor{comment}{// first its size}
227     int\_out = it3->second.second.size();
228     fwrite(&int\_out, \textcolor{keyword}{sizeof} int\_out, 1, f);
229     output\_bits += \textcolor{keyword}{sizeof} int\_out;
230     \textcolor{comment}{// then element by element}
231     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} j=0;j<it3->second.second.size();j++)\{
232       int\_out = it3->second.second[j];
233       fwrite(&int\_out, \textcolor{keyword}{sizeof} int\_out, 1, f);
234       output\_bits += \textcolor{keyword}{sizeof} int\_out;
235     \}
236   \}
237   space\_log.push\_back(pair<string, int>(\textcolor{stringliteral}{"partition graphs"}, output\_bits));
238 
239 
240   \textcolor{keywordflow}{if} (\hyperlink{classlogger_a26812b5ba03f130e8dae3446d5fc032f}{logger::stat})\{
241     *\hyperlink{classlogger_a7db37821f875f2ba3540980b355779f5}{logger::stat\_stream} << endl << endl;
242     *\hyperlink{classlogger_a7db37821f875f2ba3540980b355779f5}{logger::stat\_stream} << \textcolor{stringliteral}{" Number of bytes used for each part "} << endl;
243     *\hyperlink{classlogger_a7db37821f875f2ba3540980b355779f5}{logger::stat\_stream} << \textcolor{stringliteral}{" ---------------------------------- "} << endl << endl;
244 
245     \textcolor{keywordtype}{int} total\_bytes = 0;
246     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0; i < space\_log.size(); i++)
247       total\_bytes += space\_log[i].second;
248 
249     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0; i < space\_log.size(); i++)\{
250       *\hyperlink{classlogger_a7db37821f875f2ba3540980b355779f5}{logger::stat\_stream} << space\_log[i].first << \textcolor{stringliteral}{" -> "}  << space\_log[i].second << \textcolor{stringliteral}{"
       ( "} << float(100) * float(space\_log[i].second) / float(total\_bytes) << \textcolor{stringliteral}{" % "} << endl;
251     \}
252 
253     *\hyperlink{classlogger_a7db37821f875f2ba3540980b355779f5}{logger::stat\_stream} << \textcolor{stringliteral}{" Total number of bytes wrote to the output = "} << 
      total\_bytes << endl;
254   \}
255   \hyperlink{classlogger_a9d29b49bd318a719a8e85b59eac54fe0}{logger::current\_depth}--;
256 \}
\end{DoxyCode}
\mbox{\Hypertarget{classmarked__graph__compressed_a13ab09e4b399f179ec91746ae2b8b38c}\label{classmarked__graph__compressed_a13ab09e4b399f179ec91746ae2b8b38c}} 
\index{marked\+\_\+graph\+\_\+compressed@{marked\+\_\+graph\+\_\+compressed}!binary\+\_\+write@{binary\+\_\+write}}
\index{binary\+\_\+write@{binary\+\_\+write}!marked\+\_\+graph\+\_\+compressed@{marked\+\_\+graph\+\_\+compressed}}
\subsubsection{\texorpdfstring{binary\+\_\+write()}{binary\_write()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void marked\+\_\+graph\+\_\+compressed\+::binary\+\_\+write (\begin{DoxyParamCaption}\item[{string}]{s }\end{DoxyParamCaption})}

writes the compressed data to a binary file 
\begin{DoxyParams}{Parameters}
{\em s} & string containing the name of the binary file \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
260                                                   \{
261   
262   \hyperlink{classobitstream}{obitstream} oup(s);
263 
264   vector<pair<string, int> > space\_log; \textcolor{comment}{// stores the number of bits used to store each category. The
       string part is description of the category, and the int part is the number of bits of output used to express that
       part.}
265 
266   \textcolor{comment}{//int output\_bits; // the number of bits in the output corresponding to the current category under
       investigation, to be zeroed at each step.}
267   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} chunks = 0; \textcolor{comment}{// number of chunks written to the output. Each chunk is sizeof(unsigned int) =
       32 bits long}
268   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} chunks\_new =0; \textcolor{comment}{// to take the difference in each step}
269 
270   \hyperlink{classlogger_a9d29b49bd318a719a8e85b59eac54fe0}{logger::current\_depth}++;
271   \textcolor{comment}{// ==== write n, h, delta}
272   \textcolor{comment}{//output\_bits = 0;}
273   \hyperlink{classlogger_a710163deb17bc81f70d53d285b8ac9ac}{logger::add\_entry}(\textcolor{stringliteral}{"n"}, \textcolor{stringliteral}{""});
274   oup << \hyperlink{classmarked__graph__compressed_a8d841016ddb11cfd33748c8deb6277ba}{n}; \textcolor{comment}{//fwrite(&n, sizeof n, 1, f);}
275   \textcolor{comment}{//output\_bits += sizeof n;}
276 
277   \hyperlink{classlogger_a710163deb17bc81f70d53d285b8ac9ac}{logger::add\_entry}(\textcolor{stringliteral}{"h"}, \textcolor{stringliteral}{""});
278   oup << \hyperlink{classmarked__graph__compressed_af6ff623407b673d08d0cab77b39c2193}{h}; \textcolor{comment}{//fwrite(&h, sizeof h, 1, f);}
279   \textcolor{comment}{//output\_bits += sizeof h;}
280 
281   \hyperlink{classlogger_a710163deb17bc81f70d53d285b8ac9ac}{logger::add\_entry}(\textcolor{stringliteral}{"delta"}, \textcolor{stringliteral}{""});
282   oup << \hyperlink{classmarked__graph__compressed_a8b2aaac68e9332ddc78d88eb60b323a7}{delta}; \textcolor{comment}{//fwrite(&delta, sizeof delta, 1, f);}
283   \textcolor{comment}{//output\_bits += sizeof delta;}
284 
285   chunks\_new = oup.chunks();
286   space\_log.push\_back(pair<string, int> (\textcolor{stringliteral}{"n, h, delta"}, chunks\_new - chunks));
287   chunks = chunks\_new;
288 
289   \hyperlink{classlogger_a710163deb17bc81f70d53d285b8ac9ac}{logger::add\_entry}(\textcolor{stringliteral}{"type\_mark"}, \textcolor{stringliteral}{""});
290   \textcolor{comment}{//output\_bits = 0;}
291 
292   \textcolor{keywordtype}{int} int\_out; \textcolor{comment}{// auxiliary variable, an integer value to be written to output}
293   \textcolor{comment}{// ==== write type\_mark}
294   \textcolor{comment}{// first, the number of types}
295   oup <<  \hyperlink{classmarked__graph__compressed_a86b00223525703e973415cbc9c94da68}{type\_mark}.size();
296   \textcolor{comment}{//fwrite(&int\_out, sizeof int\_out, 1, f);}
297   \textcolor{comment}{//output\_bits += sizeof int\_out;}
298   \textcolor{comment}{// then, marks one by one}
299   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0;i<\hyperlink{classmarked__graph__compressed_a86b00223525703e973415cbc9c94da68}{type\_mark}.size();i++)\{
300     oup <<  \hyperlink{classmarked__graph__compressed_a86b00223525703e973415cbc9c94da68}{type\_mark}[i];
301     \textcolor{comment}{//fwrite(&int\_out, sizeof int\_out, 1, f);}
302     \textcolor{comment}{//output\_bits += sizeof int\_out;}
303   \}
304 
305   chunks\_new = oup.chunks();
306   space\_log.push\_back(pair<string, int>(\textcolor{stringliteral}{"type mark"}, chunks\_new - chunks));
307   chunks = chunks\_new;
308 
309   \hyperlink{classlogger_a710163deb17bc81f70d53d285b8ac9ac}{logger::add\_entry}(\textcolor{stringliteral}{"star\_vertices"}, \textcolor{stringliteral}{""});
310   \textcolor{comment}{//output\_bits = 0;}
311   \textcolor{comment}{// ==== write star vertices}
312   \textcolor{comment}{// first, write the frequency, note that star\_vertices.first is a vector of size 2 with the first entry
       being the number of zeros, and the second one the number of ones, so it enough to write only one of them}
313   oup << \hyperlink{classmarked__graph__compressed_a7a4ced4586e2e353f9076bd447df5208}{star\_vertices}.first[0];
314   \textcolor{comment}{//fwrite(&int\_out, sizeof int\_out, 1, f);}
315   \textcolor{comment}{//output\_bits += sizeof int\_out;}
316 
317   \textcolor{comment}{// then, we write the integer representation star\_vertices.second}
318   oup << \hyperlink{classmarked__graph__compressed_a7a4ced4586e2e353f9076bd447df5208}{star\_vertices}.second;
319   \textcolor{comment}{//output\_bits +=  mpz\_out\_raw(f, star\_vertices.second.get\_mpz\_t()); // mpz\_out\_raw returns the number of
       bytes written to the output}
320 
321   chunks\_new = oup.chunks();
322   space\_log.push\_back(pair<string, int> (\textcolor{stringliteral}{"star vertices"}, chunks\_new - chunks));
323   chunks = oup.chunks();
324 
325   \hyperlink{classlogger_a710163deb17bc81f70d53d285b8ac9ac}{logger::add\_entry}(\textcolor{stringliteral}{"star\_edges"}, \textcolor{stringliteral}{""});
326   \textcolor{comment}{// ==== write star edges}
327   \textcolor{comment}{//output\_bits = 0;}
328   \textcolor{comment}{//int log2n = 0; // the ceiling of log (n+1) in base 2 (which is equal to 1 + the floor of log\_2 n),
       which is the number of bits to encode vertices}
329   \textcolor{comment}{//int n\_copy = n;}
330   \textcolor{comment}{//while(n\_copy > 0)\{}
331   \textcolor{comment}{//n\_copy >>= 1;}
332   \textcolor{comment}{//log2n ++;}
333   \textcolor{comment}{//\}}
334   \textcolor{comment}{//cerr << " log2n " << log2n << endl;}
335   \textcolor{comment}{//bitset<8*sizeof(int)> B; // a bit stream with maximum length of int to store a vertex index}
336 
337   map<pair<int, int>, vector<vector<int> > >::iterator it;
338   \textcolor{keywordtype}{int} x, xp;
339   \textcolor{comment}{//string s; // the bit stream}
340 
341   \textcolor{comment}{// first, write the size of star\_edges so that the decoder knows how many blocks are coming}
342   oup << \hyperlink{classmarked__graph__compressed_a7df5779d313486644132bd816937f532}{star\_edges}.size();
343   \textcolor{comment}{//cerr << " star edges size " << star\_edges.size() << endl;}
344   \textcolor{comment}{//fwrite(&int\_out, sizeof int\_out, 1, f);}
345   \textcolor{comment}{//output\_bits += sizeof int\_out;}
346 
347   \textcolor{keywordtype}{int} nu\_star\_edges = 0; \textcolor{comment}{// number of star edges}
348   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} n\_bits = \hyperlink{bitstream_8cpp_a9dfce6f51e3febb3973aa3b16c2fecb4}{nu\_bits}(n); \textcolor{comment}{// the number of bits in n, i.e. \(\backslash\)f$1 + \(\backslash\)lfloor \(\backslash\)log\_2 n
       \(\backslash\)rfloor\(\backslash\)f$}
349   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} diff; \textcolor{comment}{// the difference for differential coding}
350   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} nu\_star\_vertices = n - \hyperlink{classmarked__graph__compressed_a7a4ced4586e2e353f9076bd447df5208}{star\_vertices}.first[0]; \textcolor{comment}{// number of star vertices}
351   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} nb\_nsv = \hyperlink{bitstream_8cpp_a9dfce6f51e3febb3973aa3b16c2fecb4}{nu\_bits}(nu\_star\_vertices-1); \textcolor{comment}{// defined to chose compression method, see
       below }
352   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} nb\_nb\_nsv = \hyperlink{bitstream_8cpp_a9dfce6f51e3febb3973aa3b16c2fecb4}{nu\_bits}(nb\_nsv); \textcolor{comment}{// defined to chose compression method, see below }
353   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} diff\_threshold = nb\_nsv - nb\_nb\_nsv;
354   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} nb\_diff; \textcolor{comment}{// number of bits in diff}
355 
356   map<int, int> deg\_map;
357 
358   \textcolor{keywordflow}{if} (\hyperlink{classlogger_a26812b5ba03f130e8dae3446d5fc032f}{logger::stat})\{
359     *\hyperlink{classlogger_a7db37821f875f2ba3540980b355779f5}{logger::stat\_stream} << \textcolor{stringliteral}{" * degree stat: "} << endl;
360     *\hyperlink{classlogger_a7db37821f875f2ba3540980b355779f5}{logger::stat\_stream} << \textcolor{stringliteral}{" -------------- "} << endl;
361   \}
362 
363   \textcolor{keywordflow}{for} (it = \hyperlink{classmarked__graph__compressed_a7df5779d313486644132bd816937f532}{star\_edges}.begin(); it!= \hyperlink{classmarked__graph__compressed_a7df5779d313486644132bd816937f532}{star\_edges}.end(); it++)\{
364 
365     x = it->first.first;
366     xp = it->first.second;
367     \textcolor{comment}{//cerr << " x " << x << " xp " << xp << endl;}
368     \textcolor{comment}{//write x and xp}
369 
370     oup << x;
371     oup << xp;
372 
373     deg\_map.clear();
374 
375     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0;i<it->second.size();i++)\{
376       \textcolor{comment}{//cerr << " star vertex " << i << endl;}
377       \textcolor{comment}{//oup.bin\_inter\_code(it->second[i], n\_bits);}
378       oup << it->second[i].size(); \textcolor{comment}{// how many star edges are going next}
379       deg\_map[it->second[i].size()] ++;
380       \textcolor{comment}{//cout << " i " << i << endl;}
381       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j=0;j<it->second[i].size();j++)\{
382         
383         \textcolor{comment}{//cout << " j " << j << " -> " << it->second[i][j] << endl;}
384         \textcolor{keywordflow}{if} (j==0)
385           diff = it->second[i][j] - i;
386         \textcolor{keywordflow}{else}
387           diff = it->second[i][j] - it->second[i][j-1];
388         \textcolor{comment}{//if (it->second[i].size() < 100)}
389         \textcolor{comment}{//  cerr << diff << " ";}
390         \textcolor{comment}{//cerr << " diff " << diff << endl;}
391         \textcolor{comment}{// diff is bounded by the number of star vertices}
392         \textcolor{comment}{// we can either encode diff by a modification of Elias delta, using the extra assumption that 1 <=
       diff <= number of star vertices - 1}
393         \textcolor{comment}{// number of star vertices = n - star\_vertices.first[0] lets call it nu\_star\_vertices defined above
       before the loop}
394         \textcolor{comment}{// with this extra assumption in Elias delta, we do not use the unary part of the code and store
       nu\_bits(diff) }
395         \textcolor{comment}{// using nu\_bits(nu\_bits(nu\_star\_vertices-1))}
396         \textcolor{comment}{// if we chose this method of compression, we use nu\_bits(nu\_bits(nu\_star\_vertices-1)) +
       nu\_bits(diff)}
397         \textcolor{comment}{// if we only use diff <= nu\_star\_vertices - 1, we spend nu\_bits(nu\_star\_vertices-1) bits}
398         \textcolor{comment}{// so we should spend the first method iff we have nu\_bits(nu\_bits(nu\_star\_vertices-1)) +
       nu\_bits(diff) < nu\_bits(nu\_star\_vertices-1)}
399         \textcolor{comment}{// or equivalently if nu\_bits(diff) < nu\_bits(nu\_star\_vertices-1) -
       nu\_bits(nu\_bits(nu\_star\_vertices-1))}
400         \textcolor{comment}{// we define  nu\_bits(nu\_star\_vertices-1) =: nb\_nsv and nu\_bits(nu\_bits(nu\_star\_vertices-1)) =:
       nb\_nb\_nsv this is define above the loop}
401         \textcolor{comment}{// we also have defined the difference above as diff\_threshold to simplify}
402         nb\_diff = \hyperlink{bitstream_8cpp_a9dfce6f51e3febb3973aa3b16c2fecb4}{nu\_bits}(diff);
403         \textcolor{keywordflow}{if} (nb\_diff < diff\_threshold)\{
404           \textcolor{comment}{//if (it->second[i].size() < 100)}
405           \textcolor{comment}{//  cerr << " f ";}
406           \textcolor{comment}{// we choose the first method}
407           \textcolor{comment}{// we write a flag 1 upfront to tell decoder which method we use}
408           oup.write\_bits(1,1); \textcolor{comment}{// write a single bit with value 1}
409           oup.write\_bits(nb\_diff, nb\_nb\_nsv); \textcolor{comment}{// write the number of bits in diff }
410           diff -= (1<<(nb\_diff-1)); \textcolor{comment}{// remove the leading (MSB) bit from diff}
411           \textcolor{keywordflow}{if} (nb\_diff > 1) \textcolor{comment}{// otherwise, we do not need to write anything (note we remove leading one, so
       if diff = 1, we should not write anything at this stage)}
412             oup.write\_bits(diff, nb\_diff-1); \textcolor{comment}{// write diff to the output}
413         \}\textcolor{keywordflow}{else}\{
414           \textcolor{comment}{//if (it->second[i].size() < 100)}
415           \textcolor{comment}{//  cerr << " s ";}
416           \textcolor{comment}{// we should choose the second method}
417           \textcolor{comment}{// write a flag 0 upfront}
418           oup.write\_bits(0,1);
419           oup.write\_bits(diff, nb\_nsv);
420         \}
421       \}
422       \textcolor{comment}{//if (it->second[i].size() < 100)}
423       \textcolor{comment}{//  cerr << endl;}
424 
425       nu\_star\_edges += it->second[i].size();
426       
427     \}
428     \textcolor{keywordflow}{if} (\hyperlink{classlogger_a26812b5ba03f130e8dae3446d5fc032f}{logger::stat})\{
429       *\hyperlink{classlogger_a7db37821f875f2ba3540980b355779f5}{logger::stat\_stream} << \textcolor{stringliteral}{"mark pair: "} <<  x << \textcolor{stringliteral}{", "} << xp << endl;
430       \textcolor{keywordflow}{for} (map<int, int>::iterator deg\_it = deg\_map.begin(); deg\_it != deg\_map.end(); deg\_it++)\{
431         *\hyperlink{classlogger_a7db37821f875f2ba3540980b355779f5}{logger::stat\_stream} << \textcolor{stringliteral}{" d "} << deg\_it->first << \textcolor{stringliteral}{" # "} << deg\_it->second;
432       \}
433       *\hyperlink{classlogger_a7db37821f875f2ba3540980b355779f5}{logger::stat\_stream} << endl;
434     \}
435   \}
436   
437   chunks\_new = oup.chunks();
438   space\_log.push\_back(pair<string, int> (\textcolor{stringliteral}{"star edges"}, chunks\_new - chunks));
439   chunks = oup.chunks();
440 
441   \hyperlink{classlogger_a710163deb17bc81f70d53d285b8ac9ac}{logger::add\_entry}(\textcolor{stringliteral}{"vertex types"}, \textcolor{stringliteral}{""});
442   \textcolor{comment}{//output\_bits = 0;}
443   
444   \textcolor{comment}{// ==== write vertex types}
445 
446   \textcolor{comment}{// first, we need vertex types list (ver\_type\_list)}
447   \textcolor{comment}{// size of ver\_type\_list}
448   oup <<  \hyperlink{classmarked__graph__compressed_af2e3e55223d436628a02758dfae88493}{ver\_type\_list}.size();
449   \textcolor{comment}{//fwrite(&int\_out, sizeof int\_out, 1, f);}
450   \textcolor{comment}{//output\_bits += sizeof int\_out;}
451 
452   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0;i<\hyperlink{classmarked__graph__compressed_af2e3e55223d436628a02758dfae88493}{ver\_type\_list}.size();i++)\{
453     oup << \hyperlink{classmarked__graph__compressed_af2e3e55223d436628a02758dfae88493}{ver\_type\_list}[i].size();
454     \textcolor{comment}{//fwrite(&int\_out, sizeof int\_out, 1, f);}
455     \textcolor{comment}{//output\_bits += sizeof int\_out;}
456 
457     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j=0;j<\hyperlink{classmarked__graph__compressed_af2e3e55223d436628a02758dfae88493}{ver\_type\_list}[i].size();j++)\{
458       \textcolor{keywordflow}{if} (j%3 == 0 and j > 0) \textcolor{comment}{// we know that these indices are the count part (list is of the form \(\backslash\)theta,
       t, t', n\_\{t,t'\}, \(\backslash\)dots but the n\_\{t,t'\} \(\backslash\)geq 1, so in Elias delta encoding of oup << we do not need to add
       one. So it would be more efficient to subtract one here, and add one during decompression)}
459         oup << \hyperlink{classmarked__graph__compressed_af2e3e55223d436628a02758dfae88493}{ver\_type\_list}[i][j]-1;
460       \textcolor{keywordflow}{else}
461         oup << ver\_type\_list[i][j];
462       \textcolor{comment}{//fwrite(&int\_out, sizeof int\_out, 1, f);}
463       \textcolor{comment}{//output\_bits += sizeof int\_out;}
464     \}
465   \}
466 
467   chunks\_new = oup.chunks();
468   space\_log.push\_back(pair<string, int>(\textcolor{stringliteral}{"vertex type list"}, chunks\_new - chunks));
469   chunks = chunks\_new;
470 
471   \textcolor{comment}{//output\_bits = 0;}
472   
473   \textcolor{comment}{// then, write ver\_types}
474 
475   \textcolor{comment}{// ver\_types.first}
476   \textcolor{comment}{// ver\_types.first.size():}
477   oup << \hyperlink{classmarked__graph__compressed_af446cc5e23c241a92b76642fd5ebc403}{ver\_types}.first.size();
478   \textcolor{comment}{//fwrite(&int\_out, sizeof int\_out, 1, f);}
479   \textcolor{comment}{//output\_bits += sizeof int\_out;}
480 
481   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i =0;i<\hyperlink{classmarked__graph__compressed_af446cc5e23c241a92b76642fd5ebc403}{ver\_types}.first.size(); i++)\{
482     oup <<  \hyperlink{classmarked__graph__compressed_af446cc5e23c241a92b76642fd5ebc403}{ver\_types}.first[i];
483     \textcolor{comment}{//fwrite(&int\_out, sizeof int\_out, 1, f);}
484     \textcolor{comment}{//output\_bits += sizeof int\_out;}
485   \}
486   \textcolor{comment}{// ver\_types.second}
487   oup << \hyperlink{classmarked__graph__compressed_af446cc5e23c241a92b76642fd5ebc403}{ver\_types}.second;
488   \textcolor{comment}{//output\_bits += mpz\_out\_raw(f, ver\_types.second.get\_mpz\_t());}
489 
490   chunks\_new = oup.chunks();
491   space\_log.push\_back(pair<string, int> (\textcolor{stringliteral}{"vertex types"}, chunks\_new - chunks));
492   chunks = chunks\_new;
493 
494   \hyperlink{classlogger_a710163deb17bc81f70d53d285b8ac9ac}{logger::add\_entry}(\textcolor{stringliteral}{"partition bipartite graphs"}, \textcolor{stringliteral}{""});
495   
496 
497   \textcolor{comment}{// ==== part bgraphs}
498   \textcolor{comment}{//output\_bits = 0;}
499 
500   \textcolor{comment}{// part\_bgraphs.size}
501   oup << \hyperlink{classmarked__graph__compressed_a7b3267063fba30b45eb21b3ba4e07536}{part\_bgraph}.size();
502   \textcolor{comment}{//fwrite(&int\_out, sizeof int\_out, 1, f);}
503   \textcolor{comment}{//output\_bits += sizeof int\_out;}
504 
505   map<pair<int, int>, mpz\_class>::iterator it2;
506   \textcolor{keywordflow}{if} (\hyperlink{classlogger_a26812b5ba03f130e8dae3446d5fc032f}{logger::stat})\{
507     *\hyperlink{classlogger_a7db37821f875f2ba3540980b355779f5}{logger::stat\_stream} << \textcolor{stringliteral}{" ==== statistics ==== "} << endl;
508     *\hyperlink{classlogger_a7db37821f875f2ba3540980b355779f5}{logger::stat\_stream} << \textcolor{stringliteral}{" n:                "} << n << endl;
509     *\hyperlink{classlogger_a7db37821f875f2ba3540980b355779f5}{logger::stat\_stream} << \textcolor{stringliteral}{" h:                "} << h << endl;
510     *\hyperlink{classlogger_a7db37821f875f2ba3540980b355779f5}{logger::stat\_stream} << \textcolor{stringliteral}{" delta:            "} << delta << endl;
511     *\hyperlink{classlogger_a7db37821f875f2ba3540980b355779f5}{logger::stat\_stream} << \textcolor{stringliteral}{" No. types         "} << 
      \hyperlink{classmarked__graph__compressed_a86b00223525703e973415cbc9c94da68}{type\_mark}.size() << endl;
512     *\hyperlink{classlogger_a7db37821f875f2ba3540980b355779f5}{logger::stat\_stream} << \textcolor{stringliteral}{" No. * vertices    "} << n - 
      \hyperlink{classmarked__graph__compressed_a7a4ced4586e2e353f9076bd447df5208}{star\_vertices}.first[0] << endl;
513     *\hyperlink{classlogger_a7db37821f875f2ba3540980b355779f5}{logger::stat\_stream} << \textcolor{stringliteral}{" No. * edges       "} << nu\_star\_edges << endl;
514     *\hyperlink{classlogger_a7db37821f875f2ba3540980b355779f5}{logger::stat\_stream} << \textcolor{stringliteral}{" No. part bgraphs  "} << 
      \hyperlink{classmarked__graph__compressed_a7b3267063fba30b45eb21b3ba4e07536}{part\_bgraph}.size() << endl;
515     *\hyperlink{classlogger_a7db37821f875f2ba3540980b355779f5}{logger::stat\_stream} << \textcolor{stringliteral}{" No. part graphs   "} << 
      \hyperlink{classmarked__graph__compressed_ae179a4737e6eab905c18a94d44ef64b7}{part\_graph}.size() << endl;
516   \}
517 
518   \textcolor{keywordflow}{for} (it2 = \hyperlink{classmarked__graph__compressed_a7b3267063fba30b45eb21b3ba4e07536}{part\_bgraph}.begin(); it2 != \hyperlink{classmarked__graph__compressed_a7b3267063fba30b45eb21b3ba4e07536}{part\_bgraph}.end(); it2++)\{
519     \textcolor{comment}{// first, write t, t'}
520     oup << it2->first.first;
521     \textcolor{comment}{//fwrite(&int\_out, sizeof int\_out, 1, f);}
522     \textcolor{comment}{//output\_bits += sizeof int\_out;}
523     oup <<  it2->first.second;
524     \textcolor{comment}{//fwrite(&int\_out, sizeof int\_out, 1, f);}
525     \textcolor{comment}{//output\_bits += sizeof int\_out;}
526     \textcolor{comment}{// then, the compressed integer}
527     oup << it2->second;
528     \textcolor{comment}{//output\_bits += mpz\_out\_raw(f, it2->second.get\_mpz\_t());}
529   \}
530 
531   chunks\_new = oup.chunks();
532   space\_log.push\_back(pair<string, int> (\textcolor{stringliteral}{"partition bipartite graphs"}, chunks\_new - chunks));
533   chunks = chunks\_new;
534 
535   \hyperlink{classlogger_a710163deb17bc81f70d53d285b8ac9ac}{logger::add\_entry}(\textcolor{stringliteral}{"partition graphs"}, \textcolor{stringliteral}{""});
536   \textcolor{comment}{//output\_bits = 0;}
537   \textcolor{comment}{// === part graphs}
538 
539   \textcolor{comment}{// part\_graph.size}
540   oup <<  \hyperlink{classmarked__graph__compressed_ae179a4737e6eab905c18a94d44ef64b7}{part\_graph}.size();
541   \textcolor{comment}{//fwrite(&int\_out, sizeof int\_out, 1, f);}
542   \textcolor{comment}{//output\_bits += sizeof int\_out;}
543 
544   map< int, pair< mpz\_class, vector< int > > >::iterator it3;
545   \textcolor{keywordflow}{for} (it3 = \hyperlink{classmarked__graph__compressed_ae179a4737e6eab905c18a94d44ef64b7}{part\_graph}.begin(); it3 != \hyperlink{classmarked__graph__compressed_ae179a4737e6eab905c18a94d44ef64b7}{part\_graph}.end(); it3++)\{
546     oup <<  it3->first; \textcolor{comment}{// the type}
547     \textcolor{comment}{//fwrite(&int\_out, sizeof int\_out, 1, f);}
548     \textcolor{comment}{//output\_bits += sizeof int\_out;}
549 
550     \textcolor{comment}{// the mpz part}
551     oup << it3->second.first;
552     \textcolor{comment}{//output\_bits += mpz\_out\_raw(f, it3->second.first.get\_mpz\_t());}
553     \textcolor{comment}{// the vector part}
554     \textcolor{comment}{// first its size}
555     oup <<  it3->second.second.size();
556     \textcolor{comment}{//fwrite(&int\_out, sizeof int\_out, 1, f);}
557     \textcolor{comment}{//output\_bits += sizeof int\_out;}
558     \textcolor{comment}{// then element by element}
559     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} j=0;j<it3->second.second.size();j++)\{
560       oup <<  it3->second.second[j];
561       \textcolor{comment}{//fwrite(&int\_out, sizeof int\_out, 1, f);}
562       \textcolor{comment}{//output\_bits += sizeof int\_out;}
563     \}
564   \}
565 
566   chunks\_new = oup.chunks();
567   space\_log.push\_back(pair<string, int>(\textcolor{stringliteral}{"partition graphs"}, chunks\_new - chunks));
568   chunks = chunks\_new;
569 
570   
571   \textcolor{keywordflow}{if} (\hyperlink{classlogger_a26812b5ba03f130e8dae3446d5fc032f}{logger::stat})\{
572     *\hyperlink{classlogger_a7db37821f875f2ba3540980b355779f5}{logger::stat\_stream} << endl << endl;
573     *\hyperlink{classlogger_a7db37821f875f2ba3540980b355779f5}{logger::stat\_stream} << \textcolor{stringliteral}{" Number of bytes used for each part "} << endl;
574     *\hyperlink{classlogger_a7db37821f875f2ba3540980b355779f5}{logger::stat\_stream} << \textcolor{stringliteral}{" ---------------------------------- "} << endl << endl;
575 
576     \textcolor{keywordtype}{int} total\_chunks = 0;
577     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0; i < space\_log.size(); i++)
578       total\_chunks += space\_log[i].second;
579 
580     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0; i < space\_log.size(); i++)\{
581       \textcolor{comment}{// each chunks is 4 bytes. }
582       *\hyperlink{classlogger_a7db37821f875f2ba3540980b355779f5}{logger::stat\_stream} << space\_log[i].first << \textcolor{stringliteral}{" -> "}  << 4 * space\_log[i].second <
      < \textcolor{stringliteral}{" ( "} << float(100) * float(space\_log[i].second) / float(total\_chunks) << \textcolor{stringliteral}{" % "} << endl;
583     \}
584 
585     *\hyperlink{classlogger_a7db37821f875f2ba3540980b355779f5}{logger::stat\_stream} << \textcolor{stringliteral}{" Total number of bytes wrote to the output = "} << 4 * 
      total\_chunks << endl;
586   \}
587   
588   oup.close();
589   \hyperlink{classlogger_a9d29b49bd318a719a8e85b59eac54fe0}{logger::current\_depth}--;
590 \}
\end{DoxyCode}
\mbox{\Hypertarget{classmarked__graph__compressed_af58307bfadcaa4c3ca6dd594c2f9b3a9}\label{classmarked__graph__compressed_af58307bfadcaa4c3ca6dd594c2f9b3a9}} 
\index{marked\+\_\+graph\+\_\+compressed@{marked\+\_\+graph\+\_\+compressed}!clear@{clear}}
\index{clear@{clear}!marked\+\_\+graph\+\_\+compressed@{marked\+\_\+graph\+\_\+compressed}}
\subsubsection{\texorpdfstring{clear()}{clear()}}
{\footnotesize\ttfamily void marked\+\_\+graph\+\_\+compressed\+::clear (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}


\begin{DoxyCode}
9 \{
10   \hyperlink{classmarked__graph__compressed_a7df5779d313486644132bd816937f532}{star\_edges}.clear();
11   \hyperlink{classmarked__graph__compressed_a86b00223525703e973415cbc9c94da68}{type\_mark}.clear();
12   \hyperlink{classmarked__graph__compressed_af2e3e55223d436628a02758dfae88493}{ver\_type\_list}.clear();
13   \hyperlink{classmarked__graph__compressed_a7b3267063fba30b45eb21b3ba4e07536}{part\_bgraph}.clear();
14   \hyperlink{classmarked__graph__compressed_ae179a4737e6eab905c18a94d44ef64b7}{part\_graph}.clear();
15 \}
\end{DoxyCode}


\subsection{Member Data Documentation}
\mbox{\Hypertarget{classmarked__graph__compressed_a8b2aaac68e9332ddc78d88eb60b323a7}\label{classmarked__graph__compressed_a8b2aaac68e9332ddc78d88eb60b323a7}} 
\index{marked\+\_\+graph\+\_\+compressed@{marked\+\_\+graph\+\_\+compressed}!delta@{delta}}
\index{delta@{delta}!marked\+\_\+graph\+\_\+compressed@{marked\+\_\+graph\+\_\+compressed}}
\subsubsection{\texorpdfstring{delta}{delta}}
{\footnotesize\ttfamily int marked\+\_\+graph\+\_\+compressed\+::delta}



the degree threshold used when compression was performed 

\mbox{\Hypertarget{classmarked__graph__compressed_af6ff623407b673d08d0cab77b39c2193}\label{classmarked__graph__compressed_af6ff623407b673d08d0cab77b39c2193}} 
\index{marked\+\_\+graph\+\_\+compressed@{marked\+\_\+graph\+\_\+compressed}!h@{h}}
\index{h@{h}!marked\+\_\+graph\+\_\+compressed@{marked\+\_\+graph\+\_\+compressed}}
\subsubsection{\texorpdfstring{h}{h}}
{\footnotesize\ttfamily int marked\+\_\+graph\+\_\+compressed\+::h}



the depth up to which the compression was performed 

\mbox{\Hypertarget{classmarked__graph__compressed_a8d841016ddb11cfd33748c8deb6277ba}\label{classmarked__graph__compressed_a8d841016ddb11cfd33748c8deb6277ba}} 
\index{marked\+\_\+graph\+\_\+compressed@{marked\+\_\+graph\+\_\+compressed}!n@{n}}
\index{n@{n}!marked\+\_\+graph\+\_\+compressed@{marked\+\_\+graph\+\_\+compressed}}
\subsubsection{\texorpdfstring{n}{n}}
{\footnotesize\ttfamily int marked\+\_\+graph\+\_\+compressed\+::n}



the number of vertices 

\mbox{\Hypertarget{classmarked__graph__compressed_a7b3267063fba30b45eb21b3ba4e07536}\label{classmarked__graph__compressed_a7b3267063fba30b45eb21b3ba4e07536}} 
\index{marked\+\_\+graph\+\_\+compressed@{marked\+\_\+graph\+\_\+compressed}!part\+\_\+bgraph@{part\+\_\+bgraph}}
\index{part\+\_\+bgraph@{part\+\_\+bgraph}!marked\+\_\+graph\+\_\+compressed@{marked\+\_\+graph\+\_\+compressed}}
\subsubsection{\texorpdfstring{part\+\_\+bgraph}{part\_bgraph}}
{\footnotesize\ttfamily map$<$pair$<$int, int$>$, mpz\+\_\+class$>$ marked\+\_\+graph\+\_\+compressed\+::part\+\_\+bgraph}



compressed form of partition bipartite graphs corresponding to colors in $C_<$. For a pair $0 \leq t < t' < L$ of half edge types, part\+\_\+bgraph\mbox{[}pair$<$int, int$>$(t,t\textquotesingle{})\mbox{]} is the compressed form of the bipartite graph with n left and right nodes, where a left node i is connected to a right node j if there is an edge connecting i to j with type t towards i and type t\textquotesingle{} towards j 

\mbox{\Hypertarget{classmarked__graph__compressed_ae179a4737e6eab905c18a94d44ef64b7}\label{classmarked__graph__compressed_ae179a4737e6eab905c18a94d44ef64b7}} 
\index{marked\+\_\+graph\+\_\+compressed@{marked\+\_\+graph\+\_\+compressed}!part\+\_\+graph@{part\+\_\+graph}}
\index{part\+\_\+graph@{part\+\_\+graph}!marked\+\_\+graph\+\_\+compressed@{marked\+\_\+graph\+\_\+compressed}}
\subsubsection{\texorpdfstring{part\+\_\+graph}{part\_graph}}
{\footnotesize\ttfamily map$<$int, pair$<$mpz\+\_\+class, vector$<$int$>$ $>$ $>$ marked\+\_\+graph\+\_\+compressed\+::part\+\_\+graph}



compressed form of partition graphs corresponding to colors in $C_=$. For a half edge type t, part\+\_\+graph\mbox{[}t\mbox{]} is the compressed form of the simple unmarked graph with n vertices, where a node i is connected to a node j where there is an edge between i and j in the original graph with color (t,t) 

\mbox{\Hypertarget{classmarked__graph__compressed_a7df5779d313486644132bd816937f532}\label{classmarked__graph__compressed_a7df5779d313486644132bd816937f532}} 
\index{marked\+\_\+graph\+\_\+compressed@{marked\+\_\+graph\+\_\+compressed}!star\+\_\+edges@{star\+\_\+edges}}
\index{star\+\_\+edges@{star\+\_\+edges}!marked\+\_\+graph\+\_\+compressed@{marked\+\_\+graph\+\_\+compressed}}
\subsubsection{\texorpdfstring{star\+\_\+edges}{star\_edges}}
{\footnotesize\ttfamily map$<$pair$<$int, int$>$ , vector$<$vector$<$int$>$ $>$ $>$ marked\+\_\+graph\+\_\+compressed\+::star\+\_\+edges}



for each pair of edge marks x,x\textquotesingle{}, and integer $k$, star\+\_\+edges\mbox{[}pair$<$int,int$>$(x,x\textquotesingle{})\mbox{]}\mbox{[}k\mbox{]} is a list of neighbors $w$ of the $k$th star vertex (say $v$) so that $v$ shares a star edge with $w$ so that the mark towards $v$ is x and the mark towards $w$ is xp. 

\mbox{\Hypertarget{classmarked__graph__compressed_a7a4ced4586e2e353f9076bd447df5208}\label{classmarked__graph__compressed_a7a4ced4586e2e353f9076bd447df5208}} 
\index{marked\+\_\+graph\+\_\+compressed@{marked\+\_\+graph\+\_\+compressed}!star\+\_\+vertices@{star\+\_\+vertices}}
\index{star\+\_\+vertices@{star\+\_\+vertices}!marked\+\_\+graph\+\_\+compressed@{marked\+\_\+graph\+\_\+compressed}}
\subsubsection{\texorpdfstring{star\+\_\+vertices}{star\_vertices}}
{\footnotesize\ttfamily pair$<$vector$<$int$>$, mpz\+\_\+class$>$ marked\+\_\+graph\+\_\+compressed\+::star\+\_\+vertices}



the compressed form of the star\+\_\+vertices list 

\mbox{\Hypertarget{classmarked__graph__compressed_a86b00223525703e973415cbc9c94da68}\label{classmarked__graph__compressed_a86b00223525703e973415cbc9c94da68}} 
\index{marked\+\_\+graph\+\_\+compressed@{marked\+\_\+graph\+\_\+compressed}!type\+\_\+mark@{type\+\_\+mark}}
\index{type\+\_\+mark@{type\+\_\+mark}!marked\+\_\+graph\+\_\+compressed@{marked\+\_\+graph\+\_\+compressed}}
\subsubsection{\texorpdfstring{type\+\_\+mark}{type\_mark}}
{\footnotesize\ttfamily vector$<$int$>$ marked\+\_\+graph\+\_\+compressed\+::type\+\_\+mark}



for an edge type t, type\+\_\+mark\mbox{[}t\mbox{]} denotes the mark component of t 

\mbox{\Hypertarget{classmarked__graph__compressed_af2e3e55223d436628a02758dfae88493}\label{classmarked__graph__compressed_af2e3e55223d436628a02758dfae88493}} 
\index{marked\+\_\+graph\+\_\+compressed@{marked\+\_\+graph\+\_\+compressed}!ver\+\_\+type\+\_\+list@{ver\+\_\+type\+\_\+list}}
\index{ver\+\_\+type\+\_\+list@{ver\+\_\+type\+\_\+list}!marked\+\_\+graph\+\_\+compressed@{marked\+\_\+graph\+\_\+compressed}}
\subsubsection{\texorpdfstring{ver\+\_\+type\+\_\+list}{ver\_type\_list}}
{\footnotesize\ttfamily vector$<$vector$<$int$>$ $>$ marked\+\_\+graph\+\_\+compressed\+::ver\+\_\+type\+\_\+list}



the list of all vertex types that appear in the graph, where the type of a vertex is a vector of integers, where its index 0 is the mark of the vertex, and indices $3k+1$, $3k+2$, $3k+3$ are $m$, $m'$ and $n_{m,m'}$, where $(m,m')$ is a type pair, and $n_{m,m'}$ is the number of edges connected to the vertex with that type. The list is sorted lexicographically to ensure unique representation. 

\mbox{\Hypertarget{classmarked__graph__compressed_af446cc5e23c241a92b76642fd5ebc403}\label{classmarked__graph__compressed_af446cc5e23c241a92b76642fd5ebc403}} 
\index{marked\+\_\+graph\+\_\+compressed@{marked\+\_\+graph\+\_\+compressed}!ver\+\_\+types@{ver\+\_\+types}}
\index{ver\+\_\+types@{ver\+\_\+types}!marked\+\_\+graph\+\_\+compressed@{marked\+\_\+graph\+\_\+compressed}}
\subsubsection{\texorpdfstring{ver\+\_\+types}{ver\_types}}
{\footnotesize\ttfamily pair$<$vector$<$int$>$, mpz\+\_\+class$>$ marked\+\_\+graph\+\_\+compressed\+::ver\+\_\+types}



the compressed form of vertex types, where the type of a vertex is the index with respect to ver\+\_\+type\+\_\+list of the list of integers specifying the type of the vertex (mark of the vertex followed by the number of edges of each type connected to that vertex) 



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
\hyperlink{marked__graph__compression_8h}{marked\+\_\+graph\+\_\+compression.\+h}\item 
\hyperlink{marked__graph__compression_8cpp}{marked\+\_\+graph\+\_\+compression.\+cpp}\end{DoxyCompactItemize}
