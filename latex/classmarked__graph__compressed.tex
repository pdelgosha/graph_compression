\hypertarget{classmarked__graph__compressed}{}\section{marked\+\_\+graph\+\_\+compressed Class Reference}
\label{classmarked__graph__compressed}\index{marked\+\_\+graph\+\_\+compressed@{marked\+\_\+graph\+\_\+compressed}}


{\ttfamily \#include $<$marked\+\_\+graph\+\_\+compression.\+h$>$}

\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classmarked__graph__compressed_af58307bfadcaa4c3ca6dd594c2f9b3a9}{clear} ()
\item 
void \hyperlink{classmarked__graph__compressed_ab9cdb7fc43badd58fb5202f74ffac723}{binary\+\_\+write} (F\+I\+LE $\ast$f)
\begin{DoxyCompactList}\small\item\em writes the compressed data to a binary file \end{DoxyCompactList}\item 
void \hyperlink{classmarked__graph__compressed_a13ab09e4b399f179ec91746ae2b8b38c}{binary\+\_\+write} (string s)
\item 
void \hyperlink{classmarked__graph__compressed_a9db2d11bd63ad3d5a75e47b4023a89dd}{binary\+\_\+read} (F\+I\+LE $\ast$f)
\begin{DoxyCompactList}\small\item\em read the compressed data from a binary file \end{DoxyCompactList}\item 
void \hyperlink{classmarked__graph__compressed_a01c67fe4234738db6bb60459515c3ad8}{binary\+\_\+read} (string s)
\item 
int \hyperlink{classmarked__graph__compressed_a5ce51414e335d817f4be781fdcfbe9b1}{vtype\+\_\+max\+\_\+match} (int i, int j)
\begin{DoxyCompactList}\small\item\em finds the maximum number of (t,t\textquotesingle{},n) blocks that match between two entries of ver\+\_\+type\+\_\+list \end{DoxyCompactList}\item 
void \hyperlink{classmarked__graph__compressed_a889749dd51bc37917a156e337eac142a}{vtype\+\_\+list\+\_\+write} (\hyperlink{classobitstream}{obitstream} \&oup)
\begin{DoxyCompactList}\small\item\em writes the ver\+\_\+type\+\_\+list array to the output using difference coding, assuming that its entries are lexicographically sorted (as vectors) \end{DoxyCompactList}\item 
void \hyperlink{classmarked__graph__compressed_af29f16cbd56583652118eb24a7c233b7}{vtype\+\_\+list\+\_\+read} (\hyperlink{classibitstream}{ibitstream} \&inp)
\begin{DoxyCompactList}\small\item\em reads the ver\+\_\+type\+\_\+list array from the input, assuming the bit sequence was generated during compression using vtype\+\_\+list\+\_\+write \end{DoxyCompactList}\item 
void \hyperlink{classmarked__graph__compressed_a31f9ea72682f9072d0f90faf58a603fe}{vtype\+\_\+block\+\_\+write} (\hyperlink{classobitstream}{obitstream} \&oup, int i, int j)
\item 
void \hyperlink{classmarked__graph__compressed_ad443f83015addcc0f2b0e35351ae9362}{vtype\+\_\+block\+\_\+write} (\hyperlink{classobitstream}{obitstream} \&oup, int i, int j, int ir, int jr)
\item 
void \hyperlink{classmarked__graph__compressed_a4bf8563a2dfd3038dc5833c014320487}{vtype\+\_\+block\+\_\+read} (\hyperlink{classibitstream}{ibitstream} \&inp, int i, int j)
\item 
void \hyperlink{classmarked__graph__compressed_a01a434f3313d99b5877eddacb380cf15}{vtype\+\_\+block\+\_\+read} (\hyperlink{classibitstream}{ibitstream} \&inp, int i, int j, int ir, int jr)
\end{DoxyCompactItemize}
\subsection*{Public Attributes}
\begin{DoxyCompactItemize}
\item 
int \hyperlink{classmarked__graph__compressed_a8d841016ddb11cfd33748c8deb6277ba}{n}
\begin{DoxyCompactList}\small\item\em the number of vertices \end{DoxyCompactList}\item 
int \hyperlink{classmarked__graph__compressed_af6ff623407b673d08d0cab77b39c2193}{h}
\begin{DoxyCompactList}\small\item\em the depth up to which the compression was performed \end{DoxyCompactList}\item 
int \hyperlink{classmarked__graph__compressed_a8b2aaac68e9332ddc78d88eb60b323a7}{delta}
\begin{DoxyCompactList}\small\item\em the degree threshold used when compression was performed \end{DoxyCompactList}\item 
pair$<$ vector$<$ int $>$, mpz\+\_\+class $>$ \hyperlink{classmarked__graph__compressed_a7a4ced4586e2e353f9076bd447df5208}{star\+\_\+vertices}
\begin{DoxyCompactList}\small\item\em the compressed form of the star\+\_\+vertices list \end{DoxyCompactList}\item 
map$<$ pair$<$ int, int $>$, vector$<$ vector$<$ int $>$ $>$ $>$ \hyperlink{classmarked__graph__compressed_a7df5779d313486644132bd816937f532}{star\+\_\+edges}
\begin{DoxyCompactList}\small\item\em for each pair of edge marks x,x\textquotesingle{}, and integer $k$, star\+\_\+edges\mbox{[}pair$<$int,int$>$(x,x\textquotesingle{})\mbox{]}\mbox{[}k\mbox{]} is a list of neighbors $w$ of the $k$th star vertex (say $v$) so that $v$ shares a star edge with $w$ so that the mark towards $v$ is x and the mark towards $w$ is xp. \end{DoxyCompactList}\item 
vector$<$ int $>$ \hyperlink{classmarked__graph__compressed_a86b00223525703e973415cbc9c94da68}{type\+\_\+mark}
\begin{DoxyCompactList}\small\item\em for an edge type t, type\+\_\+mark\mbox{[}t\mbox{]} denotes the mark component of t \end{DoxyCompactList}\item 
vector$<$ vector$<$ int $>$ $>$ \hyperlink{classmarked__graph__compressed_af2e3e55223d436628a02758dfae88493}{ver\+\_\+type\+\_\+list}
\begin{DoxyCompactList}\small\item\em the list of all vertex types that appear in the graph, where the type of a vertex is a vector of integers, where its index 0 is the mark of the vertex, and indices $3k+1$, $3k+2$, $3k+3$ are $m$, $m'$ and $n_{m,m'}$, where $(m,m')$ is a type pair, and $n_{m,m'}$ is the number of edges connected to the vertex with that type. The list is sorted lexicographically to ensure unique representation. \end{DoxyCompactList}\item 
pair$<$ vector$<$ int $>$, mpz\+\_\+class $>$ \hyperlink{classmarked__graph__compressed_af446cc5e23c241a92b76642fd5ebc403}{ver\+\_\+types}
\begin{DoxyCompactList}\small\item\em the compressed form of vertex types, where the type of a vertex is the index with respect to ver\+\_\+type\+\_\+list of the list of integers specifying the type of the vertex (mark of the vertex followed by the number of edges of each type connected to that vertex) \end{DoxyCompactList}\item 
map$<$ pair$<$ int, int $>$, mpz\+\_\+class $>$ \hyperlink{classmarked__graph__compressed_a7b3267063fba30b45eb21b3ba4e07536}{part\+\_\+bgraph}
\begin{DoxyCompactList}\small\item\em compressed form of partition bipartite graphs corresponding to colors in $C_<$. For a pair $0 \leq t < t' < L$ of half edge types, part\+\_\+bgraph\mbox{[}pair$<$int, int$>$(t,t\textquotesingle{})\mbox{]} is the compressed form of the bipartite graph with n left and right nodes, where a left node i is connected to a right node j if there is an edge connecting i to j with type t towards i and type t\textquotesingle{} towards j \end{DoxyCompactList}\item 
map$<$ int, pair$<$ mpz\+\_\+class, vector$<$ int $>$ $>$ $>$ \hyperlink{classmarked__graph__compressed_ae179a4737e6eab905c18a94d44ef64b7}{part\+\_\+graph}
\begin{DoxyCompactList}\small\item\em compressed form of partition graphs corresponding to colors in $C_=$. For a half edge type t, part\+\_\+graph\mbox{[}t\mbox{]} is the compressed form of the simple unmarked graph with n vertices, where a node i is connected to a node j where there is an edge between i and j in the original graph with color (t,t) \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Member Function Documentation}
\mbox{\Hypertarget{classmarked__graph__compressed_a9db2d11bd63ad3d5a75e47b4023a89dd}\label{classmarked__graph__compressed_a9db2d11bd63ad3d5a75e47b4023a89dd}} 
\index{marked\+\_\+graph\+\_\+compressed@{marked\+\_\+graph\+\_\+compressed}!binary\+\_\+read@{binary\+\_\+read}}
\index{binary\+\_\+read@{binary\+\_\+read}!marked\+\_\+graph\+\_\+compressed@{marked\+\_\+graph\+\_\+compressed}}
\subsubsection{\texorpdfstring{binary\+\_\+read()}{binary\_read()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void marked\+\_\+graph\+\_\+compressed\+::binary\+\_\+read (\begin{DoxyParamCaption}\item[{F\+I\+LE $\ast$}]{f }\end{DoxyParamCaption})}



read the compressed data from a binary file 


\begin{DoxyParams}{Parameters}
{\em f} & a {\ttfamily F\+I\+L\+E$\ast$} object which is the address of the binary file to write \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
628                                                 \{
629   \hyperlink{classmarked__graph__compressed_af58307bfadcaa4c3ca6dd594c2f9b3a9}{clear}(); \textcolor{comment}{// to make sure nothing is stored inside me before reading}
630 
631   \textcolor{comment}{// ==== read n, h, delta}
632   fread(&\hyperlink{classmarked__graph__compressed_a8d841016ddb11cfd33748c8deb6277ba}{n}, \textcolor{keyword}{sizeof} \hyperlink{classmarked__graph__compressed_a8d841016ddb11cfd33748c8deb6277ba}{n}, 1, f);
633   fread(&\hyperlink{classmarked__graph__compressed_af6ff623407b673d08d0cab77b39c2193}{h}, \textcolor{keyword}{sizeof} \hyperlink{classmarked__graph__compressed_af6ff623407b673d08d0cab77b39c2193}{h}, 1, f);
634   fread(&\hyperlink{classmarked__graph__compressed_a8b2aaac68e9332ddc78d88eb60b323a7}{delta}, \textcolor{keyword}{sizeof} \hyperlink{classmarked__graph__compressed_a8b2aaac68e9332ddc78d88eb60b323a7}{delta}, 1, f);
635 
636   \textcolor{keywordtype}{int} int\_in; \textcolor{comment}{// auxiliary input integer}
637   \textcolor{comment}{// ===== read type\_mark}
638   \textcolor{comment}{// read number of types}
639   fread(&int\_in, \textcolor{keyword}{sizeof} int\_in, 1, f);
640   \hyperlink{classmarked__graph__compressed_a86b00223525703e973415cbc9c94da68}{type\_mark}.resize(int\_in);
641   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0;i<\hyperlink{classmarked__graph__compressed_a86b00223525703e973415cbc9c94da68}{type\_mark}.size();i++)\{
642     fread(&int\_in, \textcolor{keyword}{sizeof} int\_in, 1, f);
643     \hyperlink{classmarked__graph__compressed_a86b00223525703e973415cbc9c94da68}{type\_mark}[i] = int\_in;
644   \}
645 
646   \textcolor{comment}{// ==== read star\_vertices}
647   \textcolor{comment}{// first, read the frequency.}
648   \hyperlink{classmarked__graph__compressed_a7a4ced4586e2e353f9076bd447df5208}{star\_vertices}.first = vector<int>(2); \textcolor{comment}{// frequency,}
649   \textcolor{comment}{// we read its first index which is number of zeros, and the second is n - the first.}
650   fread(&int\_in, \textcolor{keyword}{sizeof} int\_in, 1, f);
651   \hyperlink{classmarked__graph__compressed_a7a4ced4586e2e353f9076bd447df5208}{star\_vertices}.first[0] = int\_in;
652   \hyperlink{classmarked__graph__compressed_a7a4ced4586e2e353f9076bd447df5208}{star\_vertices}.first[1] = \hyperlink{classmarked__graph__compressed_a8d841016ddb11cfd33748c8deb6277ba}{n} - int\_in;
653 
654   \textcolor{comment}{// the integer representation which is star\_vertices.second}
655   mpz\_inp\_raw(\hyperlink{classmarked__graph__compressed_a7a4ced4586e2e353f9076bd447df5208}{star\_vertices}.second.get\_mpz\_t(), f);
656 
657   \textcolor{comment}{// ==== read star\_edges}
658 
659   \textcolor{keywordtype}{int} log2n = 0; \textcolor{comment}{// the ceiling of log (n+1) in base 2 (which is equal to 1 + the floor of log\_2 n), which
       is the number of bits to encode vertices}
660   \textcolor{keywordtype}{int} n\_copy = \hyperlink{classmarked__graph__compressed_a8d841016ddb11cfd33748c8deb6277ba}{n};
661   \textcolor{keywordflow}{while}(n\_copy > 0)\{
662     n\_copy >>= 1;
663     log2n ++;
664   \}
665   bitset<8*sizeof(int)> B; \textcolor{comment}{// a bit stream with maximum length of int to store a vertex index}
666 
667   \textcolor{keywordtype}{string} s;
668   stringstream ss;
669   \textcolor{keywordtype}{int} sp; \textcolor{comment}{// the index of the string s we are studying }
670 
671   \textcolor{comment}{// read the size of star\_edges}
672 
673   \textcolor{keywordtype}{int} star\_edges\_size;
674   fread(&star\_edges\_size, \textcolor{keyword}{sizeof} star\_edges\_size, 1, f);
675 
676   \textcolor{keywordtype}{int} x, xp; \textcolor{comment}{// edge marks}
677   \textcolor{keywordtype}{int} nu\_star\_vertices = \hyperlink{classmarked__graph__compressed_a7a4ced4586e2e353f9076bd447df5208}{star\_vertices}.first[1];
678 
679   vector<vector<int> > V; \textcolor{comment}{// the list of star edges corresponding to each mark pair}
680   V.resize(nu\_star\_vertices);
681 
682   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0;i<star\_edges\_size;i++)\{
683     fread(&x, \textcolor{keyword}{sizeof} x, 1, f);
684     fread(&xp, \textcolor{keyword}{sizeof} xp, 1, f);
685   
686     s = \hyperlink{compression__helper_8cpp_a40e8dcbc036f96b28e003e882c4890b7}{bit\_string\_read}(f);
687     \textcolor{comment}{//cerr << " read  x " << x << " xp " << xp << " s " << s << endl;}
688     sp = 0; \textcolor{comment}{// starting from zero }
689     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j=0; j<nu\_star\_vertices; j++)\{ \textcolor{comment}{// }
690       V[j].clear(); \textcolor{comment}{// make it fresh}
691       \textcolor{keywordflow}{while}(s[sp++] == \textcolor{charliteral}{'1'})\{ \textcolor{comment}{// there is still some edge connected to this vertex }
692         \textcolor{comment}{// read log2n many bits}
693         \textcolor{comment}{//cerr << " s subtr " << s.substr(sp, log2n);}
694         \textcolor{comment}{//ss << s.substr(sp, log2n);}
695         B = bitset<8*sizeof(int)>(s.substr(sp, log2n));
696         \textcolor{comment}{//cerr << " ss " << ss.str() << endl;}
697         sp += log2n;
698         \textcolor{comment}{//ss >> B;}
699 
700         V[j].push\_back(B.to\_ulong());
701       \}
702       \textcolor{comment}{//for (int k=0;k<V[j].size();k++)}
703       \textcolor{comment}{//  cerr << " , " << V[j][k];}
704       \textcolor{comment}{//cerr << endl;}
705     \}
706 
707 
708     \hyperlink{classmarked__graph__compressed_a7df5779d313486644132bd816937f532}{star\_edges}.insert(pair< pair<int, int> , vector<vector<int> > > (pair<int, int>(x, xp), V));
709   \}
710 
711   \textcolor{comment}{// ==== read vertex\_types}
712 
713   \textcolor{comment}{// read ver\_type\_list}
714   fread(&int\_in, \textcolor{keyword}{sizeof} int\_in, 1, f); \textcolor{comment}{// size of ver\_type\_list}
715   \hyperlink{classmarked__graph__compressed_af2e3e55223d436628a02758dfae88493}{ver\_type\_list}.resize(int\_in);
716   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0; i<\hyperlink{classmarked__graph__compressed_af2e3e55223d436628a02758dfae88493}{ver\_type\_list}.size();i++)\{
717     fread(&int\_in, \textcolor{keyword}{sizeof} int\_in, 1, f); \textcolor{comment}{// size of ver\_type\_list[i]}
718     \hyperlink{classmarked__graph__compressed_af2e3e55223d436628a02758dfae88493}{ver\_type\_list}[i].resize(int\_in);
719     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j=0;j<\hyperlink{classmarked__graph__compressed_af2e3e55223d436628a02758dfae88493}{ver\_type\_list}[i].size();j++)\{
720       fread(&int\_in, \textcolor{keyword}{sizeof} int\_in, 1, f);
721       \hyperlink{classmarked__graph__compressed_af2e3e55223d436628a02758dfae88493}{ver\_type\_list}[i][j] = int\_in;
722     \}
723   \}
724 
725   \textcolor{comment}{// ver\_types}
726   \textcolor{comment}{// ver\_types.first}
727   \textcolor{comment}{// ver\_types.first.size()}
728   fread(&int\_in, \textcolor{keyword}{sizeof} int\_in, 1, f);
729   \hyperlink{classmarked__graph__compressed_af446cc5e23c241a92b76642fd5ebc403}{ver\_types}.first.resize(int\_in);
730   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0;i<\hyperlink{classmarked__graph__compressed_af446cc5e23c241a92b76642fd5ebc403}{ver\_types}.first.size();i++)\{
731     fread(&int\_in, \textcolor{keyword}{sizeof} int\_in, 1, f);
732     \hyperlink{classmarked__graph__compressed_af446cc5e23c241a92b76642fd5ebc403}{ver\_types}.first[i] = int\_in;
733   \}
734   \textcolor{comment}{// ver\_types.second}
735   mpz\_inp\_raw(\hyperlink{classmarked__graph__compressed_af446cc5e23c241a92b76642fd5ebc403}{ver\_types}.second.get\_mpz\_t(), f);
736 
737 
738   \textcolor{comment}{// === part bgraphs}
739   \textcolor{keywordtype}{int} part\_bgraph\_size;
740   \textcolor{keywordtype}{int} t, tp;
741   pair<int, int> type; 
742   mpz\_class part\_g; 
743   fread(&part\_bgraph\_size, \textcolor{keyword}{sizeof} part\_bgraph\_size, 1, f);
744   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0;i<part\_bgraph\_size;i++)\{
745     \textcolor{comment}{// read t, t'}
746     fread(&t, \textcolor{keyword}{sizeof} t, 1, f);
747     fread(&tp, \textcolor{keyword}{sizeof} tp, 1, f);
748     type = pair<int, int>(t, tp);
749     mpz\_inp\_raw(part\_g.get\_mpz\_t(), f);
750     \hyperlink{classmarked__graph__compressed_a7b3267063fba30b45eb21b3ba4e07536}{part\_bgraph}.insert(pair<pair<int, int>, mpz\_class> (type, part\_g));
751   \}
752 
753   \textcolor{comment}{// === part graphs}
754 
755   \textcolor{comment}{// first, the size}
756   \textcolor{keywordtype}{int} part\_graph\_size;
757   \textcolor{keywordtype}{int} v\_size;
758   vector<int> W; 
759   fread(&part\_graph\_size, \textcolor{keyword}{sizeof} part\_graph\_size, 1, f);
760   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0;i<part\_graph\_size; i++)\{
761     \textcolor{comment}{// first, the type}
762     fread(&t, \textcolor{keyword}{sizeof} t, 1, f);
763     \textcolor{comment}{// then, the mpz part}
764     mpz\_inp\_raw(part\_g.get\_mpz\_t(), f);
765     \textcolor{comment}{// then, the vector size}
766     fread(&v\_size, \textcolor{keyword}{sizeof} v\_size, 1, f);
767     W.resize(v\_size);
768     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j=0;j<v\_size; j++)\{
769       fread(&int\_in, \textcolor{keyword}{sizeof} int\_in, 1, f);
770       W[j] = int\_in;
771     \}
772     \hyperlink{classmarked__graph__compressed_ae179a4737e6eab905c18a94d44ef64b7}{part\_graph}.insert(pair<\textcolor{keywordtype}{int}, pair< mpz\_class, vector< int > > >(t, pair<mpz\_class, vector<int>
       >(part\_g, W)));
773   \}
774 \}
\end{DoxyCode}
\mbox{\Hypertarget{classmarked__graph__compressed_a01c67fe4234738db6bb60459515c3ad8}\label{classmarked__graph__compressed_a01c67fe4234738db6bb60459515c3ad8}} 
\index{marked\+\_\+graph\+\_\+compressed@{marked\+\_\+graph\+\_\+compressed}!binary\+\_\+read@{binary\+\_\+read}}
\index{binary\+\_\+read@{binary\+\_\+read}!marked\+\_\+graph\+\_\+compressed@{marked\+\_\+graph\+\_\+compressed}}
\subsubsection{\texorpdfstring{binary\+\_\+read()}{binary\_read()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void marked\+\_\+graph\+\_\+compressed\+::binary\+\_\+read (\begin{DoxyParamCaption}\item[{string}]{s }\end{DoxyParamCaption})}

read the compressed data from a binary file 
\begin{DoxyParams}{Parameters}
{\em s} & string containing the name of the binary file \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
777                                                  \{
778   \hyperlink{classlogger_a9d29b49bd318a719a8e85b59eac54fe0}{logger::current\_depth}++;
779   \hyperlink{classmarked__graph__compressed_af58307bfadcaa4c3ca6dd594c2f9b3a9}{clear}(); \textcolor{comment}{// to make sure nothing is stored inside me before reading}
780   \hyperlink{classibitstream}{ibitstream} inp(s);
781 
782   \textcolor{comment}{// ==== read n, h, delta}
783   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} int\_in; \textcolor{comment}{// auxiliary input integer}
784   \hyperlink{classlogger_a710163deb17bc81f70d53d285b8ac9ac}{logger::add\_entry}(\textcolor{stringliteral}{"n"}, \textcolor{stringliteral}{""});
785   inp >> int\_in; 
786   \hyperlink{classmarked__graph__compressed_a8d841016ddb11cfd33748c8deb6277ba}{n} = int\_in; \textcolor{comment}{// I need to do this, since ibitstream::operator >> gets unsigned int& and the compile can
       not cast int& to unsigned int&}
787   \hyperlink{classlogger_a710163deb17bc81f70d53d285b8ac9ac}{logger::add\_entry}(\textcolor{stringliteral}{"h"}, \textcolor{stringliteral}{""});
788   inp >> int\_in;
789   \hyperlink{classmarked__graph__compressed_af6ff623407b673d08d0cab77b39c2193}{h} = int\_in;
790   \hyperlink{classlogger_a710163deb17bc81f70d53d285b8ac9ac}{logger::add\_entry}(\textcolor{stringliteral}{"delta"}, \textcolor{stringliteral}{""});
791   inp >> int\_in;
792   \hyperlink{classmarked__graph__compressed_a8b2aaac68e9332ddc78d88eb60b323a7}{delta} = int\_in;
793 
794   \textcolor{comment}{//fread(&n, sizeof n, 1, f);}
795   \textcolor{comment}{//fread(&h, sizeof h, 1, f);}
796   \textcolor{comment}{//fread(&delta, sizeof delta, 1, f);}
797 
798   \hyperlink{classlogger_a710163deb17bc81f70d53d285b8ac9ac}{logger::add\_entry}(\textcolor{stringliteral}{"type\_mark"}, \textcolor{stringliteral}{""});
799   \textcolor{comment}{// ===== read type\_mark}
800   \textcolor{comment}{// read number of types}
801   inp >> int\_in;
802   \textcolor{comment}{//fread(&int\_in, sizeof int\_in, 1, f);}
803   \hyperlink{classmarked__graph__compressed_a86b00223525703e973415cbc9c94da68}{type\_mark}.resize(int\_in);
804   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0;i<\hyperlink{classmarked__graph__compressed_a86b00223525703e973415cbc9c94da68}{type\_mark}.size();i++)\{
805     inp >> int\_in;
806     \hyperlink{classmarked__graph__compressed_a86b00223525703e973415cbc9c94da68}{type\_mark}[i] = int\_in;
807     \textcolor{comment}{//fread(&int\_in, sizeof int\_in, 1, f);}
808     \textcolor{comment}{//type\_mark[i] = int\_in;}
809   \}
810 
811   \hyperlink{classlogger_a710163deb17bc81f70d53d285b8ac9ac}{logger::add\_entry}(\textcolor{stringliteral}{"star vertices"}, \textcolor{stringliteral}{""});
812   \textcolor{comment}{// ==== read star\_vertices}
813   \textcolor{comment}{// first, read the frequency.}
814   \hyperlink{classmarked__graph__compressed_a7a4ced4586e2e353f9076bd447df5208}{star\_vertices}.first = vector<int>(2); \textcolor{comment}{// frequency,}
815   \textcolor{comment}{// we read its first index which is number of zeros, and the second is n - the first.}
816   inp >> int\_in;
817   \textcolor{comment}{//fread(&int\_in, sizeof int\_in, 1, f);}
818   \hyperlink{classmarked__graph__compressed_a7a4ced4586e2e353f9076bd447df5208}{star\_vertices}.first[0] = int\_in;
819   \hyperlink{classmarked__graph__compressed_a7a4ced4586e2e353f9076bd447df5208}{star\_vertices}.first[1] = \hyperlink{classmarked__graph__compressed_a8d841016ddb11cfd33748c8deb6277ba}{n} - int\_in;
820 
821   \textcolor{comment}{// the integer representation which is star\_vertices.second}
822   inp >> \hyperlink{classmarked__graph__compressed_a7a4ced4586e2e353f9076bd447df5208}{star\_vertices}.second;
823   \textcolor{comment}{//mpz\_inp\_raw(star\_vertices.second.get\_mpz\_t(), f);}
824 
825   \hyperlink{classlogger_a710163deb17bc81f70d53d285b8ac9ac}{logger::add\_entry}(\textcolor{stringliteral}{"star edges"}, \textcolor{stringliteral}{""});
826 
827   \textcolor{comment}{// ==== read star\_edges}
828 
829   \textcolor{comment}{//int log2n = 0; // the ceiling of log (n+1) in base 2 (which is equal to 1 + the floor of log\_2 n),
       which is the number of bits to encode vertices}
830   \textcolor{comment}{//int n\_copy = n;}
831   \textcolor{comment}{//while(n\_copy > 0)\{}
832   \textcolor{comment}{//n\_copy >>= 1;}
833   \textcolor{comment}{//log2n ++;}
834   \textcolor{comment}{//\}}
835   \textcolor{comment}{//bitset<8*sizeof(int)> B; // a bit stream with maximum length of int to store a vertex index}
836 
837   \textcolor{comment}{//string s;}
838   \textcolor{comment}{//stringstream ss;}
839   \textcolor{comment}{//int sp; // the index of the string s we are studying }
840 
841   \textcolor{comment}{// read the size of star\_edges}
842 
843   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} star\_edges\_size;
844   inp >> star\_edges\_size;
845   \textcolor{comment}{//cerr << " star edges size " << star\_edges\_size << endl;}
846   \textcolor{comment}{//fread(&star\_edges\_size, sizeof star\_edges\_size, 1, f);}
847 
848   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} x, xp; \textcolor{comment}{// edge marks}
849   \textcolor{keywordtype}{int} nu\_star\_vertices = \hyperlink{classmarked__graph__compressed_a7a4ced4586e2e353f9076bd447df5208}{star\_vertices}.first[1];
850   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} nb\_nsv = \hyperlink{bitstream_8cpp_a9dfce6f51e3febb3973aa3b16c2fecb4}{nu\_bits}(nu\_star\_vertices-1); \textcolor{comment}{// defined to chose compression method, see
       below}
851   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} nb\_nb\_nsv = \hyperlink{bitstream_8cpp_a9dfce6f51e3febb3973aa3b16c2fecb4}{nu\_bits}(nb\_nsv); \textcolor{comment}{// defined to chose compression method, see below}
852   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} diff\_threshold = nb\_nsv - nb\_nb\_nsv;
853   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} nb\_diff; \textcolor{comment}{// number of bits in diff}
854 
855 
856   vector<vector<int> > V; \textcolor{comment}{// the list of star edges corresponding to each mark pair}
857   V.resize(nu\_star\_vertices);
858 
859   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} n\_bits = \hyperlink{bitstream_8cpp_a9dfce6f51e3febb3973aa3b16c2fecb4}{nu\_bits}(\hyperlink{classmarked__graph__compressed_a8d841016ddb11cfd33748c8deb6277ba}{n}); \textcolor{comment}{// the number of bits in n, i.e. \(\backslash\)f$1 + \(\backslash\)lfloor \(\backslash\)log\_2 n
       \(\backslash\)rfloor\(\backslash\)f$}
860   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} diff; \textcolor{comment}{// to decode differences between star vertex indices in star edges}
861 
862   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0;i<star\_edges\_size;i++)\{
863 
864     inp >> x;
865     inp >> xp;
866     \textcolor{comment}{//cerr << " x  " << x << " xp " << xp << " i = " << i << endl; }
867     \textcolor{comment}{//fread(&x, sizeof x, 1, f);}
868     \textcolor{comment}{//fread(&xp, sizeof xp, 1, f);}
869   
870     \textcolor{comment}{//s = bit\_string\_read(f);}
871     \textcolor{comment}{//cerr << " read  x " << x << " xp " << xp << " s " << s << endl;}
872     \textcolor{comment}{//sp = 0; // starting from zero }
873     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j=0; j<nu\_star\_vertices; j++)\{ \textcolor{comment}{// }
874       V[j].clear(); \textcolor{comment}{// make it fresh}
875       \textcolor{comment}{//inp.bin\_inter\_decode(V[j], n\_bits); // use binary interpolative decoding}
876       \textcolor{comment}{//cerr << "  jth star vertex j = " << j<< endl; }
877       inp >> int\_in; \textcolor{comment}{// the number of star edges connected to jth star vertex}
878       \textcolor{comment}{//cerr << " number of star edges " << int\_in << endl;}
879       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} k=0; k<int\_in; k++)\{
880         \textcolor{comment}{// read diff}
881         \textcolor{comment}{//cerr << " k " << k << endl;}
882         \textcolor{keywordflow}{if} (inp.read\_bit())\{ \textcolor{comment}{// the flag bit is one, we have used the first method }
883           nb\_diff = inp.read\_bits(nb\_nb\_nsv);
884           diff = 0; \textcolor{comment}{// initialize}
885           \textcolor{keywordflow}{if} (nb\_diff > 1) \textcolor{comment}{// otherwise, reading zero bits is as iff diff = 0 (before adding the leading
       one) this is important when real diff is 1}
886             diff = inp.read\_bits(nb\_diff-1);
887           diff += (1<<(nb\_diff-1)); \textcolor{comment}{// bring the lading bit in diff back }
888         \}\textcolor{keywordflow}{else}\{ \textcolor{comment}{// use the second method to read diff}
889           diff = inp.read\_bits(nb\_nsv);
890         \}
891         \textcolor{comment}{//if (int\_in < 100)}
892         \textcolor{comment}{//  cerr << diff << " ";}
893         \textcolor{comment}{//cerr << " diff " << diff << endl;}
894         \textcolor{keywordflow}{if}(k==0)
895           V[j].push\_back(j+diff);
896         \textcolor{keywordflow}{else}
897           V[j].push\_back(V[j][k-1]+diff);
898       \}
899       \textcolor{comment}{//if (int\_in < 100)}
900       \textcolor{comment}{//  cerr << endl;}
901     \}
902 
903 
904     \hyperlink{classmarked__graph__compressed_a7df5779d313486644132bd816937f532}{star\_edges}.insert(pair< pair<int, int> , vector<vector<int> > > (pair<int, int>(x, xp), V));
905   \}
906 
907   \hyperlink{classlogger_a710163deb17bc81f70d53d285b8ac9ac}{logger::add\_entry}(\textcolor{stringliteral}{"vertex types"}, \textcolor{stringliteral}{""});
908   \textcolor{comment}{// ==== read vertex\_types}
909 
910   \hyperlink{classmarked__graph__compressed_af29f16cbd56583652118eb24a7c233b7}{vtype\_list\_read}(inp);
911 
912   \textcolor{comment}{// // read ver\_type\_list}
913   \textcolor{comment}{// inp >> int\_in;}
914   \textcolor{comment}{// //fread(&int\_in, sizeof int\_in, 1, f); // size of ver\_type\_list}
915   \textcolor{comment}{// ver\_type\_list.resize(int\_in);}
916   \textcolor{comment}{// for (int i=0; i<ver\_type\_list.size();i++)\{}
917   \textcolor{comment}{//   inp >> int\_in;}
918   \textcolor{comment}{//   //fread(&int\_in, sizeof int\_in, 1, f); // size of ver\_type\_list[i]}
919   \textcolor{comment}{//   ver\_type\_list[i].resize(int\_in);}
920 
921   \textcolor{comment}{//   inp >> int\_in;}
922   \textcolor{comment}{//   ver\_type\_list[i][0] = int\_in; // read the vertex mark part}
923 
924   \textcolor{comment}{//   for (int j=0;j<((ver\_type\_list[i].size()-1)/3); j++)\{}
925   \textcolor{comment}{//     // the triple is 3j+1, 3j+2, 3j+3}
926   \textcolor{comment}{//     if (j==0)\{}
927   \textcolor{comment}{//       // the first chunk is written of the form t,t',n-1. The reason we write n-1 is because we know n
       > 0, so it is better to save some bits!}
928   \textcolor{comment}{//       inp >> int\_in;}
929   \textcolor{comment}{//       ver\_type\_list[i][3*j+1] = int\_in;}
930   \textcolor{comment}{//       inp >> int\_in;}
931   \textcolor{comment}{//       ver\_type\_list[i][3*j+2] = int\_in;}
932   \textcolor{comment}{//       inp >> int\_in;}
933   \textcolor{comment}{//       ver\_type\_list[i][3*j+3] = int\_in + 1; // since we had subtracted one during compression}
934   \textcolor{comment}{//     \}else\{}
935   \textcolor{comment}{//       // we know that the list is lexicographically ordered, so the t here is not less than the t is
       the previous chunk, so better to write their difference}
936   \textcolor{comment}{//       inp >> int\_in;}
937   \textcolor{comment}{//       ver\_type\_list[i][3*j+1] = int\_in + ver\_type\_list[i][3*(j-1)+1]; // since we had encoded the
       difference during the compression phasen}
938 
939   \textcolor{comment}{//       // if t\_here is equal to t\_previous, then t'\_here >= t'\_previous, so better to encode their
       difference!}
940   \textcolor{comment}{//       if (ver\_type\_list[i][3*j+1] == ver\_type\_list[i][3*(j-1)+1])\{}
941   \textcolor{comment}{//         inp >> int\_in;}
942   \textcolor{comment}{//         ver\_type\_list[i][3*j+2] = int\_in + ver\_type\_list[i][3*(j-1)+2];}
943   \textcolor{comment}{//       \}else\{}
944   \textcolor{comment}{//         // otherwise, just write t'\_here}
945   \textcolor{comment}{//         inp >> int\_in;}
946   \textcolor{comment}{//         ver\_type\_list[i][3*j+2] = int\_in;}
947   \textcolor{comment}{//       \}}
948   \textcolor{comment}{//       inp >> int\_in;}
949   \textcolor{comment}{//       ver\_type\_list[i][3*j+3]= int\_in + 1; // since we had subtracted one during compression}
950   \textcolor{comment}{//     \}}
951   \textcolor{comment}{//   \}}
952 
953   \textcolor{comment}{//   /* the old way of reading the list}
954   \textcolor{comment}{//   for (int j=0;j<ver\_type\_list[i].size();j++)\{}
955   \textcolor{comment}{//     //fread(&int\_in, sizeof int\_in, 1, f);}
956   \textcolor{comment}{//     inp >> int\_in;}
957   \textcolor{comment}{//     if (j%3 == 0 and j > 0) // we know that the cont part is positive, so no need to add one during
       compression. So during compression, we subtract one to make it nonnegative}
958   \textcolor{comment}{//       int\_in ++;}
959   \textcolor{comment}{//     ver\_type\_list[i][j] = int\_in;}
960   \textcolor{comment}{//   \}}
961   \textcolor{comment}{//   */}
962   \textcolor{comment}{// \}}
963 
964   \textcolor{comment}{// ver\_types}
965   \textcolor{comment}{// ver\_types.first}
966   \textcolor{comment}{// ver\_types.first.size()}
967   inp >> int\_in;
968   \textcolor{comment}{//fread(&int\_in, sizeof int\_in, 1, f);}
969   \hyperlink{classmarked__graph__compressed_af446cc5e23c241a92b76642fd5ebc403}{ver\_types}.first.resize(int\_in);
970   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0;i<\hyperlink{classmarked__graph__compressed_af446cc5e23c241a92b76642fd5ebc403}{ver\_types}.first.size();i++)\{
971     \textcolor{comment}{//fread(&int\_in, sizeof int\_in, 1, f);}
972     inp >> int\_in;
973     \hyperlink{classmarked__graph__compressed_af446cc5e23c241a92b76642fd5ebc403}{ver\_types}.first[i] = int\_in;\textcolor{comment}{// = int\_in;}
974   \}
975   \textcolor{comment}{// ver\_types.second}
976   inp >> \hyperlink{classmarked__graph__compressed_af446cc5e23c241a92b76642fd5ebc403}{ver\_types}.second;
977   \textcolor{comment}{//mpz\_inp\_raw(ver\_types.second.get\_mpz\_t(), f);}
978 
979 
980   \hyperlink{classlogger_a710163deb17bc81f70d53d285b8ac9ac}{logger::add\_entry}(\textcolor{stringliteral}{"partition bipartite graphs"}, \textcolor{stringliteral}{""});
981   \textcolor{comment}{// === part bgraphs}
982   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} part\_bgraph\_size;
983   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} t, tp;
984   pair<int, int> type; 
985   mpz\_class part\_g;
986   inp >> part\_bgraph\_size;
987   \textcolor{comment}{//fread(&part\_bgraph\_size, sizeof part\_bgraph\_size, 1, f);}
988   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0;i<part\_bgraph\_size;i++)\{
989     \textcolor{comment}{// read t, t'}
990     inp >> t;
991     inp >> tp;
992     \textcolor{comment}{//fread(&t, sizeof t, 1, f);}
993     \textcolor{comment}{//fread(&tp, sizeof tp, 1, f);}
994     type = pair<int, int>(t, tp);
995     inp >> part\_g;
996     \textcolor{comment}{//mpz\_inp\_raw(part\_g.get\_mpz\_t(), f);}
997     \hyperlink{classmarked__graph__compressed_a7b3267063fba30b45eb21b3ba4e07536}{part\_bgraph}.insert(pair<pair<int, int>, mpz\_class> (type, part\_g));
998   \}
999 
1000   \hyperlink{classlogger_a710163deb17bc81f70d53d285b8ac9ac}{logger::add\_entry}(\textcolor{stringliteral}{"partition graphs"}, \textcolor{stringliteral}{""});
1001   \textcolor{comment}{// === part graphs}
1002 
1003   \textcolor{comment}{// first, the size}
1004   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} part\_graph\_size;
1005   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} v\_size;
1006   vector<int> W; 
1007   inp >> part\_graph\_size;
1008   \textcolor{comment}{//fread(&part\_graph\_size, sizeof part\_graph\_size, 1, f);}
1009   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0;i<part\_graph\_size; i++)\{
1010     \textcolor{comment}{// first, the type}
1011     inp >> t; 
1012     \textcolor{comment}{//fread(&t, sizeof t, 1, f);}
1013     \textcolor{comment}{// then, the mpz part}
1014     inp >> part\_g;
1015     \textcolor{comment}{//mpz\_inp\_raw(part\_g.get\_mpz\_t(), f);}
1016     \textcolor{comment}{// then, the vector size}
1017     inp >> v\_size;
1018     \textcolor{comment}{//fread(&v\_size, sizeof v\_size, 1, f);}
1019     W.resize(v\_size);
1020     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j=0;j<v\_size; j++)\{
1021       \textcolor{comment}{//fread(&int\_in, sizeof int\_in, 1, f);}
1022       inp >> int\_in;
1023       W[j] = int\_in; \textcolor{comment}{//= int\_in;}
1024     \}
1025     \hyperlink{classmarked__graph__compressed_ae179a4737e6eab905c18a94d44ef64b7}{part\_graph}.insert(pair<\textcolor{keywordtype}{int}, pair< mpz\_class, vector< int > > >(t, pair<mpz\_class, vector<int>
       >(part\_g, W)));
1026   \}
1027   inp.close();
1028   \hyperlink{classlogger_a9d29b49bd318a719a8e85b59eac54fe0}{logger::current\_depth}--;
1029 \}
\end{DoxyCode}
\mbox{\Hypertarget{classmarked__graph__compressed_ab9cdb7fc43badd58fb5202f74ffac723}\label{classmarked__graph__compressed_ab9cdb7fc43badd58fb5202f74ffac723}} 
\index{marked\+\_\+graph\+\_\+compressed@{marked\+\_\+graph\+\_\+compressed}!binary\+\_\+write@{binary\+\_\+write}}
\index{binary\+\_\+write@{binary\+\_\+write}!marked\+\_\+graph\+\_\+compressed@{marked\+\_\+graph\+\_\+compressed}}
\subsubsection{\texorpdfstring{binary\+\_\+write()}{binary\_write()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void marked\+\_\+graph\+\_\+compressed\+::binary\+\_\+write (\begin{DoxyParamCaption}\item[{F\+I\+LE $\ast$}]{f }\end{DoxyParamCaption})}



writes the compressed data to a binary file 


\begin{DoxyParams}{Parameters}
{\em f} & a {\ttfamily F\+I\+L\+E$\ast$} object which is the address of the binary file to write \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
20                                                  \{
21 
22   vector<pair<string, int> > space\_log; \textcolor{comment}{// stores the number of bits used to store each category. The
       string part is description of the category, and the int part is the number of bits of output used to express that
       part.}
23 
24   \textcolor{keywordtype}{int} output\_bits; \textcolor{comment}{// the number of bits in the output corresponding to the current category under
       investigation, to be zeroed at each step.}
25 
26   \hyperlink{classlogger_a9d29b49bd318a719a8e85b59eac54fe0}{logger::current\_depth}++;
27   \textcolor{comment}{// ==== write n, h, delta}
28   output\_bits = 0;
29   \hyperlink{classlogger_a710163deb17bc81f70d53d285b8ac9ac}{logger::add\_entry}(\textcolor{stringliteral}{"n"}, \textcolor{stringliteral}{""});
30   fwrite(&\hyperlink{classmarked__graph__compressed_a8d841016ddb11cfd33748c8deb6277ba}{n}, \textcolor{keyword}{sizeof} \hyperlink{classmarked__graph__compressed_a8d841016ddb11cfd33748c8deb6277ba}{n}, 1, f);
31   output\_bits += \textcolor{keyword}{sizeof} \hyperlink{classmarked__graph__compressed_a8d841016ddb11cfd33748c8deb6277ba}{n};
32 
33   \hyperlink{classlogger_a710163deb17bc81f70d53d285b8ac9ac}{logger::add\_entry}(\textcolor{stringliteral}{"h"}, \textcolor{stringliteral}{""});
34   fwrite(&\hyperlink{classmarked__graph__compressed_af6ff623407b673d08d0cab77b39c2193}{h}, \textcolor{keyword}{sizeof} \hyperlink{classmarked__graph__compressed_af6ff623407b673d08d0cab77b39c2193}{h}, 1, f);
35   output\_bits += \textcolor{keyword}{sizeof} \hyperlink{classmarked__graph__compressed_af6ff623407b673d08d0cab77b39c2193}{h};
36 
37   \hyperlink{classlogger_a710163deb17bc81f70d53d285b8ac9ac}{logger::add\_entry}(\textcolor{stringliteral}{"delta"}, \textcolor{stringliteral}{""});
38   fwrite(&\hyperlink{classmarked__graph__compressed_a8b2aaac68e9332ddc78d88eb60b323a7}{delta}, \textcolor{keyword}{sizeof} \hyperlink{classmarked__graph__compressed_a8b2aaac68e9332ddc78d88eb60b323a7}{delta}, 1, f);
39   output\_bits += \textcolor{keyword}{sizeof} \hyperlink{classmarked__graph__compressed_a8b2aaac68e9332ddc78d88eb60b323a7}{delta};
40 
41   space\_log.push\_back(pair<string, int> (\textcolor{stringliteral}{"n, h, delta"}, output\_bits));
42 
43   \hyperlink{classlogger_a710163deb17bc81f70d53d285b8ac9ac}{logger::add\_entry}(\textcolor{stringliteral}{"type\_mark"}, \textcolor{stringliteral}{""});
44   output\_bits = 0;
45 
46   \textcolor{keywordtype}{int} int\_out; \textcolor{comment}{// auxiliary variable, an integer value to be written to output}
47   \textcolor{comment}{// ==== write type\_mark}
48   \textcolor{comment}{// first, the number of types}
49   int\_out = \hyperlink{classmarked__graph__compressed_a86b00223525703e973415cbc9c94da68}{type\_mark}.size();
50   fwrite(&int\_out, \textcolor{keyword}{sizeof} int\_out, 1, f);
51   output\_bits += \textcolor{keyword}{sizeof} int\_out;
52   \textcolor{comment}{// then, marks one by one}
53   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0;i<\hyperlink{classmarked__graph__compressed_a86b00223525703e973415cbc9c94da68}{type\_mark}.size();i++)\{
54     int\_out = \hyperlink{classmarked__graph__compressed_a86b00223525703e973415cbc9c94da68}{type\_mark}[i];
55     fwrite(&int\_out, \textcolor{keyword}{sizeof} int\_out, 1, f);
56     output\_bits += \textcolor{keyword}{sizeof} int\_out;
57   \}
58 
59   space\_log.push\_back(pair<string, int>(\textcolor{stringliteral}{"type mark"}, output\_bits));
60 
61   \hyperlink{classlogger_a710163deb17bc81f70d53d285b8ac9ac}{logger::add\_entry}(\textcolor{stringliteral}{"star\_vertices"}, \textcolor{stringliteral}{""});
62   output\_bits = 0;
63   \textcolor{comment}{// ==== write star vertices}
64   \textcolor{comment}{// first, write the frequency, note that star\_vertices.first is a vector of size 2 with the first entry
       being the number of zeros, and the second one the number of ones, so it enough to write only one of them}
65   int\_out = \hyperlink{classmarked__graph__compressed_a7a4ced4586e2e353f9076bd447df5208}{star\_vertices}.first[0];
66   fwrite(&int\_out, \textcolor{keyword}{sizeof} int\_out, 1, f);
67   output\_bits += \textcolor{keyword}{sizeof} int\_out;
68 
69   \textcolor{comment}{// then, we write the integer representation star\_vertices.second}
70   output\_bits +=  mpz\_out\_raw(f, \hyperlink{classmarked__graph__compressed_a7a4ced4586e2e353f9076bd447df5208}{star\_vertices}.second.get\_mpz\_t()); \textcolor{comment}{// mpz\_out\_raw returns the
       number of bytes written to the output}
71 
72   space\_log.push\_back(pair<string, int> (\textcolor{stringliteral}{"star vertices"}, output\_bits));
73 
74   \hyperlink{classlogger_a710163deb17bc81f70d53d285b8ac9ac}{logger::add\_entry}(\textcolor{stringliteral}{"star\_edges"}, \textcolor{stringliteral}{""});
75   \textcolor{comment}{// ==== write star edges}
76   output\_bits = 0;
77   \textcolor{keywordtype}{int} log2n = 0; \textcolor{comment}{// the ceiling of log (n+1) in base 2 (which is equal to 1 + the floor of log\_2 n), which
       is the number of bits to encode vertices}
78   \textcolor{keywordtype}{int} n\_copy = \hyperlink{classmarked__graph__compressed_a8d841016ddb11cfd33748c8deb6277ba}{n};
79   \textcolor{keywordflow}{while}(n\_copy > 0)\{
80     n\_copy >>= 1;
81     log2n ++;
82   \}
83   \textcolor{comment}{//cerr << " log2n " << log2n << endl;}
84   bitset<8*sizeof(int)> B; \textcolor{comment}{// a bit stream with maximum length of int to store a vertex index}
85 
86   map<pair<int, int>, vector<vector<int> > >::iterator it;
87   \textcolor{keywordtype}{int} x, xp;
88   \textcolor{keywordtype}{string} s; \textcolor{comment}{// the bit stream}
89 
90   \textcolor{comment}{// first, write the size of star\_edges so that the decoder knows how many blocks are coming}
91   int\_out = \hyperlink{classmarked__graph__compressed_a7df5779d313486644132bd816937f532}{star\_edges}.size();
92   fwrite(&int\_out, \textcolor{keyword}{sizeof} int\_out, 1, f);
93   output\_bits += \textcolor{keyword}{sizeof} int\_out;
94 
95   \textcolor{keywordtype}{int} nu\_star\_edges = 0; \textcolor{comment}{// number of star edges }
96   \textcolor{keywordflow}{for} (it = \hyperlink{classmarked__graph__compressed_a7df5779d313486644132bd816937f532}{star\_edges}.begin(); it!= \hyperlink{classmarked__graph__compressed_a7df5779d313486644132bd816937f532}{star\_edges}.end(); it++)\{
97     x = it->first.first;
98     xp = it->first.second;
99     \textcolor{comment}{//write x and xp}
100     fwrite(&x, \textcolor{keyword}{sizeof} x, 1, f);
101     fwrite(&xp, \textcolor{keyword}{sizeof} xp, 1, f);
102     output\_bits += \textcolor{keyword}{sizeof} x;
103     output\_bits += \textcolor{keyword}{sizeof} xp;
104     s = \textcolor{stringliteral}{""};
105     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0;i<it->second.size();i++)\{
106       \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} j=0;j<it->second[i].size();j++)\{
107         s += \textcolor{stringliteral}{"1"};
108         B = it->second[i][j]; \textcolor{comment}{// convert the index of the other endpoint to binary}
109         s += B.to\_string().substr(8*\textcolor{keyword}{sizeof}(\textcolor{keywordtype}{int}) - log2n, log2n); \textcolor{comment}{// take only log2n many bits of the
       representation (and this should be taken from the least significant bits)}
110         nu\_star\_edges ++;
111       \}
112       s += \textcolor{stringliteral}{"0"}; \textcolor{comment}{// to indicate that the neighbor list of this vertex is over now}
113     \}
114     \textcolor{comment}{//cerr << " write  x " << x << " xp " << xp << " s " << s << endl;}
115     \textcolor{comment}{//for (int i=0;i<it->second.size();i++)\{}
116     \textcolor{comment}{//  for (int j=0;j<it->second[i].size();j++)\{}
117     \textcolor{comment}{//    cerr << " , " << it->second[i][j];}
118     \textcolor{comment}{//  \}}
119     \textcolor{comment}{//  cerr << endl;}
120     \textcolor{comment}{//\}}
121     output\_bits += \hyperlink{compression__helper_8cpp_a9a2fbdf1fe0e38f631e7e242a819883b}{bit\_string\_write}(f, s); \textcolor{comment}{// write this bitstream to the output}
122   \}
123 
124   space\_log.push\_back(pair<string, int> (\textcolor{stringliteral}{"star edges"}, output\_bits));
125 
126 
127   \hyperlink{classlogger_a710163deb17bc81f70d53d285b8ac9ac}{logger::add\_entry}(\textcolor{stringliteral}{"vertex types"}, \textcolor{stringliteral}{""});
128   output\_bits = 0;
129 
130   \textcolor{comment}{// ==== write vertex types}
131 
132   \textcolor{comment}{// first, we need vertex types list (ver\_type\_list)}
133   \textcolor{comment}{// size of ver\_type\_list}
134   int\_out = \hyperlink{classmarked__graph__compressed_af2e3e55223d436628a02758dfae88493}{ver\_type\_list}.size();
135   fwrite(&int\_out, \textcolor{keyword}{sizeof} int\_out, 1, f);
136   output\_bits += \textcolor{keyword}{sizeof} int\_out;
137 
138   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0;i<\hyperlink{classmarked__graph__compressed_af2e3e55223d436628a02758dfae88493}{ver\_type\_list}.size();i++)\{
139     int\_out = \hyperlink{classmarked__graph__compressed_af2e3e55223d436628a02758dfae88493}{ver\_type\_list}[i].size();
140     fwrite(&int\_out, \textcolor{keyword}{sizeof} int\_out, 1, f);
141     output\_bits += \textcolor{keyword}{sizeof} int\_out;
142 
143     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j=0;j<\hyperlink{classmarked__graph__compressed_af2e3e55223d436628a02758dfae88493}{ver\_type\_list}[i].size();j++)\{
144       int\_out = \hyperlink{classmarked__graph__compressed_af2e3e55223d436628a02758dfae88493}{ver\_type\_list}[i][j];
145       fwrite(&int\_out, \textcolor{keyword}{sizeof} int\_out, 1, f);
146       output\_bits += \textcolor{keyword}{sizeof} int\_out;
147     \}
148   \}
149   space\_log.push\_back(pair<string, int>(\textcolor{stringliteral}{"vertex type list"}, output\_bits));
150   output\_bits = 0;
151   
152   \textcolor{comment}{// then, write ver\_types}
153 
154   \textcolor{comment}{// ver\_types.first}
155   \textcolor{comment}{// ver\_types.first.size():}
156   int\_out = \hyperlink{classmarked__graph__compressed_af446cc5e23c241a92b76642fd5ebc403}{ver\_types}.first.size();
157   fwrite(&int\_out, \textcolor{keyword}{sizeof} int\_out, 1, f);
158   output\_bits += \textcolor{keyword}{sizeof} int\_out;
159 
160   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i =0;i<\hyperlink{classmarked__graph__compressed_af446cc5e23c241a92b76642fd5ebc403}{ver\_types}.first.size(); i++)\{
161     int\_out = \hyperlink{classmarked__graph__compressed_af446cc5e23c241a92b76642fd5ebc403}{ver\_types}.first[i];
162     fwrite(&int\_out, \textcolor{keyword}{sizeof} int\_out, 1, f);
163     output\_bits += \textcolor{keyword}{sizeof} int\_out;
164   \}
165   \textcolor{comment}{// ver\_types.second}
166   output\_bits += mpz\_out\_raw(f, \hyperlink{classmarked__graph__compressed_af446cc5e23c241a92b76642fd5ebc403}{ver\_types}.second.get\_mpz\_t());
167 
168   space\_log.push\_back(pair<string, int> (\textcolor{stringliteral}{"vertex types"}, output\_bits));
169 
170   \hyperlink{classlogger_a710163deb17bc81f70d53d285b8ac9ac}{logger::add\_entry}(\textcolor{stringliteral}{"partition bipartite graphs"}, \textcolor{stringliteral}{""});
171   
172 
173   \textcolor{comment}{// ==== part bgraphs}
174   output\_bits = 0;
175 
176   \textcolor{comment}{// part\_bgraphs.size}
177   int\_out = \hyperlink{classmarked__graph__compressed_a7b3267063fba30b45eb21b3ba4e07536}{part\_bgraph}.size();
178   fwrite(&int\_out, \textcolor{keyword}{sizeof} int\_out, 1, f);
179   output\_bits += \textcolor{keyword}{sizeof} int\_out;
180 
181   map<pair<int, int>, mpz\_class>::iterator it2;
182   \textcolor{keywordflow}{if} (\hyperlink{classlogger_a26812b5ba03f130e8dae3446d5fc032f}{logger::stat})\{
183     *\hyperlink{classlogger_a7db37821f875f2ba3540980b355779f5}{logger::stat\_stream} << \textcolor{stringliteral}{" ==== statistics ==== "} << endl;
184     *\hyperlink{classlogger_a7db37821f875f2ba3540980b355779f5}{logger::stat\_stream} << \textcolor{stringliteral}{" n:                "} << \hyperlink{classmarked__graph__compressed_a8d841016ddb11cfd33748c8deb6277ba}{n} << endl;
185     *\hyperlink{classlogger_a7db37821f875f2ba3540980b355779f5}{logger::stat\_stream} << \textcolor{stringliteral}{" h:                "} << \hyperlink{classmarked__graph__compressed_af6ff623407b673d08d0cab77b39c2193}{h} << endl;
186     *\hyperlink{classlogger_a7db37821f875f2ba3540980b355779f5}{logger::stat\_stream} << \textcolor{stringliteral}{" delta:            "} << \hyperlink{classmarked__graph__compressed_a8b2aaac68e9332ddc78d88eb60b323a7}{delta} << endl;
187     *\hyperlink{classlogger_a7db37821f875f2ba3540980b355779f5}{logger::stat\_stream} << \textcolor{stringliteral}{" No. edge types    "} << 
      \hyperlink{classmarked__graph__compressed_a86b00223525703e973415cbc9c94da68}{type\_mark}.size() << endl;
188     *\hyperlink{classlogger_a7db37821f875f2ba3540980b355779f5}{logger::stat\_stream} << \textcolor{stringliteral}{" No. vertex types  "} << 
      \hyperlink{classmarked__graph__compressed_af2e3e55223d436628a02758dfae88493}{ver\_type\_list}.size() << endl;
189     *\hyperlink{classlogger_a7db37821f875f2ba3540980b355779f5}{logger::stat\_stream} << \textcolor{stringliteral}{" No. * vertices    "} << \hyperlink{classmarked__graph__compressed_a8d841016ddb11cfd33748c8deb6277ba}{n} - 
      \hyperlink{classmarked__graph__compressed_a7a4ced4586e2e353f9076bd447df5208}{star\_vertices}.first[0] << endl;
190     *\hyperlink{classlogger_a7db37821f875f2ba3540980b355779f5}{logger::stat\_stream} << \textcolor{stringliteral}{" No. * edges       "} << nu\_star\_edges << endl;
191     *\hyperlink{classlogger_a7db37821f875f2ba3540980b355779f5}{logger::stat\_stream} << \textcolor{stringliteral}{" No. part bgraphs  "} << 
      \hyperlink{classmarked__graph__compressed_a7b3267063fba30b45eb21b3ba4e07536}{part\_bgraph}.size() << endl;
192     *\hyperlink{classlogger_a7db37821f875f2ba3540980b355779f5}{logger::stat\_stream} << \textcolor{stringliteral}{" No. part graphs   "} << 
      \hyperlink{classmarked__graph__compressed_ae179a4737e6eab905c18a94d44ef64b7}{part\_graph}.size() << endl;
193   \}
194 
195   \textcolor{keywordflow}{for} (it2 = \hyperlink{classmarked__graph__compressed_a7b3267063fba30b45eb21b3ba4e07536}{part\_bgraph}.begin(); it2 != \hyperlink{classmarked__graph__compressed_a7b3267063fba30b45eb21b3ba4e07536}{part\_bgraph}.end(); it2++)\{
196     \textcolor{comment}{// first, write t, t'}
197     int\_out = it2->first.first;
198     fwrite(&int\_out, \textcolor{keyword}{sizeof} int\_out, 1, f);
199     output\_bits += \textcolor{keyword}{sizeof} int\_out;
200     int\_out = it2->first.second;
201     fwrite(&int\_out, \textcolor{keyword}{sizeof} int\_out, 1, f);
202     output\_bits += \textcolor{keyword}{sizeof} int\_out;
203     \textcolor{comment}{// then, the compressed integer}
204     output\_bits += mpz\_out\_raw(f, it2->second.get\_mpz\_t());
205   \}
206 
207   space\_log.push\_back(pair<string, int> (\textcolor{stringliteral}{"partition bipartite graphs"}, output\_bits));
208 
209   \hyperlink{classlogger_a710163deb17bc81f70d53d285b8ac9ac}{logger::add\_entry}(\textcolor{stringliteral}{"partition graphs"}, \textcolor{stringliteral}{""});
210   output\_bits = 0;
211   \textcolor{comment}{// === part graphs}
212 
213   \textcolor{comment}{// part\_graph.size}
214   int\_out = \hyperlink{classmarked__graph__compressed_ae179a4737e6eab905c18a94d44ef64b7}{part\_graph}.size();
215   fwrite(&int\_out, \textcolor{keyword}{sizeof} int\_out, 1, f);
216   output\_bits += \textcolor{keyword}{sizeof} int\_out;
217 
218   map< int, pair< mpz\_class, vector< int > > >::iterator it3;
219   \textcolor{keywordflow}{for} (it3 = \hyperlink{classmarked__graph__compressed_ae179a4737e6eab905c18a94d44ef64b7}{part\_graph}.begin(); it3 != \hyperlink{classmarked__graph__compressed_ae179a4737e6eab905c18a94d44ef64b7}{part\_graph}.end(); it3++)\{
220     int\_out = it3->first; \textcolor{comment}{// the type}
221     fwrite(&int\_out, \textcolor{keyword}{sizeof} int\_out, 1, f);
222     output\_bits += \textcolor{keyword}{sizeof} int\_out;
223 
224     \textcolor{comment}{// the mpz part}
225     output\_bits += mpz\_out\_raw(f, it3->second.first.get\_mpz\_t());
226     \textcolor{comment}{// the vector part}
227     \textcolor{comment}{// first its size}
228     int\_out = it3->second.second.size();
229     fwrite(&int\_out, \textcolor{keyword}{sizeof} int\_out, 1, f);
230     output\_bits += \textcolor{keyword}{sizeof} int\_out;
231     \textcolor{comment}{// then element by element}
232     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} j=0;j<it3->second.second.size();j++)\{
233       int\_out = it3->second.second[j];
234       fwrite(&int\_out, \textcolor{keyword}{sizeof} int\_out, 1, f);
235       output\_bits += \textcolor{keyword}{sizeof} int\_out;
236     \}
237   \}
238   space\_log.push\_back(pair<string, int>(\textcolor{stringliteral}{"partition graphs"}, output\_bits));
239 
240 
241   \textcolor{keywordflow}{if} (\hyperlink{classlogger_a26812b5ba03f130e8dae3446d5fc032f}{logger::stat})\{
242     *\hyperlink{classlogger_a7db37821f875f2ba3540980b355779f5}{logger::stat\_stream} << endl << endl;
243     *\hyperlink{classlogger_a7db37821f875f2ba3540980b355779f5}{logger::stat\_stream} << \textcolor{stringliteral}{" Number of bytes used for each part "} << endl;
244     *\hyperlink{classlogger_a7db37821f875f2ba3540980b355779f5}{logger::stat\_stream} << \textcolor{stringliteral}{" ---------------------------------- "} << endl << endl;
245 
246     \textcolor{keywordtype}{int} total\_bytes = 0;
247     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0; i < space\_log.size(); i++)
248       total\_bytes += space\_log[i].second;
249 
250     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0; i < space\_log.size(); i++)\{
251       *\hyperlink{classlogger_a7db37821f875f2ba3540980b355779f5}{logger::stat\_stream} << space\_log[i].first << \textcolor{stringliteral}{" -> "}  << space\_log[i].second << \textcolor{stringliteral}{"
       ( "} << float(100) * float(space\_log[i].second) / float(total\_bytes) << \textcolor{stringliteral}{" % "} << endl;
252     \}
253 
254     *\hyperlink{classlogger_a7db37821f875f2ba3540980b355779f5}{logger::stat\_stream} << \textcolor{stringliteral}{" Total number of bytes wrote to the output = "} << 
      total\_bytes << endl;
255   \}
256   \hyperlink{classlogger_a9d29b49bd318a719a8e85b59eac54fe0}{logger::current\_depth}--;
257 \}
\end{DoxyCode}
\mbox{\Hypertarget{classmarked__graph__compressed_a13ab09e4b399f179ec91746ae2b8b38c}\label{classmarked__graph__compressed_a13ab09e4b399f179ec91746ae2b8b38c}} 
\index{marked\+\_\+graph\+\_\+compressed@{marked\+\_\+graph\+\_\+compressed}!binary\+\_\+write@{binary\+\_\+write}}
\index{binary\+\_\+write@{binary\+\_\+write}!marked\+\_\+graph\+\_\+compressed@{marked\+\_\+graph\+\_\+compressed}}
\subsubsection{\texorpdfstring{binary\+\_\+write()}{binary\_write()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void marked\+\_\+graph\+\_\+compressed\+::binary\+\_\+write (\begin{DoxyParamCaption}\item[{string}]{s }\end{DoxyParamCaption})}

writes the compressed data to a binary file 
\begin{DoxyParams}{Parameters}
{\em s} & string containing the name of the binary file \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
261                                                   \{
262   
263   \hyperlink{classobitstream}{obitstream} oup(s);
264 
265   vector<pair<string, int> > space\_log; \textcolor{comment}{// stores the number of bits used to store each category. The
       string part is description of the category, and the int part is the number of bits of output used to express that
       part.}
266 
267   \textcolor{comment}{//int output\_bits; // the number of bits in the output corresponding to the current category under
       investigation, to be zeroed at each step.}
268   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} chunks = 0; \textcolor{comment}{// number of chunks written to the output. Each chunk is sizeof(unsigned int) =
       32 bits long}
269   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} chunks\_new =0; \textcolor{comment}{// to take the difference in each step}
270 
271   \hyperlink{classlogger_a9d29b49bd318a719a8e85b59eac54fe0}{logger::current\_depth}++;
272   \textcolor{comment}{// ==== write n, h, delta}
273   \textcolor{comment}{//output\_bits = 0;}
274   \hyperlink{classlogger_a710163deb17bc81f70d53d285b8ac9ac}{logger::add\_entry}(\textcolor{stringliteral}{"n"}, \textcolor{stringliteral}{""});
275   oup << \hyperlink{classmarked__graph__compressed_a8d841016ddb11cfd33748c8deb6277ba}{n}; \textcolor{comment}{//fwrite(&n, sizeof n, 1, f);}
276   \textcolor{comment}{//output\_bits += sizeof n;}
277 
278   \hyperlink{classlogger_a710163deb17bc81f70d53d285b8ac9ac}{logger::add\_entry}(\textcolor{stringliteral}{"h"}, \textcolor{stringliteral}{""});
279   oup << \hyperlink{classmarked__graph__compressed_af6ff623407b673d08d0cab77b39c2193}{h}; \textcolor{comment}{//fwrite(&h, sizeof h, 1, f);}
280   \textcolor{comment}{//output\_bits += sizeof h;}
281 
282   \hyperlink{classlogger_a710163deb17bc81f70d53d285b8ac9ac}{logger::add\_entry}(\textcolor{stringliteral}{"delta"}, \textcolor{stringliteral}{""});
283   oup << \hyperlink{classmarked__graph__compressed_a8b2aaac68e9332ddc78d88eb60b323a7}{delta}; \textcolor{comment}{//fwrite(&delta, sizeof delta, 1, f);}
284   \textcolor{comment}{//output\_bits += sizeof delta;}
285 
286   chunks\_new = oup.chunks();
287   space\_log.push\_back(pair<string, int> (\textcolor{stringliteral}{"n, h, delta"}, chunks\_new - chunks));
288   chunks = chunks\_new;
289 
290   \hyperlink{classlogger_a710163deb17bc81f70d53d285b8ac9ac}{logger::add\_entry}(\textcolor{stringliteral}{"type\_mark"}, \textcolor{stringliteral}{""});
291   \textcolor{comment}{//output\_bits = 0;}
292 
293   \textcolor{keywordtype}{int} int\_out; \textcolor{comment}{// auxiliary variable, an integer value to be written to output}
294   \textcolor{comment}{// ==== write type\_mark}
295   \textcolor{comment}{// first, the number of types}
296   oup <<  \hyperlink{classmarked__graph__compressed_a86b00223525703e973415cbc9c94da68}{type\_mark}.size();
297   \textcolor{comment}{//fwrite(&int\_out, sizeof int\_out, 1, f);}
298   \textcolor{comment}{//output\_bits += sizeof int\_out;}
299   \textcolor{comment}{// then, marks one by one}
300   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0;i<\hyperlink{classmarked__graph__compressed_a86b00223525703e973415cbc9c94da68}{type\_mark}.size();i++)\{
301     oup <<  \hyperlink{classmarked__graph__compressed_a86b00223525703e973415cbc9c94da68}{type\_mark}[i];
302     \textcolor{comment}{//fwrite(&int\_out, sizeof int\_out, 1, f);}
303     \textcolor{comment}{//output\_bits += sizeof int\_out;}
304   \}
305 
306   chunks\_new = oup.chunks();
307   space\_log.push\_back(pair<string, int>(\textcolor{stringliteral}{"type mark"}, chunks\_new - chunks));
308   chunks = chunks\_new;
309 
310   \hyperlink{classlogger_a710163deb17bc81f70d53d285b8ac9ac}{logger::add\_entry}(\textcolor{stringliteral}{"star\_vertices"}, \textcolor{stringliteral}{""});
311   \textcolor{comment}{//output\_bits = 0;}
312   \textcolor{comment}{// ==== write star vertices}
313   \textcolor{comment}{// first, write the frequency, note that star\_vertices.first is a vector of size 2 with the first entry
       being the number of zeros, and the second one the number of ones, so it enough to write only one of them}
314   oup << \hyperlink{classmarked__graph__compressed_a7a4ced4586e2e353f9076bd447df5208}{star\_vertices}.first[0];
315   \textcolor{comment}{//fwrite(&int\_out, sizeof int\_out, 1, f);}
316   \textcolor{comment}{//output\_bits += sizeof int\_out;}
317 
318   \textcolor{comment}{// then, we write the integer representation star\_vertices.second}
319   oup << \hyperlink{classmarked__graph__compressed_a7a4ced4586e2e353f9076bd447df5208}{star\_vertices}.second;
320   \textcolor{comment}{//output\_bits +=  mpz\_out\_raw(f, star\_vertices.second.get\_mpz\_t()); // mpz\_out\_raw returns the number of
       bytes written to the output}
321 
322   chunks\_new = oup.chunks();
323   space\_log.push\_back(pair<string, int> (\textcolor{stringliteral}{"star vertices"}, chunks\_new - chunks));
324   chunks = oup.chunks();
325 
326   \hyperlink{classlogger_a710163deb17bc81f70d53d285b8ac9ac}{logger::add\_entry}(\textcolor{stringliteral}{"star\_edges"}, \textcolor{stringliteral}{""});
327   \textcolor{comment}{// ==== write star edges}
328   \textcolor{comment}{//output\_bits = 0;}
329   \textcolor{comment}{//int log2n = 0; // the ceiling of log (n+1) in base 2 (which is equal to 1 + the floor of log\_2 n),
       which is the number of bits to encode vertices}
330   \textcolor{comment}{//int n\_copy = n;}
331   \textcolor{comment}{//while(n\_copy > 0)\{}
332   \textcolor{comment}{//n\_copy >>= 1;}
333   \textcolor{comment}{//log2n ++;}
334   \textcolor{comment}{//\}}
335   \textcolor{comment}{//cerr << " log2n " << log2n << endl;}
336   \textcolor{comment}{//bitset<8*sizeof(int)> B; // a bit stream with maximum length of int to store a vertex index}
337 
338   map<pair<int, int>, vector<vector<int> > >::iterator it;
339   \textcolor{keywordtype}{int} x, xp;
340   \textcolor{comment}{//string s; // the bit stream}
341 
342   \textcolor{comment}{// first, write the size of star\_edges so that the decoder knows how many blocks are coming}
343   oup << \hyperlink{classmarked__graph__compressed_a7df5779d313486644132bd816937f532}{star\_edges}.size();
344   \textcolor{comment}{//cerr << " star edges size " << star\_edges.size() << endl;}
345   \textcolor{comment}{//fwrite(&int\_out, sizeof int\_out, 1, f);}
346   \textcolor{comment}{//output\_bits += sizeof int\_out;}
347 
348   \textcolor{keywordtype}{int} nu\_star\_edges = 0; \textcolor{comment}{// number of star edges}
349   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} n\_bits = \hyperlink{bitstream_8cpp_a9dfce6f51e3febb3973aa3b16c2fecb4}{nu\_bits}(n); \textcolor{comment}{// the number of bits in n, i.e. \(\backslash\)f$1 + \(\backslash\)lfloor \(\backslash\)log\_2 n
       \(\backslash\)rfloor\(\backslash\)f$}
350   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} diff; \textcolor{comment}{// the difference for differential coding}
351   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} nu\_star\_vertices = n - \hyperlink{classmarked__graph__compressed_a7a4ced4586e2e353f9076bd447df5208}{star\_vertices}.first[0]; \textcolor{comment}{// number of star vertices}
352   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} nb\_nsv = \hyperlink{bitstream_8cpp_a9dfce6f51e3febb3973aa3b16c2fecb4}{nu\_bits}(nu\_star\_vertices-1); \textcolor{comment}{// defined to chose compression method, see
       below }
353   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} nb\_nb\_nsv = \hyperlink{bitstream_8cpp_a9dfce6f51e3febb3973aa3b16c2fecb4}{nu\_bits}(nb\_nsv); \textcolor{comment}{// defined to chose compression method, see below }
354   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} diff\_threshold = nb\_nsv - nb\_nb\_nsv;
355   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} nb\_diff; \textcolor{comment}{// number of bits in diff}
356 
357   map<int, int> deg\_map;
358 
359   \textcolor{keywordflow}{if} (\hyperlink{classlogger_a26812b5ba03f130e8dae3446d5fc032f}{logger::stat})\{
360     *\hyperlink{classlogger_a7db37821f875f2ba3540980b355779f5}{logger::stat\_stream} << \textcolor{stringliteral}{" * degree stat: "} << endl;
361     *\hyperlink{classlogger_a7db37821f875f2ba3540980b355779f5}{logger::stat\_stream} << \textcolor{stringliteral}{" -------------- "} << endl;
362   \}
363 
364   \textcolor{keywordflow}{for} (it = \hyperlink{classmarked__graph__compressed_a7df5779d313486644132bd816937f532}{star\_edges}.begin(); it!= \hyperlink{classmarked__graph__compressed_a7df5779d313486644132bd816937f532}{star\_edges}.end(); it++)\{
365 
366     x = it->first.first;
367     xp = it->first.second;
368     \textcolor{comment}{//cerr << " x " << x << " xp " << xp << endl;}
369     \textcolor{comment}{//write x and xp}
370 
371     oup << x;
372     oup << xp;
373 
374     deg\_map.clear();
375 
376     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0;i<it->second.size();i++)\{
377       \textcolor{comment}{//cerr << " star vertex " << i << endl;}
378       \textcolor{comment}{//oup.bin\_inter\_code(it->second[i], n\_bits);}
379       oup << it->second[i].size(); \textcolor{comment}{// how many star edges are going next}
380       deg\_map[it->second[i].size()] ++;
381       \textcolor{comment}{//cout << " i " << i << endl;}
382       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j=0;j<it->second[i].size();j++)\{
383         
384         \textcolor{comment}{//cout << " j " << j << " -> " << it->second[i][j] << endl;}
385         \textcolor{keywordflow}{if} (j==0)
386           diff = it->second[i][j] - i;
387         \textcolor{keywordflow}{else}
388           diff = it->second[i][j] - it->second[i][j-1];
389         \textcolor{comment}{//if (it->second[i].size() < 100)}
390         \textcolor{comment}{//  cerr << diff << " ";}
391         \textcolor{comment}{//cerr << " diff " << diff << endl;}
392         \textcolor{comment}{// diff is bounded by the number of star vertices}
393         \textcolor{comment}{// we can either encode diff by a modification of Elias delta, using the extra assumption that 1 <=
       diff <= number of star vertices - 1}
394         \textcolor{comment}{// number of star vertices = n - star\_vertices.first[0] lets call it nu\_star\_vertices defined above
       before the loop}
395         \textcolor{comment}{// with this extra assumption in Elias delta, we do not use the unary part of the code and store
       nu\_bits(diff) }
396         \textcolor{comment}{// using nu\_bits(nu\_bits(nu\_star\_vertices-1))}
397         \textcolor{comment}{// if we chose this method of compression, we use nu\_bits(nu\_bits(nu\_star\_vertices-1)) +
       nu\_bits(diff)}
398         \textcolor{comment}{// if we only use diff <= nu\_star\_vertices - 1, we spend nu\_bits(nu\_star\_vertices-1) bits}
399         \textcolor{comment}{// so we should spend the first method iff we have nu\_bits(nu\_bits(nu\_star\_vertices-1)) +
       nu\_bits(diff) < nu\_bits(nu\_star\_vertices-1)}
400         \textcolor{comment}{// or equivalently if nu\_bits(diff) < nu\_bits(nu\_star\_vertices-1) -
       nu\_bits(nu\_bits(nu\_star\_vertices-1))}
401         \textcolor{comment}{// we define  nu\_bits(nu\_star\_vertices-1) =: nb\_nsv and nu\_bits(nu\_bits(nu\_star\_vertices-1)) =:
       nb\_nb\_nsv this is define above the loop}
402         \textcolor{comment}{// we also have defined the difference above as diff\_threshold to simplify}
403         nb\_diff = \hyperlink{bitstream_8cpp_a9dfce6f51e3febb3973aa3b16c2fecb4}{nu\_bits}(diff);
404         \textcolor{keywordflow}{if} (nb\_diff < diff\_threshold)\{
405           \textcolor{comment}{//if (it->second[i].size() < 100)}
406           \textcolor{comment}{//  cerr << " f ";}
407           \textcolor{comment}{// we choose the first method}
408           \textcolor{comment}{// we write a flag 1 upfront to tell decoder which method we use}
409           oup.write\_bits(1,1); \textcolor{comment}{// write a single bit with value 1}
410           oup.write\_bits(nb\_diff, nb\_nb\_nsv); \textcolor{comment}{// write the number of bits in diff }
411           diff -= (1<<(nb\_diff-1)); \textcolor{comment}{// remove the leading (MSB) bit from diff}
412           \textcolor{keywordflow}{if} (nb\_diff > 1) \textcolor{comment}{// otherwise, we do not need to write anything (note we remove leading one, so
       if diff = 1, we should not write anything at this stage)}
413             oup.write\_bits(diff, nb\_diff-1); \textcolor{comment}{// write diff to the output}
414         \}\textcolor{keywordflow}{else}\{
415           \textcolor{comment}{//if (it->second[i].size() < 100)}
416           \textcolor{comment}{//  cerr << " s ";}
417           \textcolor{comment}{// we should choose the second method}
418           \textcolor{comment}{// write a flag 0 upfront}
419           oup.write\_bits(0,1);
420           oup.write\_bits(diff, nb\_nsv);
421         \}
422       \}
423       \textcolor{comment}{//if (it->second[i].size() < 100)}
424       \textcolor{comment}{//  cerr << endl;}
425 
426       nu\_star\_edges += it->second[i].size();
427       
428     \}
429     \textcolor{keywordflow}{if} (\hyperlink{classlogger_a26812b5ba03f130e8dae3446d5fc032f}{logger::stat})\{
430       *\hyperlink{classlogger_a7db37821f875f2ba3540980b355779f5}{logger::stat\_stream} << \textcolor{stringliteral}{"mark pair: "} <<  x << \textcolor{stringliteral}{", "} << xp << endl;
431       \textcolor{keywordflow}{for} (map<int, int>::iterator deg\_it = deg\_map.begin(); deg\_it != deg\_map.end(); deg\_it++)\{
432         *\hyperlink{classlogger_a7db37821f875f2ba3540980b355779f5}{logger::stat\_stream} << \textcolor{stringliteral}{" d "} << deg\_it->first << \textcolor{stringliteral}{" # "} << deg\_it->second;
433       \}
434       *\hyperlink{classlogger_a7db37821f875f2ba3540980b355779f5}{logger::stat\_stream} << endl;
435     \}
436   \}
437   
438   chunks\_new = oup.chunks();
439   space\_log.push\_back(pair<string, int> (\textcolor{stringliteral}{"star edges"}, chunks\_new - chunks));
440   chunks = oup.chunks();
441 
442   \hyperlink{classlogger_a710163deb17bc81f70d53d285b8ac9ac}{logger::add\_entry}(\textcolor{stringliteral}{"vertex types"}, \textcolor{stringliteral}{""});
443   \textcolor{comment}{//output\_bits = 0;}
444   
445   \textcolor{comment}{// ==== write vertex types}
446 
447   \textcolor{comment}{// first, we need vertex types list (ver\_type\_list)}
448   \textcolor{comment}{// size of ver\_type\_list}
449 
450 
451   \hyperlink{classmarked__graph__compressed_a889749dd51bc37917a156e337eac142a}{vtype\_list\_write}(oup);
452 
453 
454   \textcolor{comment}{// oup <<  ver\_type\_list.size();}
455   \textcolor{comment}{// //fwrite(&int\_out, sizeof int\_out, 1, f);}
456   \textcolor{comment}{// //output\_bits += sizeof int\_out;}
457 
458   \textcolor{comment}{// for (int i=0;i<ver\_type\_list.size();i++)\{}
459   \textcolor{comment}{//   oup << ver\_type\_list[i].size();}
460   \textcolor{comment}{//   //fwrite(&int\_out, sizeof int\_out, 1, f);}
461   \textcolor{comment}{//   //output\_bits += sizeof int\_out;}
462 
463   \textcolor{comment}{//   oup << ver\_type\_list[i][0]; // write the vertex mark}
464   \textcolor{comment}{//   // then, we know that the rest of the list is (t,t',n\_\{t,t')\}) chunks, each of course with size 3}
465   \textcolor{comment}{//   for (int j=0;j<((ver\_type\_list[i].size()-1)/3); j++)\{}
466   \textcolor{comment}{//     // the triple is 3j+1, 3j+2, 3j+3}
467   \textcolor{comment}{//     if (j==0)\{}
468   \textcolor{comment}{//       // the first chunk is written of the form t,t',n-1. The reason we write n-1 is because we know n
       > 0, so it is better to save some bits!}
469   \textcolor{comment}{//       oup << ver\_type\_list[i][3*j+1];}
470   \textcolor{comment}{//       oup << ver\_type\_list[i][3*j+2];}
471   \textcolor{comment}{//       oup << ver\_type\_list[i][3*j+3]-1;}
472   \textcolor{comment}{//     \}else\{}
473   \textcolor{comment}{//       // we know that the list is lexicographically ordered, so the t here is not less than the t is
       the previous chunk, so better to write their difference}
474   \textcolor{comment}{//       oup << ver\_type\_list[i][3*j+1] - ver\_type\_list[i][3*(j-1)+1];}
475   \textcolor{comment}{//       // if t\_here is equal to t\_previous, then t'\_here >= t'\_previous, so better to encode their
       difference!}
476   \textcolor{comment}{//       if (ver\_type\_list[i][3*j+1] == ver\_type\_list[i][3*(j-1)+1])\{}
477   \textcolor{comment}{//         oup << ver\_type\_list[i][3*j+2] - ver\_type\_list[i][3*(j-1)+2];}
478   \textcolor{comment}{//       \}else\{}
479   \textcolor{comment}{//         // otherwise, just write t'\_here}
480   \textcolor{comment}{//         oup << ver\_type\_list[i][3*j+2];}
481   \textcolor{comment}{//       \}}
482   \textcolor{comment}{//       oup << ver\_type\_list[i][3*j+3]-1;}
483   \textcolor{comment}{//     \}}
484   \textcolor{comment}{//   \}}
485 
486   \textcolor{comment}{//   /* the old way of writing the list:}
487   \textcolor{comment}{//   for (int j=0;j<ver\_type\_list[i].size();j++)\{}
488   \textcolor{comment}{//     if (j%3 == 0 and j > 0) // we know that these indices are the count part (list is of the form
       \(\backslash\)theta, t, t', n\_\{t,t'\}, \(\backslash\)dots but the n\_\{t,t'\} \(\backslash\)geq 1, so in Elias delta encoding of oup << we do not need to
       add one. So it would be more efficient to subtract one here, and add one during decompression)}
489   \textcolor{comment}{//       oup << ver\_type\_list[i][j]-1;}
490   \textcolor{comment}{//     else}
491   \textcolor{comment}{//       oup << ver\_type\_list[i][j];}
492   \textcolor{comment}{//     //fwrite(&int\_out, sizeof int\_out, 1, f);}
493   \textcolor{comment}{//     //output\_bits += sizeof int\_out;}
494   \textcolor{comment}{//   \}}
495   \textcolor{comment}{//   */}
496   \textcolor{comment}{// \}}
497 
498 
499 
500   chunks\_new = oup.chunks();
501   space\_log.push\_back(pair<string, int>(\textcolor{stringliteral}{"vertex type list"}, chunks\_new - chunks));
502   chunks = chunks\_new;
503 
504   \textcolor{comment}{//output\_bits = 0;}
505   
506   \textcolor{comment}{// then, write ver\_types}
507 
508   \textcolor{comment}{// ver\_types.first}
509   \textcolor{comment}{// ver\_types.first.size():}
510   oup << \hyperlink{classmarked__graph__compressed_af446cc5e23c241a92b76642fd5ebc403}{ver\_types}.first.size();
511   \textcolor{comment}{//fwrite(&int\_out, sizeof int\_out, 1, f);}
512   \textcolor{comment}{//output\_bits += sizeof int\_out;}
513 
514   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i =0;i<\hyperlink{classmarked__graph__compressed_af446cc5e23c241a92b76642fd5ebc403}{ver\_types}.first.size(); i++)\{
515     oup <<  \hyperlink{classmarked__graph__compressed_af446cc5e23c241a92b76642fd5ebc403}{ver\_types}.first[i];
516     \textcolor{comment}{//fwrite(&int\_out, sizeof int\_out, 1, f);}
517     \textcolor{comment}{//output\_bits += sizeof int\_out;}
518   \}
519   \textcolor{comment}{// ver\_types.second}
520   oup << \hyperlink{classmarked__graph__compressed_af446cc5e23c241a92b76642fd5ebc403}{ver\_types}.second;
521   \textcolor{comment}{//output\_bits += mpz\_out\_raw(f, ver\_types.second.get\_mpz\_t());}
522 
523   chunks\_new = oup.chunks();
524   space\_log.push\_back(pair<string, int> (\textcolor{stringliteral}{"vertex types"}, chunks\_new - chunks));
525   chunks = chunks\_new;
526 
527   \hyperlink{classlogger_a710163deb17bc81f70d53d285b8ac9ac}{logger::add\_entry}(\textcolor{stringliteral}{"partition bipartite graphs"}, \textcolor{stringliteral}{""});
528   
529 
530   \textcolor{comment}{// ==== part bgraphs}
531   \textcolor{comment}{//output\_bits = 0;}
532 
533   \textcolor{comment}{// part\_bgraphs.size}
534   oup << \hyperlink{classmarked__graph__compressed_a7b3267063fba30b45eb21b3ba4e07536}{part\_bgraph}.size();
535   \textcolor{comment}{//fwrite(&int\_out, sizeof int\_out, 1, f);}
536   \textcolor{comment}{//output\_bits += sizeof int\_out;}
537 
538   map<pair<int, int>, mpz\_class>::iterator it2;
539   \textcolor{keywordflow}{if} (\hyperlink{classlogger_a26812b5ba03f130e8dae3446d5fc032f}{logger::stat})\{
540     *\hyperlink{classlogger_a7db37821f875f2ba3540980b355779f5}{logger::stat\_stream} << \textcolor{stringliteral}{" ==== statistics ==== "} << endl;
541     *\hyperlink{classlogger_a7db37821f875f2ba3540980b355779f5}{logger::stat\_stream} << \textcolor{stringliteral}{" n:                "} << n << endl;
542     *\hyperlink{classlogger_a7db37821f875f2ba3540980b355779f5}{logger::stat\_stream} << \textcolor{stringliteral}{" h:                "} << h << endl;
543     *\hyperlink{classlogger_a7db37821f875f2ba3540980b355779f5}{logger::stat\_stream} << \textcolor{stringliteral}{" delta:            "} << delta << endl;
544     *\hyperlink{classlogger_a7db37821f875f2ba3540980b355779f5}{logger::stat\_stream} << \textcolor{stringliteral}{" No. types         "} << 
      \hyperlink{classmarked__graph__compressed_a86b00223525703e973415cbc9c94da68}{type\_mark}.size() << endl;
545     *\hyperlink{classlogger_a7db37821f875f2ba3540980b355779f5}{logger::stat\_stream} << \textcolor{stringliteral}{" No. * vertices    "} << n - 
      \hyperlink{classmarked__graph__compressed_a7a4ced4586e2e353f9076bd447df5208}{star\_vertices}.first[0] << endl;
546     *\hyperlink{classlogger_a7db37821f875f2ba3540980b355779f5}{logger::stat\_stream} << \textcolor{stringliteral}{" No. * edges       "} << nu\_star\_edges << endl;
547     *\hyperlink{classlogger_a7db37821f875f2ba3540980b355779f5}{logger::stat\_stream} << \textcolor{stringliteral}{" No. part bgraphs  "} << 
      \hyperlink{classmarked__graph__compressed_a7b3267063fba30b45eb21b3ba4e07536}{part\_bgraph}.size() << endl;
548     *\hyperlink{classlogger_a7db37821f875f2ba3540980b355779f5}{logger::stat\_stream} << \textcolor{stringliteral}{" No. part graphs   "} << 
      \hyperlink{classmarked__graph__compressed_ae179a4737e6eab905c18a94d44ef64b7}{part\_graph}.size() << endl;
549   \}
550 
551   \textcolor{keywordflow}{for} (it2 = \hyperlink{classmarked__graph__compressed_a7b3267063fba30b45eb21b3ba4e07536}{part\_bgraph}.begin(); it2 != \hyperlink{classmarked__graph__compressed_a7b3267063fba30b45eb21b3ba4e07536}{part\_bgraph}.end(); it2++)\{
552     \textcolor{comment}{// first, write t, t'}
553     oup << it2->first.first;
554     \textcolor{comment}{//fwrite(&int\_out, sizeof int\_out, 1, f);}
555     \textcolor{comment}{//output\_bits += sizeof int\_out;}
556     oup <<  it2->first.second;
557     \textcolor{comment}{//fwrite(&int\_out, sizeof int\_out, 1, f);}
558     \textcolor{comment}{//output\_bits += sizeof int\_out;}
559     \textcolor{comment}{// then, the compressed integer}
560     oup << it2->second;
561     \textcolor{comment}{//output\_bits += mpz\_out\_raw(f, it2->second.get\_mpz\_t());}
562   \}
563 
564   chunks\_new = oup.chunks();
565   space\_log.push\_back(pair<string, int> (\textcolor{stringliteral}{"partition bipartite graphs"}, chunks\_new - chunks));
566   chunks = chunks\_new;
567 
568   \hyperlink{classlogger_a710163deb17bc81f70d53d285b8ac9ac}{logger::add\_entry}(\textcolor{stringliteral}{"partition graphs"}, \textcolor{stringliteral}{""});
569   \textcolor{comment}{//output\_bits = 0;}
570   \textcolor{comment}{// === part graphs}
571 
572   \textcolor{comment}{// part\_graph.size}
573   oup <<  \hyperlink{classmarked__graph__compressed_ae179a4737e6eab905c18a94d44ef64b7}{part\_graph}.size();
574   \textcolor{comment}{//fwrite(&int\_out, sizeof int\_out, 1, f);}
575   \textcolor{comment}{//output\_bits += sizeof int\_out;}
576 
577   map< int, pair< mpz\_class, vector< int > > >::iterator it3;
578   \textcolor{keywordflow}{for} (it3 = \hyperlink{classmarked__graph__compressed_ae179a4737e6eab905c18a94d44ef64b7}{part\_graph}.begin(); it3 != \hyperlink{classmarked__graph__compressed_ae179a4737e6eab905c18a94d44ef64b7}{part\_graph}.end(); it3++)\{
579     oup <<  it3->first; \textcolor{comment}{// the type}
580     \textcolor{comment}{//fwrite(&int\_out, sizeof int\_out, 1, f);}
581     \textcolor{comment}{//output\_bits += sizeof int\_out;}
582 
583     \textcolor{comment}{// the mpz part}
584     oup << it3->second.first;
585     \textcolor{comment}{//output\_bits += mpz\_out\_raw(f, it3->second.first.get\_mpz\_t());}
586     \textcolor{comment}{// the vector part}
587     \textcolor{comment}{// first its size}
588     oup <<  it3->second.second.size();
589     \textcolor{comment}{//fwrite(&int\_out, sizeof int\_out, 1, f);}
590     \textcolor{comment}{//output\_bits += sizeof int\_out;}
591     \textcolor{comment}{// then element by element}
592     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} j=0;j<it3->second.second.size();j++)\{
593       oup <<  it3->second.second[j];
594       \textcolor{comment}{//fwrite(&int\_out, sizeof int\_out, 1, f);}
595       \textcolor{comment}{//output\_bits += sizeof int\_out;}
596     \}
597   \}
598 
599   chunks\_new = oup.chunks();
600   space\_log.push\_back(pair<string, int>(\textcolor{stringliteral}{"partition graphs"}, chunks\_new - chunks));
601   chunks = chunks\_new;
602 
603   
604   \textcolor{keywordflow}{if} (\hyperlink{classlogger_a26812b5ba03f130e8dae3446d5fc032f}{logger::stat})\{
605     *\hyperlink{classlogger_a7db37821f875f2ba3540980b355779f5}{logger::stat\_stream} << endl << endl;
606     *\hyperlink{classlogger_a7db37821f875f2ba3540980b355779f5}{logger::stat\_stream} << \textcolor{stringliteral}{" Number of bytes used for each part "} << endl;
607     *\hyperlink{classlogger_a7db37821f875f2ba3540980b355779f5}{logger::stat\_stream} << \textcolor{stringliteral}{" ---------------------------------- "} << endl << endl;
608 
609     \textcolor{keywordtype}{int} total\_chunks = 0;
610     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0; i < space\_log.size(); i++)
611       total\_chunks += space\_log[i].second;
612 
613     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0; i < space\_log.size(); i++)\{
614       \textcolor{comment}{// each chunks is 4 bytes. }
615       *\hyperlink{classlogger_a7db37821f875f2ba3540980b355779f5}{logger::stat\_stream} << space\_log[i].first << \textcolor{stringliteral}{" -> "}  << 4 * space\_log[i].second <
      < \textcolor{stringliteral}{" ( "} << float(100) * float(space\_log[i].second) / float(total\_chunks) << \textcolor{stringliteral}{" % "} << endl;
616     \}
617 
618     *\hyperlink{classlogger_a7db37821f875f2ba3540980b355779f5}{logger::stat\_stream} << \textcolor{stringliteral}{" Total number of bytes wrote to the output = "} << 4 * 
      total\_chunks << endl;
619   \}
620   
621   oup.close();
622   \hyperlink{classlogger_a9d29b49bd318a719a8e85b59eac54fe0}{logger::current\_depth}--;
623 \}
\end{DoxyCode}
\mbox{\Hypertarget{classmarked__graph__compressed_af58307bfadcaa4c3ca6dd594c2f9b3a9}\label{classmarked__graph__compressed_af58307bfadcaa4c3ca6dd594c2f9b3a9}} 
\index{marked\+\_\+graph\+\_\+compressed@{marked\+\_\+graph\+\_\+compressed}!clear@{clear}}
\index{clear@{clear}!marked\+\_\+graph\+\_\+compressed@{marked\+\_\+graph\+\_\+compressed}}
\subsubsection{\texorpdfstring{clear()}{clear()}}
{\footnotesize\ttfamily void marked\+\_\+graph\+\_\+compressed\+::clear (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}


\begin{DoxyCode}
9 \{
10   \hyperlink{classmarked__graph__compressed_a7df5779d313486644132bd816937f532}{star\_edges}.clear();
11   \hyperlink{classmarked__graph__compressed_a86b00223525703e973415cbc9c94da68}{type\_mark}.clear();
12   \hyperlink{classmarked__graph__compressed_af2e3e55223d436628a02758dfae88493}{ver\_type\_list}.clear();
13   \hyperlink{classmarked__graph__compressed_a7b3267063fba30b45eb21b3ba4e07536}{part\_bgraph}.clear();
14   \hyperlink{classmarked__graph__compressed_ae179a4737e6eab905c18a94d44ef64b7}{part\_graph}.clear();
15 \}
\end{DoxyCode}
\mbox{\Hypertarget{classmarked__graph__compressed_a4bf8563a2dfd3038dc5833c014320487}\label{classmarked__graph__compressed_a4bf8563a2dfd3038dc5833c014320487}} 
\index{marked\+\_\+graph\+\_\+compressed@{marked\+\_\+graph\+\_\+compressed}!vtype\+\_\+block\+\_\+read@{vtype\+\_\+block\+\_\+read}}
\index{vtype\+\_\+block\+\_\+read@{vtype\+\_\+block\+\_\+read}!marked\+\_\+graph\+\_\+compressed@{marked\+\_\+graph\+\_\+compressed}}
\subsubsection{\texorpdfstring{vtype\+\_\+block\+\_\+read()}{vtype\_block\_read()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void marked\+\_\+graph\+\_\+compressed\+::vtype\+\_\+block\+\_\+read (\begin{DoxyParamCaption}\item[{\hyperlink{classibitstream}{ibitstream} \&}]{inp,  }\item[{int}]{i,  }\item[{int}]{j }\end{DoxyParamCaption})}

reads a (t,t\textquotesingle{},n) block of a vertex type list element from input. 
\begin{DoxyParams}{Parameters}
{\em inp} & the input bitstream used to read the encoded bit sequence \\
\hline
{\em i} & the index of ver\+\_\+type\+\_\+list member of this class which is going to be decoded \\
\hline
{\em j} & the index of the t,t\textquotesingle{},n block of ver\+\_\+type\+\_\+list\mbox{[}i\mbox{]} that is going to be decoded. Hence, the block is ver\+\_\+type\+\_\+list\mbox{[}i\mbox{]}\mbox{[}1+3$\ast$j\mbox{]}, ver\+\_\+type\+\_\+list\mbox{[}i\mbox{]}\mbox{[}2+3$\ast$j\mbox{]}, and ver\+\_\+type\+\_\+list\mbox{[}i\mbox{]}\mbox{[}3+3$\ast$j\mbox{]} \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
1280                                                                            \{
1281   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} int\_in;
1282   inp >> int\_in;
1283   \hyperlink{classmarked__graph__compressed_af2e3e55223d436628a02758dfae88493}{ver\_type\_list}[i][3*j+1] = int\_in;
1284   inp >> int\_in;
1285   \hyperlink{classmarked__graph__compressed_af2e3e55223d436628a02758dfae88493}{ver\_type\_list}[i][3*j+2] = int\_in;
1286   inp >> int\_in;
1287   \hyperlink{classmarked__graph__compressed_af2e3e55223d436628a02758dfae88493}{ver\_type\_list}[i][3*j+3] = int\_in + 1; \textcolor{comment}{// since we had subtracted one during compression}
1288 \}
\end{DoxyCode}
\mbox{\Hypertarget{classmarked__graph__compressed_a01a434f3313d99b5877eddacb380cf15}\label{classmarked__graph__compressed_a01a434f3313d99b5877eddacb380cf15}} 
\index{marked\+\_\+graph\+\_\+compressed@{marked\+\_\+graph\+\_\+compressed}!vtype\+\_\+block\+\_\+read@{vtype\+\_\+block\+\_\+read}}
\index{vtype\+\_\+block\+\_\+read@{vtype\+\_\+block\+\_\+read}!marked\+\_\+graph\+\_\+compressed@{marked\+\_\+graph\+\_\+compressed}}
\subsubsection{\texorpdfstring{vtype\+\_\+block\+\_\+read()}{vtype\_block\_read()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void marked\+\_\+graph\+\_\+compressed\+::vtype\+\_\+block\+\_\+read (\begin{DoxyParamCaption}\item[{\hyperlink{classibitstream}{ibitstream} \&}]{inp,  }\item[{int}]{i,  }\item[{int}]{j,  }\item[{int}]{ir,  }\item[{int}]{jr }\end{DoxyParamCaption})}

reads a (t,t\textquotesingle{},n) block of a vertex type list element with reference to another reference block. We assume that this block is lexicographically greater than the reference block, and this fact was used in the compression to encode the difference. The reference block must be prior to the current block so that it is already decoded and ready to be used as a reference. 
\begin{DoxyParams}{Parameters}
{\em inp} & the input bitstream used to read the encoded bit sequence \\
\hline
{\em i} & the index of ver\+\_\+type\+\_\+list member of this class which is going to be decoded \\
\hline
{\em j} & the index of the t,t\textquotesingle{},n block of ver\+\_\+type\+\_\+list\mbox{[}i\mbox{]} that is going to be decoded. Hence, the block is ver\+\_\+type\+\_\+list\mbox{[}i\mbox{]}\mbox{[}1+3$\ast$j\mbox{]}, ver\+\_\+type\+\_\+list\mbox{[}i\mbox{]}\mbox{[}2+3$\ast$j\mbox{]}, and ver\+\_\+type\+\_\+list\mbox{[}i\mbox{]}\mbox{[}3+3$\ast$j\mbox{]} \\
\hline
{\em ir} & the index of the ver\+\_\+type\+\_\+list used as the reference \\
\hline
{\em jr} & the index of the block in ver\+\_\+type\+\_\+list\mbox{[}ir\mbox{]} used as the reference. Hence, the reference block is ver\+\_\+type\+\_\+list\mbox{[}ir\mbox{]}\mbox{[}1+3$\ast$jr\mbox{]}, ver\+\_\+type\+\_\+list\mbox{[}ir\mbox{]}\mbox{[}2+3$\ast$jr\mbox{]}, and ver\+\_\+type\+\_\+list\mbox{[}ir\mbox{]}\mbox{[}3+3$\ast$jr\mbox{]} \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
1290                                                                                            \{
1291   \textcolor{comment}{// we use the following terminologies for comments:}
1292   \textcolor{comment}{// t = ver\_type\_list[i][3*j+1]}
1293   \textcolor{comment}{// t' = ver\_type\_int[i][3*j+2]}
1294   \textcolor{comment}{// n = ver\_type\_list[i][3*j+3]}
1295   \textcolor{comment}{// t\_r = ver\_type\_list[ir][3*jr+1]}
1296   \textcolor{comment}{// t'\_r = ver\_type\_list[ir][3*jr+2]}
1297   \textcolor{comment}{// n\_r = ver\_type\_list[ir][3*jr+3]}
1298   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} int\_in;
1299   inp >> int\_in;
1300   \hyperlink{classmarked__graph__compressed_af2e3e55223d436628a02758dfae88493}{ver\_type\_list}[i][3*j+1] = int\_in + \hyperlink{classmarked__graph__compressed_af2e3e55223d436628a02758dfae88493}{ver\_type\_list}[ir][3*jr+1]; \textcolor{comment}{// since we had
       encoded the difference during the compression phasen}
1301  
1302   \textcolor{comment}{// if t = t\_r, we have encoded t' - t'\_r - 1}
1303   \textcolor{keywordflow}{if} (ver\_type\_list[i][3*j+1] == ver\_type\_list[ir][3*jr+1])\{
1304     inp >> int\_in;
1305     ver\_type\_list[i][3*j+2] = int\_in + ver\_type\_list[ir][3*jr+2];
1306     \textcolor{keywordflow}{if} (ver\_type\_list[i][3*j+2] == ver\_type\_list[ir][3*jr+2])\{
1307       inp >> int\_in; 
1308       ver\_type\_list[i][3*j+3] = int\_in +  ver\_type\_list[ir][3*jr+3];
1309     \}\textcolor{keywordflow}{else}\{
1310       inp >> int\_in; 
1311       ver\_type\_list[i][3*j+3] = int\_in +  1;
1312     \}
1313   \}\textcolor{keywordflow}{else}\{
1314     \textcolor{comment}{// otherwise, we have just encoded t'}
1315     inp >> int\_in;
1316     ver\_type\_list[i][3*j+2] = int\_in;
1317     inp >> int\_in;
1318     ver\_type\_list[i][3*j+3]= int\_in + 1; \textcolor{comment}{// since we had subtracted one during compression}
1319   \}
1320 \}
\end{DoxyCode}
\mbox{\Hypertarget{classmarked__graph__compressed_a31f9ea72682f9072d0f90faf58a603fe}\label{classmarked__graph__compressed_a31f9ea72682f9072d0f90faf58a603fe}} 
\index{marked\+\_\+graph\+\_\+compressed@{marked\+\_\+graph\+\_\+compressed}!vtype\+\_\+block\+\_\+write@{vtype\+\_\+block\+\_\+write}}
\index{vtype\+\_\+block\+\_\+write@{vtype\+\_\+block\+\_\+write}!marked\+\_\+graph\+\_\+compressed@{marked\+\_\+graph\+\_\+compressed}}
\subsubsection{\texorpdfstring{vtype\+\_\+block\+\_\+write()}{vtype\_block\_write()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void marked\+\_\+graph\+\_\+compressed\+::vtype\+\_\+block\+\_\+write (\begin{DoxyParamCaption}\item[{\hyperlink{classobitstream}{obitstream} \&}]{oup,  }\item[{int}]{i,  }\item[{int}]{j }\end{DoxyParamCaption})}

writes a (t,t\textquotesingle{},n) block of a vertex type list element to the output. 
\begin{DoxyParams}{Parameters}
{\em oup} & the output bitstream used to output the encoded bit sequence \\
\hline
{\em i} & the index of ver\+\_\+type\+\_\+list member of this class which is going to be encoded \\
\hline
{\em j} & the index of the t,t\textquotesingle{},n block of ver\+\_\+type\+\_\+list\mbox{[}i\mbox{]} that is going to be encoded. Hence, the block is ver\+\_\+type\+\_\+list\mbox{[}i\mbox{]}\mbox{[}1+3$\ast$j\mbox{]}, ver\+\_\+type\+\_\+list\mbox{[}i\mbox{]}\mbox{[}2+3$\ast$j\mbox{]}, and ver\+\_\+type\+\_\+list\mbox{[}i\mbox{]}\mbox{[}3+3$\ast$j\mbox{]} \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
1238                                                                             \{
1239   oup << \hyperlink{classmarked__graph__compressed_af2e3e55223d436628a02758dfae88493}{ver\_type\_list}[i][3*j+1];
1240   oup << ver\_type\_list[i][3*j+2];
1241   oup << ver\_type\_list[i][3*j+3]-1;
1242 \}
\end{DoxyCode}
\mbox{\Hypertarget{classmarked__graph__compressed_ad443f83015addcc0f2b0e35351ae9362}\label{classmarked__graph__compressed_ad443f83015addcc0f2b0e35351ae9362}} 
\index{marked\+\_\+graph\+\_\+compressed@{marked\+\_\+graph\+\_\+compressed}!vtype\+\_\+block\+\_\+write@{vtype\+\_\+block\+\_\+write}}
\index{vtype\+\_\+block\+\_\+write@{vtype\+\_\+block\+\_\+write}!marked\+\_\+graph\+\_\+compressed@{marked\+\_\+graph\+\_\+compressed}}
\subsubsection{\texorpdfstring{vtype\+\_\+block\+\_\+write()}{vtype\_block\_write()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void marked\+\_\+graph\+\_\+compressed\+::vtype\+\_\+block\+\_\+write (\begin{DoxyParamCaption}\item[{\hyperlink{classobitstream}{obitstream} \&}]{oup,  }\item[{int}]{i,  }\item[{int}]{j,  }\item[{int}]{ir,  }\item[{int}]{jr }\end{DoxyParamCaption})}

writes a (t,t\textquotesingle{},n) block of a vertex type list element with reference to another reference block to the output. We assume that this block is lexicographically greater than the reference block, and use it to encode the difference to save space 
\begin{DoxyParams}{Parameters}
{\em oup} & the output bitstream used to output the encoded bit sequence \\
\hline
{\em i} & the index of ver\+\_\+type\+\_\+list member of this class which is going to be encoded \\
\hline
{\em j} & the index of the t,t\textquotesingle{},n block of ver\+\_\+type\+\_\+list\mbox{[}i\mbox{]} that is going to be encoded. Hence, the block is ver\+\_\+type\+\_\+list\mbox{[}i\mbox{]}\mbox{[}1+3$\ast$j\mbox{]}, ver\+\_\+type\+\_\+list\mbox{[}i\mbox{]}\mbox{[}2+3$\ast$j\mbox{]}, and ver\+\_\+type\+\_\+list\mbox{[}i\mbox{]}\mbox{[}3+3$\ast$j\mbox{]} \\
\hline
{\em ir} & the index of the ver\+\_\+type\+\_\+list used as the reference \\
\hline
{\em jr} & the index of the block in ver\+\_\+type\+\_\+list\mbox{[}ir\mbox{]} used as the reference. Hence, the reference block is ver\+\_\+type\+\_\+list\mbox{[}ir\mbox{]}\mbox{[}1+3$\ast$jr\mbox{]}, ver\+\_\+type\+\_\+list\mbox{[}ir\mbox{]}\mbox{[}2+3$\ast$jr\mbox{]}, and ver\+\_\+type\+\_\+list\mbox{[}ir\mbox{]}\mbox{[}3+3$\ast$jr\mbox{]} \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
1244                                                                                             \{
1245   \textcolor{comment}{// we use the following terminologies for comments:}
1246   \textcolor{comment}{// t = ver\_type\_list[i][3*j+1]}
1247   \textcolor{comment}{// t' = ver\_type\_int[i][3*j+2]}
1248   \textcolor{comment}{// n = ver\_type\_list[i][3*j+3]}
1249   \textcolor{comment}{// t\_r = ver\_type\_list[ir][3*jr+1]}
1250   \textcolor{comment}{// t'\_r = ver\_type\_list[ir][3*jr+2]}
1251   \textcolor{comment}{// n\_r = ver\_type\_list[ir][3*jr+3]}
1252 
1253   \textcolor{comment}{//write the difference between the t parts, i.e. t - t\_r}
1254   oup << \hyperlink{classmarked__graph__compressed_af2e3e55223d436628a02758dfae88493}{ver\_type\_list}[i][3*j+1] - \hyperlink{classmarked__graph__compressed_af2e3e55223d436628a02758dfae88493}{ver\_type\_list}[ir][3*jr+1];
1255 
1256   \textcolor{comment}{// check if the t part is the same, i.e. t = t\_r}
1257   \textcolor{keywordflow}{if} (ver\_type\_list[i][3*j+1] == ver\_type\_list[ir][3*jr+1])\{
1258     \textcolor{comment}{// encode the difference of the t' part}
1259     \textcolor{comment}{// but in this case, t' >= t'\_r, so write the difference}
1260     oup << ver\_type\_list[i][3*j+2] - ver\_type\_list[ir][3*jr+2];
1261     \textcolor{comment}{// for sanity check:}
1262     \textcolor{comment}{// TO BE REMOVED LATER}
1263     \textcolor{comment}{//if (ver\_type\_list[i][3*j+2] == ver\_type\_list[ir][3*jr+2])}
1264     \textcolor{comment}{//cerr << " warning marked\_graph\_compressed::vtype\_block\_write : (t,t') = (t\_r, t'\_r), (i,j) = " << i
       << ", " << j << ") and (ir, jr) = (" << ir << ", " << jr << ")" << endl;}
1265     \textcolor{keywordflow}{if} (ver\_type\_list[i][3*j+2] == ver\_type\_list[ir][3*jr+2])\{
1266       oup << ver\_type\_list[i][3*j+3] - ver\_type\_list[ir][3*jr+3];
1267     \}\textcolor{keywordflow}{else}\{
1268       oup << ver\_type\_list[i][3*j+3] - 1;
1269     \}
1270   \}\textcolor{keywordflow}{else}\{
1271     \textcolor{comment}{// just write t'}
1272     oup << ver\_type\_list[i][3*j+2];
1273     \textcolor{comment}{// finally, write n - 1, note that n > 0, so we encode n - 1 to save some space}
1274     oup << ver\_type\_list[i][3*j+3] - 1;
1275   \}
1276 
1277   
1278 \}
\end{DoxyCode}
\mbox{\Hypertarget{classmarked__graph__compressed_af29f16cbd56583652118eb24a7c233b7}\label{classmarked__graph__compressed_af29f16cbd56583652118eb24a7c233b7}} 
\index{marked\+\_\+graph\+\_\+compressed@{marked\+\_\+graph\+\_\+compressed}!vtype\+\_\+list\+\_\+read@{vtype\+\_\+list\+\_\+read}}
\index{vtype\+\_\+list\+\_\+read@{vtype\+\_\+list\+\_\+read}!marked\+\_\+graph\+\_\+compressed@{marked\+\_\+graph\+\_\+compressed}}
\subsubsection{\texorpdfstring{vtype\+\_\+list\+\_\+read()}{vtype\_list\_read()}}
{\footnotesize\ttfamily void marked\+\_\+graph\+\_\+compressed\+::vtype\+\_\+list\+\_\+read (\begin{DoxyParamCaption}\item[{\hyperlink{classibitstream}{ibitstream} \&}]{inp }\end{DoxyParamCaption})}



reads the ver\+\_\+type\+\_\+list array from the input, assuming the bit sequence was generated during compression using vtype\+\_\+list\+\_\+write 


\begin{DoxyCode}
1149                                                             \{
1150   \textcolor{comment}{// read vertex mark block counts}
1151   vector<pair<int, int> > ver\_types\_freq; \textcolor{comment}{// each element (m,k) means that the ver mark m appears in k many
       vertex types}
1152   \textcolor{comment}{//vector<pair<int, int> > ver\_types\_blocks; // the ith entry is (a,b), where a and b denote the range of
       indices in ith block. Note that the range is of the form [a,b)}
1153   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} int\_in;
1154 
1155   inp >> int\_in;
1156   ver\_types\_freq.resize(int\_in);
1157   \textcolor{keywordtype}{int} total\_types = 0; \textcolor{comment}{// size of ver\_type\_int}
1158 
1159   \textcolor{keywordtype}{int} block\_start = 0;
1160   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0;i<ver\_types\_freq.size();i++)\{
1161     inp >> int\_in;
1162     ver\_types\_freq[i].first = int\_in;
1163     inp >> int\_in;
1164     ver\_types\_freq[i].second  = int\_in + 1;
1165     total\_types += ver\_types\_freq[i].second;
1166     \textcolor{comment}{//ver\_types\_blocks.push\_back(pair<int,int>(block\_start, block\_start+ver\_types\_freq[i].second));}
1167     \textcolor{comment}{//block\_start += ver\_types\_freq[i].second;}
1168   \}
1169 
1170   \textcolor{comment}{// create ver\_types\_blocks}
1171 
1172   \hyperlink{classmarked__graph__compressed_af2e3e55223d436628a02758dfae88493}{ver\_type\_list}.resize(total\_types);
1173   \textcolor{keywordtype}{int} block = 0; \textcolor{comment}{// the block at which we are in terms of vertex mark}
1174   \textcolor{keywordtype}{int} count\_in\_block = 0; \textcolor{comment}{// the index of me in the current blcok}
1175   \textcolor{keywordtype}{int} max\_match; \textcolor{comment}{// maximum match with the previous row}
1176   \textcolor{keywordtype}{int} total\_chunks; 
1177   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0; i<\hyperlink{classmarked__graph__compressed_af2e3e55223d436628a02758dfae88493}{ver\_type\_list}.size(); i++)\{
1178     \textcolor{keywordflow}{if} (count\_in\_block == ver\_types\_freq[block].second)\{
1179       block++;
1180       count\_in\_block =0 ;
1181     \}
1182     \textcolor{keywordflow}{if} (count\_in\_block==0)\{
1183       inp >> int\_in; \textcolor{comment}{// the number of chunks}
1184       \hyperlink{classmarked__graph__compressed_af2e3e55223d436628a02758dfae88493}{ver\_type\_list}[i].resize(1+3*int\_in);
1185       \hyperlink{classmarked__graph__compressed_af2e3e55223d436628a02758dfae88493}{ver\_type\_list}[i][0] = ver\_types\_freq[block].first; \textcolor{comment}{// fix the vertex mark}
1186       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j=0; j<int\_in; j++)\{ \textcolor{comment}{// read blocks one by one}
1187         \textcolor{keywordflow}{if} (j==0)
1188           \hyperlink{classmarked__graph__compressed_a4bf8563a2dfd3038dc5833c014320487}{vtype\_block\_read}(inp, i, j);
1189         \textcolor{keywordflow}{else}
1190           \hyperlink{classmarked__graph__compressed_a4bf8563a2dfd3038dc5833c014320487}{vtype\_block\_read}(inp, i, j, i, j-1); \textcolor{comment}{// use the previous block as reference}
1191       \}
1192     \}\textcolor{keywordflow}{else}\{
1193       inp >> int\_in;
1194       max\_match = int\_in;
1195       inp >> int\_in; \textcolor{comment}{// the remaining chunks}
1196       total\_chunks = max\_match + int\_in; 
1197       \hyperlink{classmarked__graph__compressed_af2e3e55223d436628a02758dfae88493}{ver\_type\_list}[i].resize(1+3*total\_chunks);
1198       \textcolor{comment}{// first, fill the matching chunks}
1199       \hyperlink{classmarked__graph__compressed_af2e3e55223d436628a02758dfae88493}{ver\_type\_list}[i][0] = ver\_types\_freq[block].first;
1200       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j=0; j<max\_match;j++)\{
1201         \hyperlink{classmarked__graph__compressed_af2e3e55223d436628a02758dfae88493}{ver\_type\_list}[i][1+3*j] = \hyperlink{classmarked__graph__compressed_af2e3e55223d436628a02758dfae88493}{ver\_type\_list}[i-1][1+3*j];
1202         \hyperlink{classmarked__graph__compressed_af2e3e55223d436628a02758dfae88493}{ver\_type\_list}[i][2+3*j] = \hyperlink{classmarked__graph__compressed_af2e3e55223d436628a02758dfae88493}{ver\_type\_list}[i-1][2+3*j];
1203         \hyperlink{classmarked__graph__compressed_af2e3e55223d436628a02758dfae88493}{ver\_type\_list}[i][3+3*j] = \hyperlink{classmarked__graph__compressed_af2e3e55223d436628a02758dfae88493}{ver\_type\_list}[i-1][3+3*j];
1204       \}
1205       \textcolor{keywordflow}{if} (max\_match < total\_chunks)\{
1206         \textcolor{comment}{// there are still some blocks to be decoded}
1207         \textcolor{comment}{// first, we need to encode the block max\_match itself}
1208         \textcolor{comment}{// if this block exists in row i-1, we use that as a reference,}
1209         \textcolor{keywordflow}{if} (max\_match <(\hyperlink{classmarked__graph__compressed_af2e3e55223d436628a02758dfae88493}{ver\_type\_list}[i-1].size()-1)/3)\{
1210           \hyperlink{classmarked__graph__compressed_a4bf8563a2dfd3038dc5833c014320487}{vtype\_block\_read}(inp, i, max\_match, i-1, max\_match);
1211           \textcolor{comment}{// then, write the remaining blocks, if any}
1212           \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j = max\_match+1; j<(\hyperlink{classmarked__graph__compressed_af2e3e55223d436628a02758dfae88493}{ver\_type\_list}[i].size()-1)/3; j++)\{
1213             \hyperlink{classmarked__graph__compressed_a4bf8563a2dfd3038dc5833c014320487}{vtype\_block\_read}(inp, i, j, i, j-1);
1214           \}
1215         \}\textcolor{keywordflow}{else}\{
1216           \textcolor{comment}{// if block max\_match - 1 exists in row i, use it as a reference}
1217           \textcolor{keywordflow}{if} (max\_match > 0)\{
1218             \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j = max\_match; j<total\_chunks; j++)\{
1219               \hyperlink{classmarked__graph__compressed_a4bf8563a2dfd3038dc5833c014320487}{vtype\_block\_read}(inp, i, j, i, j-1);
1220             \}
1221           \}\textcolor{keywordflow}{else}\{
1222             \textcolor{comment}{// otherwise, encode the first block standalone, and recursively go forward and use previous
       block as reference }
1223             \hyperlink{classmarked__graph__compressed_a4bf8563a2dfd3038dc5833c014320487}{vtype\_block\_read}(inp, i, max\_match);
1224             \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j = max\_match+1; j<total\_chunks; j++)\{
1225               \hyperlink{classmarked__graph__compressed_a4bf8563a2dfd3038dc5833c014320487}{vtype\_block\_read}(inp, i, j, i, j-1);
1226             \}
1227           \}
1228         \}
1229       \}
1230     \}
1231     count\_in\_block++;
1232   \}
1233 
1234 \}
\end{DoxyCode}
\mbox{\Hypertarget{classmarked__graph__compressed_a889749dd51bc37917a156e337eac142a}\label{classmarked__graph__compressed_a889749dd51bc37917a156e337eac142a}} 
\index{marked\+\_\+graph\+\_\+compressed@{marked\+\_\+graph\+\_\+compressed}!vtype\+\_\+list\+\_\+write@{vtype\+\_\+list\+\_\+write}}
\index{vtype\+\_\+list\+\_\+write@{vtype\+\_\+list\+\_\+write}!marked\+\_\+graph\+\_\+compressed@{marked\+\_\+graph\+\_\+compressed}}
\subsubsection{\texorpdfstring{vtype\+\_\+list\+\_\+write()}{vtype\_list\_write()}}
{\footnotesize\ttfamily void marked\+\_\+graph\+\_\+compressed\+::vtype\+\_\+list\+\_\+write (\begin{DoxyParamCaption}\item[{\hyperlink{classobitstream}{obitstream} \&}]{oup }\end{DoxyParamCaption})}



writes the ver\+\_\+type\+\_\+list array to the output using difference coding, assuming that its entries are lexicographically sorted (as vectors) 


\begin{DoxyCode}
1049                                                              \{
1050   \textcolor{comment}{// first, we should extract information about vertex marks}
1051   vector<pair<int, int> > ver\_types\_freq; \textcolor{comment}{// each element (m,k) means that the ver mark m appears in k many
       vertex types}
1052   vector<pair<int, int> > ver\_types\_blocks; \textcolor{comment}{// the ith entry is (a,b), where a and b denote the range of
       indices in ith block. Note that the range is of the form [a,b)}
1053   \textcolor{comment}{//int prev\_mark = ver\_type\_list[0][0]-1; // define it this way, so that initially it is different from
       the first mark}
1054   \textcolor{keywordtype}{int} current\_mark; \textcolor{comment}{// the mark of the current blcok}
1055   \textcolor{keywordtype}{int} block\_start = 0; \textcolor{comment}{// the start index of the current vertex mark block, a block is subsequent entries
       in ver\_type\_list with the same vertex marks}
1056   \textcolor{keywordtype}{int} i = 0;
1057   \textcolor{comment}{// cerr << " ver\_type\_list.size() " << ver\_type\_list.size() << endl;}
1058   \textcolor{comment}{// cerr << " ver\_type\_list " << endl;}
1059   \textcolor{comment}{// for (int k=0; k<ver\_type\_list.size(); k++)\{}
1060   \textcolor{comment}{//   cerr << "(" << k << ") ";}
1061   \textcolor{comment}{//   cerr << ver\_type\_list[k][0]<< ": ";}
1062   \textcolor{comment}{//   for (int j=0; j< (ver\_type\_list[k].size()-1)/3; j++)}
1063   \textcolor{comment}{//     cerr << "| " << ver\_type\_list[k][1+3*j] << " " << ver\_type\_list[k][2+3*j] << " " <<
       ver\_type\_list[k][3+3*j] << " ";}
1064   \textcolor{comment}{//   cerr << endl;}
1065   \textcolor{comment}{// \}}
1066   \textcolor{keywordflow}{while}(i<\hyperlink{classmarked__graph__compressed_af2e3e55223d436628a02758dfae88493}{ver\_type\_list}.size())\{
1067     current\_mark = \hyperlink{classmarked__graph__compressed_af2e3e55223d436628a02758dfae88493}{ver\_type\_list}[block\_start][0];
1068     \textcolor{keywordflow}{while} (\hyperlink{classmarked__graph__compressed_af2e3e55223d436628a02758dfae88493}{ver\_type\_list}[i][0] == current\_mark)\{
1069       \textcolor{comment}{//cerr << i << " ";}
1070       i++;
1071       \textcolor{keywordflow}{if} (i >= \hyperlink{classmarked__graph__compressed_af2e3e55223d436628a02758dfae88493}{ver\_type\_list}.size())
1072         \textcolor{keywordflow}{break};
1073     \}
1074     ver\_types\_freq.push\_back(pair<int, int>(current\_mark, i - block\_start));
1075     ver\_types\_blocks.push\_back(pair<int, int>(block\_start, i));
1076     block\_start = i;
1077   \}
1078 
1079 
1080   \textcolor{comment}{// writing ver\_type\_freq to the output}
1081   oup << ver\_types\_freq.size();
1082   \textcolor{keywordflow}{for} (i=0;i<ver\_types\_freq.size();i++)\{
1083     \textcolor{comment}{//cerr << " mark " << ver\_types\_freq[i].first << " count " << ver\_types\_freq[i].second << endl;}
1084     oup << ver\_types\_freq[i].first;
1085     oup << ver\_types\_freq[i].second - 1;\textcolor{comment}{// since it is at least one}
1086   \}
1087 
1088   \textcolor{comment}{// now, we go over each block}
1089   \textcolor{comment}{// let b denote the block index}
1090   \textcolor{keywordtype}{int} max\_match;
1091 
1092   \textcolor{keywordtype}{bool} cond\_1 = \textcolor{keyword}{false};
1093   \textcolor{keywordtype}{bool} cond\_2 = \textcolor{keyword}{false};
1094   \textcolor{keywordtype}{bool} cond\_3 = \textcolor{keyword}{false};
1095   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} b=0; b<ver\_types\_freq.size();b++)\{
1096     \textcolor{keywordflow}{for} (i=ver\_types\_blocks[b].first; i<ver\_types\_blocks[b].second; i++)\{
1097       \textcolor{comment}{//for (i =0; i<ver\_type\_list.size();i++)\{}
1098       \textcolor{keywordflow}{if} (i==ver\_types\_blocks[b].first)\{
1099         \textcolor{comment}{// this is the first row in that block, so its compression is different}
1100         oup << (\hyperlink{classmarked__graph__compressed_af2e3e55223d436628a02758dfae88493}{ver\_type\_list}[i].size()-1)/3; \textcolor{comment}{// number of blocks}
1101         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j=0;j<(\hyperlink{classmarked__graph__compressed_af2e3e55223d436628a02758dfae88493}{ver\_type\_list}[i].size()-1)/3; j++)\{
1102           \textcolor{keywordflow}{if} (j==0)
1103             \hyperlink{classmarked__graph__compressed_a31f9ea72682f9072d0f90faf58a603fe}{vtype\_block\_write}(oup, i, j);
1104           \textcolor{keywordflow}{else}
1105             \hyperlink{classmarked__graph__compressed_a31f9ea72682f9072d0f90faf58a603fe}{vtype\_block\_write}(oup, i, j, i, j-1); \textcolor{comment}{// use the previous block as reference}
1106         \}
1107       \}\textcolor{keywordflow}{else}\{
1108         max\_match = \hyperlink{classmarked__graph__compressed_a5ce51414e335d817f4be781fdcfbe9b1}{vtype\_max\_match}(i, i-1); \textcolor{comment}{// compare with the previous one}
1109         oup << max\_match;
1110         oup << (\hyperlink{classmarked__graph__compressed_af2e3e55223d436628a02758dfae88493}{ver\_type\_list}[i].size()-1)/3 - max\_match; \textcolor{comment}{// number of remaining blocks}
1111         \textcolor{comment}{//cerr << " i " << i << " max\_match " << max\_match;}
1112         \textcolor{keywordflow}{if} (max\_match < (\hyperlink{classmarked__graph__compressed_af2e3e55223d436628a02758dfae88493}{ver\_type\_list}[i].size()-1)/3)\{
1113           \textcolor{comment}{// there are still some blocks to be encoded}
1114           \textcolor{comment}{// first, we need to encode the block max\_match itself}
1115           \textcolor{comment}{// if this block exists in row i-1, we use that as a reference,}
1116           \textcolor{keywordflow}{if} (max\_match <(\hyperlink{classmarked__graph__compressed_af2e3e55223d436628a02758dfae88493}{ver\_type\_list}[i-1].size()-1)/3)\{
1117             \textcolor{comment}{//cerr << " 1" << endl;}
1118             cond\_1 = \textcolor{keyword}{true};
1119             \hyperlink{classmarked__graph__compressed_a31f9ea72682f9072d0f90faf58a603fe}{vtype\_block\_write}(oup, i, max\_match, i-1, max\_match);
1120             \textcolor{comment}{// then, write the remaining blocks, if any}
1121             \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j = max\_match+1; j<(\hyperlink{classmarked__graph__compressed_af2e3e55223d436628a02758dfae88493}{ver\_type\_list}[i].size()-1)/3; j++)\{
1122               \hyperlink{classmarked__graph__compressed_a31f9ea72682f9072d0f90faf58a603fe}{vtype\_block\_write}(oup, i, j, i, j-1);
1123             \}
1124           \}\textcolor{keywordflow}{else}\{
1125             \textcolor{comment}{// if block max\_match - 1 exists in row i, use it as a reference}
1126             \textcolor{keywordflow}{if} (max\_match > 0)\{
1127               \textcolor{comment}{//cerr << " 2" << endl;}
1128               cond\_2 = \textcolor{keyword}{true};
1129               \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j = max\_match; j<(\hyperlink{classmarked__graph__compressed_af2e3e55223d436628a02758dfae88493}{ver\_type\_list}[i].size()-1)/3; j++)\{
1130                 \hyperlink{classmarked__graph__compressed_a31f9ea72682f9072d0f90faf58a603fe}{vtype\_block\_write}(oup, i, j, i, j-1);
1131               \}
1132             \}\textcolor{keywordflow}{else}\{
1133               \textcolor{comment}{//cerr << " 3" << endl;}
1134               \textcolor{comment}{// otherwise, encode the first block standalone, and recursively go forward and use previous
       block as reference}
1135               cond\_3 = \textcolor{keyword}{true};
1136               \hyperlink{classmarked__graph__compressed_a31f9ea72682f9072d0f90faf58a603fe}{vtype\_block\_write}(oup, i, max\_match);
1137               \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j = max\_match+1; j<(\hyperlink{classmarked__graph__compressed_af2e3e55223d436628a02758dfae88493}{ver\_type\_list}[i].size()-1)/3; j++)\{
1138                 \hyperlink{classmarked__graph__compressed_a31f9ea72682f9072d0f90faf58a603fe}{vtype\_block\_write}(oup, i, j, i, j-1);
1139               \}
1140             \}
1141           \}
1142         \}
1143       \}
1144     \}
1145   \}
1146   \textcolor{comment}{//cerr << " cond\_1 " << cond\_1 << " cond\_2 " << cond\_2 << " cond\_3 " << cond\_3 << endl;}
1147 \}
\end{DoxyCode}
\mbox{\Hypertarget{classmarked__graph__compressed_a5ce51414e335d817f4be781fdcfbe9b1}\label{classmarked__graph__compressed_a5ce51414e335d817f4be781fdcfbe9b1}} 
\index{marked\+\_\+graph\+\_\+compressed@{marked\+\_\+graph\+\_\+compressed}!vtype\+\_\+max\+\_\+match@{vtype\+\_\+max\+\_\+match}}
\index{vtype\+\_\+max\+\_\+match@{vtype\+\_\+max\+\_\+match}!marked\+\_\+graph\+\_\+compressed@{marked\+\_\+graph\+\_\+compressed}}
\subsubsection{\texorpdfstring{vtype\+\_\+max\+\_\+match()}{vtype\_max\_match()}}
{\footnotesize\ttfamily int marked\+\_\+graph\+\_\+compressed\+::vtype\+\_\+max\+\_\+match (\begin{DoxyParamCaption}\item[{int}]{i,  }\item[{int}]{j }\end{DoxyParamCaption})}



finds the maximum number of (t,t\textquotesingle{},n) blocks that match between two entries of ver\+\_\+type\+\_\+list 


\begin{DoxyCode}
1031                                                         \{
1032   \textcolor{keywordtype}{int} max\_match = 0;
1033   \textcolor{keywordtype}{int} k;
1034   \textcolor{keywordtype}{bool} flag;
1035   \textcolor{keywordflow}{while}(\textcolor{keyword}{true})\{
1036     \textcolor{keywordflow}{if} (((3*max\_match + 3) >= \hyperlink{classmarked__graph__compressed_af2e3e55223d436628a02758dfae88493}{ver\_type\_list}[i].size()) or ((3*max\_match+3) >= 
      \hyperlink{classmarked__graph__compressed_af2e3e55223d436628a02758dfae88493}{ver\_type\_list}[j].size())) \textcolor{comment}{// one of the lists is reached an end}
1037       \textcolor{keywordflow}{break};
1038     flag = \textcolor{keyword}{true};
1039     \textcolor{keywordflow}{for} (k=1;k<=3;k++)
1040       \textcolor{keywordflow}{if} (\hyperlink{classmarked__graph__compressed_af2e3e55223d436628a02758dfae88493}{ver\_type\_list}[i][3*max\_match+k] != \hyperlink{classmarked__graph__compressed_af2e3e55223d436628a02758dfae88493}{ver\_type\_list}[j][3*max\_match+k])
1041         flag = \textcolor{keyword}{false};
1042     \textcolor{keywordflow}{if} (flag == \textcolor{keyword}{false})
1043       \textcolor{keywordflow}{break};
1044     max\_match++;
1045   \}
1046   \textcolor{keywordflow}{return} max\_match;
1047 \}
\end{DoxyCode}


\subsection{Member Data Documentation}
\mbox{\Hypertarget{classmarked__graph__compressed_a8b2aaac68e9332ddc78d88eb60b323a7}\label{classmarked__graph__compressed_a8b2aaac68e9332ddc78d88eb60b323a7}} 
\index{marked\+\_\+graph\+\_\+compressed@{marked\+\_\+graph\+\_\+compressed}!delta@{delta}}
\index{delta@{delta}!marked\+\_\+graph\+\_\+compressed@{marked\+\_\+graph\+\_\+compressed}}
\subsubsection{\texorpdfstring{delta}{delta}}
{\footnotesize\ttfamily int marked\+\_\+graph\+\_\+compressed\+::delta}



the degree threshold used when compression was performed 

\mbox{\Hypertarget{classmarked__graph__compressed_af6ff623407b673d08d0cab77b39c2193}\label{classmarked__graph__compressed_af6ff623407b673d08d0cab77b39c2193}} 
\index{marked\+\_\+graph\+\_\+compressed@{marked\+\_\+graph\+\_\+compressed}!h@{h}}
\index{h@{h}!marked\+\_\+graph\+\_\+compressed@{marked\+\_\+graph\+\_\+compressed}}
\subsubsection{\texorpdfstring{h}{h}}
{\footnotesize\ttfamily int marked\+\_\+graph\+\_\+compressed\+::h}



the depth up to which the compression was performed 

\mbox{\Hypertarget{classmarked__graph__compressed_a8d841016ddb11cfd33748c8deb6277ba}\label{classmarked__graph__compressed_a8d841016ddb11cfd33748c8deb6277ba}} 
\index{marked\+\_\+graph\+\_\+compressed@{marked\+\_\+graph\+\_\+compressed}!n@{n}}
\index{n@{n}!marked\+\_\+graph\+\_\+compressed@{marked\+\_\+graph\+\_\+compressed}}
\subsubsection{\texorpdfstring{n}{n}}
{\footnotesize\ttfamily int marked\+\_\+graph\+\_\+compressed\+::n}



the number of vertices 

\mbox{\Hypertarget{classmarked__graph__compressed_a7b3267063fba30b45eb21b3ba4e07536}\label{classmarked__graph__compressed_a7b3267063fba30b45eb21b3ba4e07536}} 
\index{marked\+\_\+graph\+\_\+compressed@{marked\+\_\+graph\+\_\+compressed}!part\+\_\+bgraph@{part\+\_\+bgraph}}
\index{part\+\_\+bgraph@{part\+\_\+bgraph}!marked\+\_\+graph\+\_\+compressed@{marked\+\_\+graph\+\_\+compressed}}
\subsubsection{\texorpdfstring{part\+\_\+bgraph}{part\_bgraph}}
{\footnotesize\ttfamily map$<$pair$<$int, int$>$, mpz\+\_\+class$>$ marked\+\_\+graph\+\_\+compressed\+::part\+\_\+bgraph}



compressed form of partition bipartite graphs corresponding to colors in $C_<$. For a pair $0 \leq t < t' < L$ of half edge types, part\+\_\+bgraph\mbox{[}pair$<$int, int$>$(t,t\textquotesingle{})\mbox{]} is the compressed form of the bipartite graph with n left and right nodes, where a left node i is connected to a right node j if there is an edge connecting i to j with type t towards i and type t\textquotesingle{} towards j 

\mbox{\Hypertarget{classmarked__graph__compressed_ae179a4737e6eab905c18a94d44ef64b7}\label{classmarked__graph__compressed_ae179a4737e6eab905c18a94d44ef64b7}} 
\index{marked\+\_\+graph\+\_\+compressed@{marked\+\_\+graph\+\_\+compressed}!part\+\_\+graph@{part\+\_\+graph}}
\index{part\+\_\+graph@{part\+\_\+graph}!marked\+\_\+graph\+\_\+compressed@{marked\+\_\+graph\+\_\+compressed}}
\subsubsection{\texorpdfstring{part\+\_\+graph}{part\_graph}}
{\footnotesize\ttfamily map$<$int, pair$<$mpz\+\_\+class, vector$<$int$>$ $>$ $>$ marked\+\_\+graph\+\_\+compressed\+::part\+\_\+graph}



compressed form of partition graphs corresponding to colors in $C_=$. For a half edge type t, part\+\_\+graph\mbox{[}t\mbox{]} is the compressed form of the simple unmarked graph with n vertices, where a node i is connected to a node j where there is an edge between i and j in the original graph with color (t,t) 

\mbox{\Hypertarget{classmarked__graph__compressed_a7df5779d313486644132bd816937f532}\label{classmarked__graph__compressed_a7df5779d313486644132bd816937f532}} 
\index{marked\+\_\+graph\+\_\+compressed@{marked\+\_\+graph\+\_\+compressed}!star\+\_\+edges@{star\+\_\+edges}}
\index{star\+\_\+edges@{star\+\_\+edges}!marked\+\_\+graph\+\_\+compressed@{marked\+\_\+graph\+\_\+compressed}}
\subsubsection{\texorpdfstring{star\+\_\+edges}{star\_edges}}
{\footnotesize\ttfamily map$<$pair$<$int, int$>$ , vector$<$vector$<$int$>$ $>$ $>$ marked\+\_\+graph\+\_\+compressed\+::star\+\_\+edges}



for each pair of edge marks x,x\textquotesingle{}, and integer $k$, star\+\_\+edges\mbox{[}pair$<$int,int$>$(x,x\textquotesingle{})\mbox{]}\mbox{[}k\mbox{]} is a list of neighbors $w$ of the $k$th star vertex (say $v$) so that $v$ shares a star edge with $w$ so that the mark towards $v$ is x and the mark towards $w$ is xp. 

\mbox{\Hypertarget{classmarked__graph__compressed_a7a4ced4586e2e353f9076bd447df5208}\label{classmarked__graph__compressed_a7a4ced4586e2e353f9076bd447df5208}} 
\index{marked\+\_\+graph\+\_\+compressed@{marked\+\_\+graph\+\_\+compressed}!star\+\_\+vertices@{star\+\_\+vertices}}
\index{star\+\_\+vertices@{star\+\_\+vertices}!marked\+\_\+graph\+\_\+compressed@{marked\+\_\+graph\+\_\+compressed}}
\subsubsection{\texorpdfstring{star\+\_\+vertices}{star\_vertices}}
{\footnotesize\ttfamily pair$<$vector$<$int$>$, mpz\+\_\+class$>$ marked\+\_\+graph\+\_\+compressed\+::star\+\_\+vertices}



the compressed form of the star\+\_\+vertices list 

\mbox{\Hypertarget{classmarked__graph__compressed_a86b00223525703e973415cbc9c94da68}\label{classmarked__graph__compressed_a86b00223525703e973415cbc9c94da68}} 
\index{marked\+\_\+graph\+\_\+compressed@{marked\+\_\+graph\+\_\+compressed}!type\+\_\+mark@{type\+\_\+mark}}
\index{type\+\_\+mark@{type\+\_\+mark}!marked\+\_\+graph\+\_\+compressed@{marked\+\_\+graph\+\_\+compressed}}
\subsubsection{\texorpdfstring{type\+\_\+mark}{type\_mark}}
{\footnotesize\ttfamily vector$<$int$>$ marked\+\_\+graph\+\_\+compressed\+::type\+\_\+mark}



for an edge type t, type\+\_\+mark\mbox{[}t\mbox{]} denotes the mark component of t 

\mbox{\Hypertarget{classmarked__graph__compressed_af2e3e55223d436628a02758dfae88493}\label{classmarked__graph__compressed_af2e3e55223d436628a02758dfae88493}} 
\index{marked\+\_\+graph\+\_\+compressed@{marked\+\_\+graph\+\_\+compressed}!ver\+\_\+type\+\_\+list@{ver\+\_\+type\+\_\+list}}
\index{ver\+\_\+type\+\_\+list@{ver\+\_\+type\+\_\+list}!marked\+\_\+graph\+\_\+compressed@{marked\+\_\+graph\+\_\+compressed}}
\subsubsection{\texorpdfstring{ver\+\_\+type\+\_\+list}{ver\_type\_list}}
{\footnotesize\ttfamily vector$<$vector$<$int$>$ $>$ marked\+\_\+graph\+\_\+compressed\+::ver\+\_\+type\+\_\+list}



the list of all vertex types that appear in the graph, where the type of a vertex is a vector of integers, where its index 0 is the mark of the vertex, and indices $3k+1$, $3k+2$, $3k+3$ are $m$, $m'$ and $n_{m,m'}$, where $(m,m')$ is a type pair, and $n_{m,m'}$ is the number of edges connected to the vertex with that type. The list is sorted lexicographically to ensure unique representation. 

\mbox{\Hypertarget{classmarked__graph__compressed_af446cc5e23c241a92b76642fd5ebc403}\label{classmarked__graph__compressed_af446cc5e23c241a92b76642fd5ebc403}} 
\index{marked\+\_\+graph\+\_\+compressed@{marked\+\_\+graph\+\_\+compressed}!ver\+\_\+types@{ver\+\_\+types}}
\index{ver\+\_\+types@{ver\+\_\+types}!marked\+\_\+graph\+\_\+compressed@{marked\+\_\+graph\+\_\+compressed}}
\subsubsection{\texorpdfstring{ver\+\_\+types}{ver\_types}}
{\footnotesize\ttfamily pair$<$vector$<$int$>$, mpz\+\_\+class$>$ marked\+\_\+graph\+\_\+compressed\+::ver\+\_\+types}



the compressed form of vertex types, where the type of a vertex is the index with respect to ver\+\_\+type\+\_\+list of the list of integers specifying the type of the vertex (mark of the vertex followed by the number of edges of each type connected to that vertex) 



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
\hyperlink{marked__graph__compression_8h}{marked\+\_\+graph\+\_\+compression.\+h}\item 
\hyperlink{marked__graph__compression_8cpp}{marked\+\_\+graph\+\_\+compression.\+cpp}\end{DoxyCompactItemize}
