\hypertarget{classibitstream}{}\section{ibitstream Class Reference}
\label{classibitstream}\index{ibitstream@{ibitstream}}


deals with reading bit streams from binary files, this is the reverse of obitstream  




{\ttfamily \#include $<$bitstream.\+h$>$}

\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classibitstream_ac62c26004436d83f337f4aeba0895e20}{read\+\_\+chunk} ()
\begin{DoxyCompactList}\small\item\em reads one chunk (4 bytes) from the input file and stores it in buffer \end{DoxyCompactList}\item 
unsigned int \hyperlink{classibitstream_a2fdcaecf10fefa6942dcd5286a2696e0}{read\+\_\+bits} (unsigned int k)
\begin{DoxyCompactList}\small\item\em read k bits from the input, interpret it as integer (first bit read is M\+SB) and return its value. Here, k must be in the range 1 $<$= k $<$= B\+I\+T\+\_\+\+I\+NT \end{DoxyCompactList}\item 
void \hyperlink{classibitstream_a4bb7a698ab44c1e2fe21b4daa880bd6c}{read\+\_\+bits} (int k, \hyperlink{classbit__pipe}{bit\+\_\+pipe} \&B)
\begin{DoxyCompactList}\small\item\em reads k bits from input and stores in the given \hyperlink{classbit__pipe}{bit\+\_\+pipe}. $k \geq 1$ is arbitrary. The bits are stored in the \hyperlink{classbit__pipe}{bit\+\_\+pipe} so that can be interpreted as integer (e.\+g. mpz\+\_\+class) so the L\+SB is located in the rightmost bit of the rightmost chunk (unlike the usual \hyperlink{classbit__pipe}{bit\+\_\+pipe} situation). We assume that the B given here is an empty \hyperlink{classbit__pipe}{bit\+\_\+pipe} \end{DoxyCompactList}\item 
void \hyperlink{classibitstream_acec2e9efa21551ce8db784f5b0bbd1b5}{read\+\_\+bits\+\_\+append} (int k, \hyperlink{classbit__pipe}{bit\+\_\+pipe} \&B)
\begin{DoxyCompactList}\small\item\em similar to read\+\_\+bits, but B does not have to be empty and the result will be appended to B (this is used in order to recursively implement read\+\_\+bits) \end{DoxyCompactList}\item 
bool \hyperlink{classibitstream_a895239acf7179f6778388c39c97643e4}{read\+\_\+bit} ()
\begin{DoxyCompactList}\small\item\em read one bit from input and return true if its value is 1 and false otherwise. \end{DoxyCompactList}\item 
\hyperlink{classibitstream_af5f00b64072ed3ffe495b7712a71e3eb}{ibitstream} (string file\+\_\+name)
\item 
\hyperlink{classibitstream}{ibitstream} \& \hyperlink{classibitstream_ae3e91ecc9ff17eef98d72d44aec02eca}{operator$>$$>$} (unsigned int \&n)
\begin{DoxyCompactList}\small\item\em reads an unsigned int from the input using Elias delta decoding and saves it in the reference given \end{DoxyCompactList}\item 
\hyperlink{classibitstream}{ibitstream} \& \hyperlink{classibitstream_a0264d01fa1211c4bb73f5de2bc68adbc}{operator$>$$>$} (mpz\+\_\+class \&n)
\begin{DoxyCompactList}\small\item\em reads a nonnegative mpz\+\_\+class integer using Elias delta decoding and stores in the reference given \end{DoxyCompactList}\item 
void \hyperlink{classibitstream_aa7b59600e58571b802d6d0dadf92d37a}{close} ()
\begin{DoxyCompactList}\small\item\em closes the session by closing the input file \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
F\+I\+LE $\ast$ \hyperlink{classibitstream_a3ea2cdd0cf97820f0e1520c42e364308}{f}
\begin{DoxyCompactList}\small\item\em pointer to input binary file \end{DoxyCompactList}\item 
unsigned int \hyperlink{classibitstream_a73f0b24d3d4402369f1abbb43f7f70ef}{buffer}
\begin{DoxyCompactList}\small\item\em the last chunk read from the input \end{DoxyCompactList}\item 
unsigned int \hyperlink{classibitstream_a48cd41991b6c29ea5120b53873a72a70}{head\+\_\+mask}
\begin{DoxyCompactList}\small\item\em the place of the head bit in buffer, represented in terms of mask. So if we are in the L\+SB, head\+\_\+mask is one, if we are in two bit left of L\+SB, this is 4 so on. When this is zero, it means the buffer is expired and we should probably read one more chunk from the input file \end{DoxyCompactList}\item 
unsigned int \hyperlink{classibitstream_a7b96359ac1534a5565e6e9b0cc53a0b3}{head\+\_\+place}
\begin{DoxyCompactList}\small\item\em the place of head represented in terms of integer, L\+SB is 1, left of L\+SB is 2, 2 left of L\+SB is 3 and so on. head\+\_\+place is effectively the number of unread bits remaining in the buffer. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
deals with reading bit streams from binary files, this is the reverse of obitstream 

\subsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classibitstream_af5f00b64072ed3ffe495b7712a71e3eb}\label{classibitstream_af5f00b64072ed3ffe495b7712a71e3eb}} 
\index{ibitstream@{ibitstream}!ibitstream@{ibitstream}}
\index{ibitstream@{ibitstream}!ibitstream@{ibitstream}}
\subsubsection{\texorpdfstring{ibitstream()}{ibitstream()}}
{\footnotesize\ttfamily ibitstream\+::ibitstream (\begin{DoxyParamCaption}\item[{string}]{file\+\_\+name }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}


\begin{DoxyCode}
135                               \{
136     \hyperlink{classibitstream_a3ea2cdd0cf97820f0e1520c42e364308}{f} = fopen(file\_name.c\_str(), \textcolor{stringliteral}{"rb+"});
137     \hyperlink{classibitstream_a73f0b24d3d4402369f1abbb43f7f70ef}{buffer} =0;
138     \hyperlink{classibitstream_a48cd41991b6c29ea5120b53873a72a70}{head\_mask} = 0;
139     \hyperlink{classibitstream_a7b96359ac1534a5565e6e9b0cc53a0b3}{head\_place} = 0;
140   \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\mbox{\Hypertarget{classibitstream_aa7b59600e58571b802d6d0dadf92d37a}\label{classibitstream_aa7b59600e58571b802d6d0dadf92d37a}} 
\index{ibitstream@{ibitstream}!close@{close}}
\index{close@{close}!ibitstream@{ibitstream}}
\subsubsection{\texorpdfstring{close()}{close()}}
{\footnotesize\ttfamily void ibitstream\+::close (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



closes the session by closing the input file 


\begin{DoxyCode}
149 \{fclose(\hyperlink{classibitstream_a3ea2cdd0cf97820f0e1520c42e364308}{f});\}
\end{DoxyCode}
\mbox{\Hypertarget{classibitstream_ae3e91ecc9ff17eef98d72d44aec02eca}\label{classibitstream_ae3e91ecc9ff17eef98d72d44aec02eca}} 
\index{ibitstream@{ibitstream}!operator$>$$>$@{operator$>$$>$}}
\index{operator$>$$>$@{operator$>$$>$}!ibitstream@{ibitstream}}
\subsubsection{\texorpdfstring{operator$>$$>$()}{operator>>()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \hyperlink{classibitstream}{ibitstream} \& ibitstream\+::operator$>$$>$ (\begin{DoxyParamCaption}\item[{unsigned int \&}]{n }\end{DoxyParamCaption})}



reads an unsigned int from the input using Elias delta decoding and saves it in the reference given 


\begin{DoxyCode}
383                                                    \{
384   \textcolor{comment}{// implement Elias delta decoding}
385   \textcolor{comment}{//bitset<32> B(buffer);}
386   \textcolor{comment}{//cerr << " buffer " << B << endl;}
387   \textcolor{comment}{//cerr << " head " << bitset<32>(head\_mask) << endl;}
388   \textcolor{comment}{//cerr << " head position " << head\_place << endl;}
389   
390   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} L = 0;
391   \textcolor{keywordflow}{while} (!\hyperlink{classibitstream_a895239acf7179f6778388c39c97643e4}{read\_bit}())\{
392     \textcolor{comment}{// read until reach one}
393     L++;
394   \}
395   \textcolor{comment}{//cerr << " L " << L << endl;}
396   
397   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} N;
398   \textcolor{keywordflow}{if} (L == 0)\{\textcolor{comment}{// special case, avoid going over further calculations}
399     n = 0; \textcolor{comment}{// we had subtracted one when encoding }
400     \textcolor{keywordflow}{return} *\textcolor{keyword}{this};
401   \}
402   N = \hyperlink{classibitstream_a2fdcaecf10fefa6942dcd5286a2696e0}{read\_bits}(L); \textcolor{comment}{// read L digits}
403   
404   N += (1<<L); \textcolor{comment}{// we must add 2^L}
405   N --; \textcolor{comment}{// this was N + 1}
406   
407   n = \hyperlink{classibitstream_a2fdcaecf10fefa6942dcd5286a2696e0}{read\_bits}(N); \textcolor{comment}{// read N digits}
408   n += (1 << N); \textcolor{comment}{// we must add 2^N}
409   n --; \textcolor{comment}{// when we encoded, in order to get a positive integer, we added one, now we subtract one}
410   \textcolor{keywordflow}{return} *\textcolor{keyword}{this};
411 \}
\end{DoxyCode}
\mbox{\Hypertarget{classibitstream_a0264d01fa1211c4bb73f5de2bc68adbc}\label{classibitstream_a0264d01fa1211c4bb73f5de2bc68adbc}} 
\index{ibitstream@{ibitstream}!operator$>$$>$@{operator$>$$>$}}
\index{operator$>$$>$@{operator$>$$>$}!ibitstream@{ibitstream}}
\subsubsection{\texorpdfstring{operator$>$$>$()}{operator>>()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \hyperlink{classibitstream}{ibitstream} \& ibitstream\+::operator$>$$>$ (\begin{DoxyParamCaption}\item[{mpz\+\_\+class \&}]{n }\end{DoxyParamCaption})}



reads a nonnegative mpz\+\_\+class integer using Elias delta decoding and stores in the reference given 


\begin{DoxyCode}
413                                                 \{
414   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} L = 0;
415   \textcolor{comment}{//cout << "head\_place " << head\_place << endl;}
416   \textcolor{comment}{//cout << "head\_mask  " << head\_mask << endl;}
417   \textcolor{keywordflow}{while} (!\hyperlink{classibitstream_a895239acf7179f6778388c39c97643e4}{read\_bit}())\{
418     \textcolor{comment}{// read until reach one}
419     L++;
420   \}
421 
422   \textcolor{comment}{//cout << " L = " << L << endl;}
423   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} N;
424   \textcolor{keywordflow}{if} (L == 0)\{\textcolor{comment}{// special case, avoid going over further calculations}
425     n = 0; \textcolor{comment}{// we had subtracted one when encoding }
426     \textcolor{keywordflow}{return} *\textcolor{keyword}{this};
427   \}
428 
429   N = \hyperlink{classibitstream_a2fdcaecf10fefa6942dcd5286a2696e0}{read\_bits}(L); \textcolor{comment}{// read L digits}
430   
431   N += (1<<L); \textcolor{comment}{// we must add 2^L}
432   N --; \textcolor{comment}{// this was N + 1}
433 
434   \textcolor{comment}{// we must read N bits and form n based on that}
435 
436   \hyperlink{classbit__pipe}{bit\_pipe} B;
437   \textcolor{comment}{//cout << " N " << N << endl;}
438   \hyperlink{classibitstream_a2fdcaecf10fefa6942dcd5286a2696e0}{read\_bits}(N, B);
439   \textcolor{comment}{//cout << " B first " << B << endl;}
440   \textcolor{comment}{// we should add a leading 1 to B}
441   \textcolor{comment}{// in order to do so, we should consider 2 cases:}
442   \textcolor{keywordflow}{if} (N % \hyperlink{bitstream_8h_afcadf5aa65c5159bfb96c4d82ebc0a5d}{BIT\_INT} == 0)\{
443     \textcolor{comment}{// this is the tricky case, since B now contains full chunks and there is no room to add the leading 1}
444     \textcolor{comment}{// so we need to insert a chunk at the beginning and place the leading bit there}
445     \textcolor{comment}{// since the leading bit will be in the rightmost bit in this case, the value of the initial chunk is 1
       in this case}
446     B.\hyperlink{classbit__pipe_a86f38af1e9736b053728033490476b50}{bits}.insert(B.\hyperlink{classbit__pipe_a86f38af1e9736b053728033490476b50}{bits}.begin(), 1);
447   \}\textcolor{keywordflow}{else}\{
448     \textcolor{comment}{// in this case, the lading bit will be placed in the first chunk of B}
449     B.\hyperlink{classbit__pipe_a86f38af1e9736b053728033490476b50}{bits}[0] |= (1 << (N % \hyperlink{bitstream_8h_afcadf5aa65c5159bfb96c4d82ebc0a5d}{BIT\_INT}));
450   \}
451   \textcolor{comment}{//cout << " B " << B << endl;}
452   \textcolor{comment}{//cout << B.bits[0] << endl;}
453 
454   \textcolor{comment}{// construct the mpz\_clas}
455   mpz\_import(n.get\_mpz\_t(),
456              B.\hyperlink{classbit__pipe_a86f38af1e9736b053728033490476b50}{bits}.size(), \textcolor{comment}{// the number of words}
457              1, \textcolor{comment}{// order: 1 means first significant word first}
458              \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{unsigned} int), \textcolor{comment}{// each word is this many bytes}
459              0, \textcolor{comment}{// endian can be 1 for most significant byte first, -1 for least significant first, or 0
       for the native endianness of the host CPU.}
460              0, \textcolor{comment}{// nails}
461              &B.\hyperlink{classbit__pipe_a86f38af1e9736b053728033490476b50}{bits}[0]); \textcolor{comment}{//&B.bits[0]);}
462 
463   n --; \textcolor{comment}{// when encoding, we added 1 to make sure it is positive}
464   \textcolor{keywordflow}{return} *\textcolor{keyword}{this};
465 \}
\end{DoxyCode}
\mbox{\Hypertarget{classibitstream_a895239acf7179f6778388c39c97643e4}\label{classibitstream_a895239acf7179f6778388c39c97643e4}} 
\index{ibitstream@{ibitstream}!read\+\_\+bit@{read\+\_\+bit}}
\index{read\+\_\+bit@{read\+\_\+bit}!ibitstream@{ibitstream}}
\subsubsection{\texorpdfstring{read\+\_\+bit()}{read\_bit()}}
{\footnotesize\ttfamily bool ibitstream\+::read\+\_\+bit (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



read one bit from input and return true if its value is 1 and false otherwise. 


\begin{DoxyCode}
468                          \{
469   \textcolor{keywordflow}{if} (\hyperlink{classibitstream_a48cd41991b6c29ea5120b53873a72a70}{head\_mask} == 0)\{ \textcolor{comment}{// nothing is in buffer}
470     \textcolor{comment}{//cerr << " read a chunk " << endl;}
471     \hyperlink{classibitstream_ac62c26004436d83f337f4aeba0895e20}{read\_chunk}();
472   \}
473   \textcolor{keywordtype}{bool} ans = \hyperlink{classibitstream_a48cd41991b6c29ea5120b53873a72a70}{head\_mask} & \hyperlink{classibitstream_a73f0b24d3d4402369f1abbb43f7f70ef}{buffer}; \textcolor{comment}{// look at the value of buffer at the bit where the
       head\_mask is pointing to}
474   \hyperlink{classibitstream_a48cd41991b6c29ea5120b53873a72a70}{head\_mask} >>= 1; \textcolor{comment}{// go one bit to the right}
475   \hyperlink{classibitstream_a7b96359ac1534a5565e6e9b0cc53a0b3}{head\_place} --;
476   \textcolor{comment}{//cerr << " read bit " << ans << endl;}
477   \textcolor{keywordflow}{return} ans;
478 \}
\end{DoxyCode}
\mbox{\Hypertarget{classibitstream_a2fdcaecf10fefa6942dcd5286a2696e0}\label{classibitstream_a2fdcaecf10fefa6942dcd5286a2696e0}} 
\index{ibitstream@{ibitstream}!read\+\_\+bits@{read\+\_\+bits}}
\index{read\+\_\+bits@{read\+\_\+bits}!ibitstream@{ibitstream}}
\subsubsection{\texorpdfstring{read\+\_\+bits()}{read\_bits()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily unsigned int ibitstream\+::read\+\_\+bits (\begin{DoxyParamCaption}\item[{unsigned int}]{k }\end{DoxyParamCaption})}



read k bits from the input, interpret it as integer (first bit read is M\+SB) and return its value. Here, k must be in the range 1 $<$= k $<$= B\+I\+T\+\_\+\+I\+NT 


\begin{DoxyCode}
274                                                 \{
275 
276   \textcolor{comment}{//cerr << " read bits with k = " << k << endl;}
277   \textcolor{keywordflow}{if} (k < 1 or k > \hyperlink{bitstream_8h_afcadf5aa65c5159bfb96c4d82ebc0a5d}{BIT\_INT})\{
278     cerr << \textcolor{stringliteral}{"ERROR: ibitstream::read\_bits called with k out of range, k = "} << k << endl;
279   \}
280   \textcolor{keywordflow}{if} (\hyperlink{classibitstream_a7b96359ac1534a5565e6e9b0cc53a0b3}{head\_place} == 0)\textcolor{comment}{// no bits left}
281     \hyperlink{classibitstream_ac62c26004436d83f337f4aeba0895e20}{read\_chunk}();
282   \textcolor{keywordflow}{if} (\hyperlink{classibitstream_a7b96359ac1534a5565e6e9b0cc53a0b3}{head\_place} >= k)\{ \textcolor{comment}{// head\_place is effectively the number of unread bits remaining in the
       buffer}
283     \textcolor{comment}{//cerr << " head\_place >= k head\_mask = " << head\_mask << " head\_place = " << head\_place << endl;}
284     \textcolor{comment}{// there are enough number of bits in the current buffer to read}
285     \textcolor{comment}{// mask the input}
286     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} mask = \hyperlink{bitstream_8cpp_a6364b017a9400a38f7a994376bb3ebee}{mask\_gen}(k); \textcolor{comment}{// k ones}
287     \textcolor{comment}{// now we should shift mask to start at head\_place}
288     mask <<= (\hyperlink{classibitstream_a7b96359ac1534a5565e6e9b0cc53a0b3}{head\_place} - k);
289     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} ans = \hyperlink{classibitstream_a73f0b24d3d4402369f1abbb43f7f70ef}{buffer} & mask; \textcolor{comment}{// mask out the corresponding bits}
290     ans >>= (\hyperlink{classibitstream_a7b96359ac1534a5565e6e9b0cc53a0b3}{head\_place} - k); \textcolor{comment}{// bring it back to LSB}
291 
292     \textcolor{comment}{// we need to shift head k bits to the right}
293     \textcolor{comment}{// in some compilers, >>= 32 does strange things, in fact it does nothing. To avoid that, I shift k - 1
       bits and then an extra 1 bit}
294     \hyperlink{classibitstream_a48cd41991b6c29ea5120b53873a72a70}{head\_mask} >>= k - 1;
295     \hyperlink{classibitstream_a48cd41991b6c29ea5120b53873a72a70}{head\_mask} >>= 1;
296     \hyperlink{classibitstream_a7b96359ac1534a5565e6e9b0cc53a0b3}{head\_place} -= k;
297     \textcolor{comment}{//cerr << " after head\_mask " << head\_mask << " head\_place = " << head\_place << endl;}
298     \textcolor{keywordflow}{return} ans;
299   \}\textcolor{keywordflow}{else}\{
300     \textcolor{comment}{// there is not enough bits in the current buffer.}
301     \textcolor{comment}{// So we should read head\_place many bits from the current buffer}
302     \textcolor{comment}{// then read another chunk from input file}
303     \textcolor{comment}{// and then read k - head\_place bits from the new buffer}
304     \textcolor{comment}{// we do these two steps recursively}
305     \textcolor{comment}{// but first need to store the number of bits we will have to read in the future, since these variables
       will be modified later:}
306     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} future\_bits = k - \hyperlink{classibitstream_a7b96359ac1534a5565e6e9b0cc53a0b3}{head\_place};
307     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} a = \hyperlink{classibitstream_a2fdcaecf10fefa6942dcd5286a2696e0}{read\_bits}(head\_place); \textcolor{comment}{// the bits from the current buffer}
308     \hyperlink{classibitstream_ac62c26004436d83f337f4aeba0895e20}{read\_chunk}();
309     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} b = \hyperlink{classibitstream_a2fdcaecf10fefa6942dcd5286a2696e0}{read\_bits}(future\_bits); \textcolor{comment}{// bits from the next buffer}
310     \textcolor{comment}{// now we need to combine these}
311     \textcolor{comment}{// in order to do so, we need to shift a to the left and combine with b}
312     \textcolor{comment}{// but the number of bits we need to shift a is exactly future bits}
313     a <<= future\_bits;
314     \textcolor{keywordflow}{return} a | b;
315   \}
316 \}
\end{DoxyCode}
\mbox{\Hypertarget{classibitstream_a4bb7a698ab44c1e2fe21b4daa880bd6c}\label{classibitstream_a4bb7a698ab44c1e2fe21b4daa880bd6c}} 
\index{ibitstream@{ibitstream}!read\+\_\+bits@{read\+\_\+bits}}
\index{read\+\_\+bits@{read\+\_\+bits}!ibitstream@{ibitstream}}
\subsubsection{\texorpdfstring{read\+\_\+bits()}{read\_bits()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void ibitstream\+::read\+\_\+bits (\begin{DoxyParamCaption}\item[{int}]{k,  }\item[{\hyperlink{classbit__pipe}{bit\+\_\+pipe} \&}]{B }\end{DoxyParamCaption})}



reads k bits from input and stores in the given \hyperlink{classbit__pipe}{bit\+\_\+pipe}. $k \geq 1$ is arbitrary. The bits are stored in the \hyperlink{classbit__pipe}{bit\+\_\+pipe} so that can be interpreted as integer (e.\+g. mpz\+\_\+class) so the L\+SB is located in the rightmost bit of the rightmost chunk (unlike the usual \hyperlink{classbit__pipe}{bit\+\_\+pipe} situation). We assume that the B given here is an empty \hyperlink{classbit__pipe}{bit\+\_\+pipe} 


\begin{DoxyCode}
366                                             \{
367   \textcolor{comment}{//cerr << " read\_bits " << k << endl;}
368   \textcolor{comment}{// assumption: B is empty bit\_pipe}
369   \textcolor{keywordflow}{if} (B.\hyperlink{classbit__pipe_a86f38af1e9736b053728033490476b50}{bits}.size() != 0 or B.\hyperlink{classbit__pipe_a0f3e84b02751803adaab499b5dad86fe}{last\_bits} != 0)\{
370     cerr << \textcolor{stringliteral}{" ERROR: ibitstream::read\_bits(int k, bit\_pipe& B) must be called with an empty bit\_pipe, a
       nonempty bitpipe is given with B.bits.size() = "} << B.\hyperlink{classbit__pipe_a86f38af1e9736b053728033490476b50}{bits}.size() << endl;
371   \}
372   \hyperlink{classibitstream_acec2e9efa21551ce8db784f5b0bbd1b5}{read\_bits\_append}(k, B);
373   \textcolor{comment}{// there might be a few zero chunks at the beginning of B which are redundant, we remove them here}
374   \textcolor{comment}{// the number of nonzero chunks is exactly the floor of k / BIT\_INT}
375   \textcolor{keywordtype}{int} nonzero\_chunks = k / \hyperlink{bitstream_8h_afcadf5aa65c5159bfb96c4d82ebc0a5d}{BIT\_INT};
376   \textcolor{keywordflow}{if} (k % \hyperlink{bitstream_8h_afcadf5aa65c5159bfb96c4d82ebc0a5d}{BIT\_INT} != 0)
377     nonzero\_chunks ++; \textcolor{comment}{// take the floor}
378   \textcolor{comment}{//cerr << " nonzero\_chunks " << nonzero\_chunks << endl;}
379   \textcolor{keywordflow}{if} (nonzero\_chunks < B.\hyperlink{classbit__pipe_a86f38af1e9736b053728033490476b50}{bits}.size())
380     B.\hyperlink{classbit__pipe_a86f38af1e9736b053728033490476b50}{bits}.erase(B.\hyperlink{classbit__pipe_a86f38af1e9736b053728033490476b50}{bits}.begin(), B.\hyperlink{classbit__pipe_a86f38af1e9736b053728033490476b50}{bits}.begin() + B.\hyperlink{classbit__pipe_a86f38af1e9736b053728033490476b50}{bits}.size() - nonzero\_chunks);
381 \}
\end{DoxyCode}
\mbox{\Hypertarget{classibitstream_acec2e9efa21551ce8db784f5b0bbd1b5}\label{classibitstream_acec2e9efa21551ce8db784f5b0bbd1b5}} 
\index{ibitstream@{ibitstream}!read\+\_\+bits\+\_\+append@{read\+\_\+bits\+\_\+append}}
\index{read\+\_\+bits\+\_\+append@{read\+\_\+bits\+\_\+append}!ibitstream@{ibitstream}}
\subsubsection{\texorpdfstring{read\+\_\+bits\+\_\+append()}{read\_bits\_append()}}
{\footnotesize\ttfamily void ibitstream\+::read\+\_\+bits\+\_\+append (\begin{DoxyParamCaption}\item[{int}]{k,  }\item[{\hyperlink{classbit__pipe}{bit\+\_\+pipe} \&}]{B }\end{DoxyParamCaption})}



similar to read\+\_\+bits, but B does not have to be empty and the result will be appended to B (this is used in order to recursively implement read\+\_\+bits) 


\begin{DoxyCode}
318                                                    \{
319   \textcolor{comment}{//cout << " read\_bits called k = " << k << " head\_place = " << head\_place << endl;}
320   \textcolor{comment}{// by assumption, when calling this function, B has full chunks (last\_bits is either zero so BIT\_INT)}
321   \textcolor{keywordflow}{if} (k == 0)
322     \textcolor{keywordflow}{return}; \textcolor{comment}{// nothing remains to be done}
323   \textcolor{keywordflow}{if} (\hyperlink{classibitstream_a7b96359ac1534a5565e6e9b0cc53a0b3}{head\_place} == 0)\{
324     \textcolor{comment}{// we are over with the current bits in the buffer}
325     \textcolor{comment}{// so we need to load a few chunks from the input}
326     \textcolor{comment}{// we should append k / BIT\_INT full chunks to B and then k % BIT\_INT bits from the next chunk}
327     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} full\_chunks = k / \hyperlink{bitstream_8h_afcadf5aa65c5159bfb96c4d82ebc0a5d}{BIT\_INT};
328     \textcolor{keywordflow}{if} (full\_chunks > 0)\{
329       B.\hyperlink{classbit__pipe_a86f38af1e9736b053728033490476b50}{bits}.resize(B.\hyperlink{classbit__pipe_a86f38af1e9736b053728033490476b50}{bits}.size() + full\_chunks);
330       fread(&B.\hyperlink{classbit__pipe_a86f38af1e9736b053728033490476b50}{bits}[B.\hyperlink{classbit__pipe_a86f38af1e9736b053728033490476b50}{bits}.size() - full\_chunks], \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{unsigned} int), full\_chunks, 
      \hyperlink{classibitstream_a3ea2cdd0cf97820f0e1520c42e364308}{f}); \textcolor{comment}{// read full\_chunks many chunks}
331       B.\hyperlink{classbit__pipe_a0f3e84b02751803adaab499b5dad86fe}{last\_bits} = \hyperlink{bitstream_8h_afcadf5aa65c5159bfb96c4d82ebc0a5d}{BIT\_INT}; \textcolor{comment}{// the last chunk contains full bits }
332     \}
333     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} res\_bits = k % \hyperlink{bitstream_8h_afcadf5aa65c5159bfb96c4d82ebc0a5d}{BIT\_INT}; \textcolor{comment}{// the remaining bits to be read}
334     \textcolor{keywordflow}{if} (res\_bits > 0)\{
335       \textcolor{comment}{// we need to read an extra res bits}
336       \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} res = \hyperlink{classibitstream_a2fdcaecf10fefa6942dcd5286a2696e0}{read\_bits} (res\_bits); \textcolor{comment}{// read res many bits}
337       \textcolor{comment}{// we should shift res\_bits so that its MSB is the leftmost bits of the chunk}
338       res <<= (\hyperlink{bitstream_8h_afcadf5aa65c5159bfb96c4d82ebc0a5d}{BIT\_INT} - res\_bits);
339       B.\hyperlink{classbit__pipe_a86f38af1e9736b053728033490476b50}{bits}.push\_back(res);
340       B.\hyperlink{classbit__pipe_a0f3e84b02751803adaab499b5dad86fe}{last\_bits} = res\_bits;
341     \}
342   \}\textcolor{keywordflow}{else}\{
343     \textcolor{keywordflow}{if} (k <= \hyperlink{classibitstream_a7b96359ac1534a5565e6e9b0cc53a0b3}{head\_place})\{
344       \textcolor{comment}{// there are enough bits to read}
345       \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} a = \hyperlink{classibitstream_a2fdcaecf10fefa6942dcd5286a2696e0}{read\_bits}(k);
346       \textcolor{comment}{// no need to shift a since we need LSB of a to be in the rightmost bit}
347       B.\hyperlink{classbit__pipe_a86f38af1e9736b053728033490476b50}{bits}.push\_back(a);
348       B.\hyperlink{classbit__pipe_a0f3e84b02751803adaab499b5dad86fe}{last\_bits} = \hyperlink{bitstream_8h_afcadf5aa65c5159bfb96c4d82ebc0a5d}{BIT\_INT};
349     \}\textcolor{keywordflow}{else}\{
350       \textcolor{comment}{// read head\_place bits and call again}
351       \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} future\_read; \textcolor{comment}{// number of bits to read in future after calling the read\_bits function
       below}
352       future\_read = k - \hyperlink{classibitstream_a7b96359ac1534a5565e6e9b0cc53a0b3}{head\_place}; 
353       \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} a = \hyperlink{classibitstream_a2fdcaecf10fefa6942dcd5286a2696e0}{read\_bits}(head\_place);
354       B.\hyperlink{classbit__pipe_a86f38af1e9736b053728033490476b50}{bits}.push\_back(a);
355       B.\hyperlink{classbit__pipe_a0f3e84b02751803adaab499b5dad86fe}{last\_bits} = \hyperlink{bitstream_8h_afcadf5aa65c5159bfb96c4d82ebc0a5d}{BIT\_INT};
356       \hyperlink{classibitstream_acec2e9efa21551ce8db784f5b0bbd1b5}{read\_bits\_append}(future\_read, B); \textcolor{comment}{// read the remaining bits }
357     \}
358   \}
359 
360   B.\hyperlink{classbit__pipe_a341a1f62d728a67f730503ca722a7770}{shift\_right}(\hyperlink{bitstream_8h_afcadf5aa65c5159bfb96c4d82ebc0a5d}{BIT\_INT} - B.\hyperlink{classbit__pipe_a0f3e84b02751803adaab499b5dad86fe}{last\_bits}); \textcolor{comment}{// so that LSB of B is the rightmost bit
       of the lats chunk.}
361 
362   \textcolor{comment}{// this is important to make sure that B is correctly representing an integer and can be converted to
       mpz\_class}
363   \textcolor{comment}{// TODO issue of 2^k - 1 correct}
364 \}
\end{DoxyCode}
\mbox{\Hypertarget{classibitstream_ac62c26004436d83f337f4aeba0895e20}\label{classibitstream_ac62c26004436d83f337f4aeba0895e20}} 
\index{ibitstream@{ibitstream}!read\+\_\+chunk@{read\+\_\+chunk}}
\index{read\+\_\+chunk@{read\+\_\+chunk}!ibitstream@{ibitstream}}
\subsubsection{\texorpdfstring{read\+\_\+chunk()}{read\_chunk()}}
{\footnotesize\ttfamily void ibitstream\+::read\+\_\+chunk (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



reads one chunk (4 bytes) from the input file and stores it in buffer 


\begin{DoxyCode}
266                            \{
267   fread(&\hyperlink{classibitstream_a73f0b24d3d4402369f1abbb43f7f70ef}{buffer}, \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}), 1, \hyperlink{classibitstream_a3ea2cdd0cf97820f0e1520c42e364308}{f});
268   \textcolor{comment}{//cout << " in read chunk  buffer = " << bitset<32>(buffer) << endl;}
269   \hyperlink{classibitstream_a48cd41991b6c29ea5120b53873a72a70}{head\_mask} = 1 << (\hyperlink{bitstream_8h_afcadf5aa65c5159bfb96c4d82ebc0a5d}{BIT\_INT} - 1); \textcolor{comment}{// pointing to the MSB which is the first bit to consider}
270   \hyperlink{classibitstream_a7b96359ac1534a5565e6e9b0cc53a0b3}{head\_place} = \hyperlink{bitstream_8h_afcadf5aa65c5159bfb96c4d82ebc0a5d}{BIT\_INT};
271 \}
\end{DoxyCode}


\subsection{Member Data Documentation}
\mbox{\Hypertarget{classibitstream_a73f0b24d3d4402369f1abbb43f7f70ef}\label{classibitstream_a73f0b24d3d4402369f1abbb43f7f70ef}} 
\index{ibitstream@{ibitstream}!buffer@{buffer}}
\index{buffer@{buffer}!ibitstream@{ibitstream}}
\subsubsection{\texorpdfstring{buffer}{buffer}}
{\footnotesize\ttfamily unsigned int ibitstream\+::buffer\hspace{0.3cm}{\ttfamily [private]}}



the last chunk read from the input 

\mbox{\Hypertarget{classibitstream_a3ea2cdd0cf97820f0e1520c42e364308}\label{classibitstream_a3ea2cdd0cf97820f0e1520c42e364308}} 
\index{ibitstream@{ibitstream}!f@{f}}
\index{f@{f}!ibitstream@{ibitstream}}
\subsubsection{\texorpdfstring{f}{f}}
{\footnotesize\ttfamily F\+I\+LE$\ast$ ibitstream\+::f\hspace{0.3cm}{\ttfamily [private]}}



pointer to input binary file 

\mbox{\Hypertarget{classibitstream_a48cd41991b6c29ea5120b53873a72a70}\label{classibitstream_a48cd41991b6c29ea5120b53873a72a70}} 
\index{ibitstream@{ibitstream}!head\+\_\+mask@{head\+\_\+mask}}
\index{head\+\_\+mask@{head\+\_\+mask}!ibitstream@{ibitstream}}
\subsubsection{\texorpdfstring{head\+\_\+mask}{head\_mask}}
{\footnotesize\ttfamily unsigned int ibitstream\+::head\+\_\+mask\hspace{0.3cm}{\ttfamily [private]}}



the place of the head bit in buffer, represented in terms of mask. So if we are in the L\+SB, head\+\_\+mask is one, if we are in two bit left of L\+SB, this is 4 so on. When this is zero, it means the buffer is expired and we should probably read one more chunk from the input file 

\mbox{\Hypertarget{classibitstream_a7b96359ac1534a5565e6e9b0cc53a0b3}\label{classibitstream_a7b96359ac1534a5565e6e9b0cc53a0b3}} 
\index{ibitstream@{ibitstream}!head\+\_\+place@{head\+\_\+place}}
\index{head\+\_\+place@{head\+\_\+place}!ibitstream@{ibitstream}}
\subsubsection{\texorpdfstring{head\+\_\+place}{head\_place}}
{\footnotesize\ttfamily unsigned int ibitstream\+::head\+\_\+place\hspace{0.3cm}{\ttfamily [private]}}



the place of head represented in terms of integer, L\+SB is 1, left of L\+SB is 2, 2 left of L\+SB is 3 and so on. head\+\_\+place is effectively the number of unread bits remaining in the buffer. 



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
\hyperlink{bitstream_8h}{bitstream.\+h}\item 
\hyperlink{bitstream_8cpp}{bitstream.\+cpp}\end{DoxyCompactItemize}
