\hypertarget{classibitstream}{}\section{ibitstream Class Reference}
\label{classibitstream}\index{ibitstream@{ibitstream}}


deals with reading bit streams from binary files, this is the reverse of obitstream  




{\ttfamily \#include $<$bitstream.\+h$>$}

\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classibitstream_ac62c26004436d83f337f4aeba0895e20}{read\+\_\+chunk} ()
\begin{DoxyCompactList}\small\item\em reads one chunk (4 bytes) from the input file and stores it in buffer \end{DoxyCompactList}\item 
unsigned int \hyperlink{classibitstream_a2fdcaecf10fefa6942dcd5286a2696e0}{read\+\_\+bits} (unsigned int k)
\begin{DoxyCompactList}\small\item\em read k bits from the input, interpret it as integer (first bit read is M\+SB) and return its value. Here, k must be in the range 1 $<$= k $<$= B\+I\+T\+\_\+\+I\+NT \end{DoxyCompactList}\item 
void \hyperlink{classibitstream_a4bb7a698ab44c1e2fe21b4daa880bd6c}{read\+\_\+bits} (int k, \hyperlink{classbit__pipe}{bit\+\_\+pipe} \&B)
\begin{DoxyCompactList}\small\item\em reads k bits from input and stores in the given \hyperlink{classbit__pipe}{bit\+\_\+pipe}. $k \geq 1$ is arbitrary. The bits are stored in the \hyperlink{classbit__pipe}{bit\+\_\+pipe} so that can be interpreted as integer (e.\+g. mpz\+\_\+class) so the L\+SB is located in the rightmost bit of the rightmost chunk (unlike the usual \hyperlink{classbit__pipe}{bit\+\_\+pipe} situation). We assume that the B given here is an empty \hyperlink{classbit__pipe}{bit\+\_\+pipe} \end{DoxyCompactList}\item 
void \hyperlink{classibitstream_acec2e9efa21551ce8db784f5b0bbd1b5}{read\+\_\+bits\+\_\+append} (int k, \hyperlink{classbit__pipe}{bit\+\_\+pipe} \&B)
\begin{DoxyCompactList}\small\item\em similar to read\+\_\+bits, but B does not have to be empty and the result will be appended to B (this is used in order to recursively implement read\+\_\+bits) \end{DoxyCompactList}\item 
bool \hyperlink{classibitstream_a895239acf7179f6778388c39c97643e4}{read\+\_\+bit} ()
\begin{DoxyCompactList}\small\item\em read one bit from input and return true if its value is 1 and false otherwise. \end{DoxyCompactList}\item 
\hyperlink{classibitstream_af5f00b64072ed3ffe495b7712a71e3eb}{ibitstream} (string file\+\_\+name)
\item 
\hyperlink{classibitstream}{ibitstream} \& \hyperlink{classibitstream_ae3e91ecc9ff17eef98d72d44aec02eca}{operator$>$$>$} (unsigned int \&n)
\begin{DoxyCompactList}\small\item\em reads an unsigned int from the input using Elias delta decoding and saves it in the reference given \end{DoxyCompactList}\item 
\hyperlink{classibitstream}{ibitstream} \& \hyperlink{classibitstream_a0264d01fa1211c4bb73f5de2bc68adbc}{operator$>$$>$} (mpz\+\_\+class \&n)
\begin{DoxyCompactList}\small\item\em reads a nonnegative mpz\+\_\+class integer using Elias delta decoding and stores in the reference given \end{DoxyCompactList}\item 
void \hyperlink{classibitstream_aa7b59600e58571b802d6d0dadf92d37a}{close} ()
\begin{DoxyCompactList}\small\item\em closes the session by closing the input file \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
F\+I\+LE $\ast$ \hyperlink{classibitstream_a3ea2cdd0cf97820f0e1520c42e364308}{f}
\begin{DoxyCompactList}\small\item\em pointer to input binary file \end{DoxyCompactList}\item 
unsigned int \hyperlink{classibitstream_a73f0b24d3d4402369f1abbb43f7f70ef}{buffer}
\begin{DoxyCompactList}\small\item\em the last chunk read from the input \end{DoxyCompactList}\item 
unsigned int \hyperlink{classibitstream_a48cd41991b6c29ea5120b53873a72a70}{head\+\_\+mask}
\begin{DoxyCompactList}\small\item\em the place of the head bit in buffer, represented in terms of mask. So if we are in the L\+SB, head\+\_\+mask is one, if we are in two bit left of L\+SB, this is 4 so on. When this is zero, it means the buffer is expired and we should probably read one more chunk from the input file \end{DoxyCompactList}\item 
unsigned int \hyperlink{classibitstream_a7b96359ac1534a5565e6e9b0cc53a0b3}{head\+\_\+place}
\begin{DoxyCompactList}\small\item\em the place of head represented in terms of integer, L\+SB is 1, left of L\+SB is 2, 2 left of L\+SB is 3 and so on. head\+\_\+place is effectively the number of unread bits remaining in the buffer. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
deals with reading bit streams from binary files, this is the reverse of obitstream 

\subsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classibitstream_af5f00b64072ed3ffe495b7712a71e3eb}\label{classibitstream_af5f00b64072ed3ffe495b7712a71e3eb}} 
\index{ibitstream@{ibitstream}!ibitstream@{ibitstream}}
\index{ibitstream@{ibitstream}!ibitstream@{ibitstream}}
\subsubsection{\texorpdfstring{ibitstream()}{ibitstream()}}
{\footnotesize\ttfamily ibitstream\+::ibitstream (\begin{DoxyParamCaption}\item[{string}]{file\+\_\+name }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}


\begin{DoxyCode}
128                               \{
129     \hyperlink{classibitstream_a3ea2cdd0cf97820f0e1520c42e364308}{f} = fopen(file\_name.c\_str(), \textcolor{stringliteral}{"rb+"});
130     \hyperlink{classibitstream_a73f0b24d3d4402369f1abbb43f7f70ef}{buffer} =0;
131     \hyperlink{classibitstream_a48cd41991b6c29ea5120b53873a72a70}{head\_mask} = 0;
132     \hyperlink{classibitstream_a7b96359ac1534a5565e6e9b0cc53a0b3}{head\_place} = 0;
133   \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\mbox{\Hypertarget{classibitstream_aa7b59600e58571b802d6d0dadf92d37a}\label{classibitstream_aa7b59600e58571b802d6d0dadf92d37a}} 
\index{ibitstream@{ibitstream}!close@{close}}
\index{close@{close}!ibitstream@{ibitstream}}
\subsubsection{\texorpdfstring{close()}{close()}}
{\footnotesize\ttfamily void ibitstream\+::close (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



closes the session by closing the input file 


\begin{DoxyCode}
142 \{fclose(\hyperlink{classibitstream_a3ea2cdd0cf97820f0e1520c42e364308}{f});\}
\end{DoxyCode}
\mbox{\Hypertarget{classibitstream_ae3e91ecc9ff17eef98d72d44aec02eca}\label{classibitstream_ae3e91ecc9ff17eef98d72d44aec02eca}} 
\index{ibitstream@{ibitstream}!operator$>$$>$@{operator$>$$>$}}
\index{operator$>$$>$@{operator$>$$>$}!ibitstream@{ibitstream}}
\subsubsection{\texorpdfstring{operator$>$$>$()}{operator>>()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \hyperlink{classibitstream}{ibitstream} \& ibitstream\+::operator$>$$>$ (\begin{DoxyParamCaption}\item[{unsigned int \&}]{n }\end{DoxyParamCaption})}



reads an unsigned int from the input using Elias delta decoding and saves it in the reference given 


\begin{DoxyCode}
381                                                    \{
382   \textcolor{comment}{// implement Elias delta decoding}
383   \textcolor{comment}{//bitset<32> B(buffer);}
384   \textcolor{comment}{//cerr << " buffer " << B << endl;}
385   \textcolor{comment}{//cerr << " head " << bitset<32>(head\_mask) << endl;}
386   \textcolor{comment}{//cerr << " head position " << head\_place << endl;}
387   
388   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} L = 0;
389   \textcolor{keywordflow}{while} (!\hyperlink{classibitstream_a895239acf7179f6778388c39c97643e4}{read\_bit}())\{
390     \textcolor{comment}{// read until reach one}
391     L++;
392   \}
393   \textcolor{comment}{//cerr << " L " << L << endl;}
394   
395   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} N;
396   \textcolor{keywordflow}{if} (L == 0)\{\textcolor{comment}{// special case, avoid going over further calculations}
397     n = 0; \textcolor{comment}{// we had subtracted one when encoding }
398     \textcolor{keywordflow}{return} *\textcolor{keyword}{this};
399   \}
400   N = \hyperlink{classibitstream_a2fdcaecf10fefa6942dcd5286a2696e0}{read\_bits}(L); \textcolor{comment}{// read L digits}
401   
402   N += (1<<L); \textcolor{comment}{// we must add 2^L}
403   N --; \textcolor{comment}{// this was N + 1}
404   
405   n = \hyperlink{classibitstream_a2fdcaecf10fefa6942dcd5286a2696e0}{read\_bits}(N); \textcolor{comment}{// read N digits}
406   n += (1 << N); \textcolor{comment}{// we must add 2^N}
407   n --; \textcolor{comment}{// when we encoded, in order to get a positive integer, we added one, now we subtract one}
408   \textcolor{keywordflow}{return} *\textcolor{keyword}{this};
409 \}
\end{DoxyCode}
\mbox{\Hypertarget{classibitstream_a0264d01fa1211c4bb73f5de2bc68adbc}\label{classibitstream_a0264d01fa1211c4bb73f5de2bc68adbc}} 
\index{ibitstream@{ibitstream}!operator$>$$>$@{operator$>$$>$}}
\index{operator$>$$>$@{operator$>$$>$}!ibitstream@{ibitstream}}
\subsubsection{\texorpdfstring{operator$>$$>$()}{operator>>()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \hyperlink{classibitstream}{ibitstream} \& ibitstream\+::operator$>$$>$ (\begin{DoxyParamCaption}\item[{mpz\+\_\+class \&}]{n }\end{DoxyParamCaption})}



reads a nonnegative mpz\+\_\+class integer using Elias delta decoding and stores in the reference given 


\begin{DoxyCode}
411                                                 \{
412   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} L = 0;
413   \textcolor{comment}{//cout << "head\_place " << head\_place << endl;}
414   \textcolor{comment}{//cout << "head\_mask  " << head\_mask << endl;}
415   \textcolor{keywordflow}{while} (!\hyperlink{classibitstream_a895239acf7179f6778388c39c97643e4}{read\_bit}())\{
416     \textcolor{comment}{// read until reach one}
417     L++;
418   \}
419 
420   \textcolor{comment}{//cout << " L = " << L << endl;}
421   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} N;
422   \textcolor{keywordflow}{if} (L == 0)\{\textcolor{comment}{// special case, avoid going over further calculations}
423     n = 0; \textcolor{comment}{// we had subtracted one when encoding }
424     \textcolor{keywordflow}{return} *\textcolor{keyword}{this};
425   \}
426 
427   N = \hyperlink{classibitstream_a2fdcaecf10fefa6942dcd5286a2696e0}{read\_bits}(L); \textcolor{comment}{// read L digits}
428   
429   N += (1<<L); \textcolor{comment}{// we must add 2^L}
430   N --; \textcolor{comment}{// this was N + 1}
431 
432   \textcolor{comment}{// we must read N bits and form n based on that}
433 
434   \hyperlink{classbit__pipe}{bit\_pipe} B;
435   \textcolor{comment}{//cout << " N " << N << endl;}
436   \hyperlink{classibitstream_a2fdcaecf10fefa6942dcd5286a2696e0}{read\_bits}(N, B);
437   \textcolor{comment}{//cout << " B first " << B << endl;}
438   \textcolor{comment}{// we should add a leading 1 to B}
439   \textcolor{comment}{// in order to do so, we should consider 2 cases:}
440   \textcolor{keywordflow}{if} (N % \hyperlink{bitstream_8h_afcadf5aa65c5159bfb96c4d82ebc0a5d}{BIT\_INT} == 0)\{
441     \textcolor{comment}{// this is the tricky case, since B now contains full chunks and there is no room to add the leading 1}
442     \textcolor{comment}{// so we need to insert a chunk at the beginning and place the leading bit there}
443     \textcolor{comment}{// since the leading bit will be in the rightmost bit in this case, the value of the initial chunk is 1
       in this case}
444     B.\hyperlink{classbit__pipe_a86f38af1e9736b053728033490476b50}{bits}.insert(B.\hyperlink{classbit__pipe_a86f38af1e9736b053728033490476b50}{bits}.begin(), 1);
445   \}\textcolor{keywordflow}{else}\{
446     \textcolor{comment}{// in this case, the lading bit will be placed in the first chunk of B}
447     B.\hyperlink{classbit__pipe_a86f38af1e9736b053728033490476b50}{bits}[0] |= (1 << (N % \hyperlink{bitstream_8h_afcadf5aa65c5159bfb96c4d82ebc0a5d}{BIT\_INT}));
448   \}
449   \textcolor{comment}{//cout << " B " << B << endl;}
450   \textcolor{comment}{//cout << B.bits[0] << endl;}
451 
452   \textcolor{comment}{// construct the mpz\_clas}
453   mpz\_import(n.get\_mpz\_t(),
454              B.\hyperlink{classbit__pipe_a86f38af1e9736b053728033490476b50}{bits}.size(), \textcolor{comment}{// the number of words}
455              1, \textcolor{comment}{// order: 1 means first significant word first}
456              \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{unsigned} int), \textcolor{comment}{// each word is this many bytes}
457              0, \textcolor{comment}{// endian can be 1 for most significant byte first, -1 for least significant first, or 0
       for the native endianness of the host CPU.}
458              0, \textcolor{comment}{// nails}
459              &B.\hyperlink{classbit__pipe_a86f38af1e9736b053728033490476b50}{bits}[0]); \textcolor{comment}{//&B.bits[0]);}
460 
461   n --; \textcolor{comment}{// when encoding, we added 1 to make sure it is positive}
462   \textcolor{keywordflow}{return} *\textcolor{keyword}{this};
463 \}
\end{DoxyCode}
\mbox{\Hypertarget{classibitstream_a895239acf7179f6778388c39c97643e4}\label{classibitstream_a895239acf7179f6778388c39c97643e4}} 
\index{ibitstream@{ibitstream}!read\+\_\+bit@{read\+\_\+bit}}
\index{read\+\_\+bit@{read\+\_\+bit}!ibitstream@{ibitstream}}
\subsubsection{\texorpdfstring{read\+\_\+bit()}{read\_bit()}}
{\footnotesize\ttfamily bool ibitstream\+::read\+\_\+bit (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



read one bit from input and return true if its value is 1 and false otherwise. 


\begin{DoxyCode}
466                          \{
467   \textcolor{keywordflow}{if} (\hyperlink{classibitstream_a48cd41991b6c29ea5120b53873a72a70}{head\_mask} == 0)\{ \textcolor{comment}{// nothing is in buffer}
468     \textcolor{comment}{//cerr << " read a chunk " << endl;}
469     \hyperlink{classibitstream_ac62c26004436d83f337f4aeba0895e20}{read\_chunk}();
470   \}
471   \textcolor{keywordtype}{bool} ans = \hyperlink{classibitstream_a48cd41991b6c29ea5120b53873a72a70}{head\_mask} & \hyperlink{classibitstream_a73f0b24d3d4402369f1abbb43f7f70ef}{buffer}; \textcolor{comment}{// look at the value of buffer at the bit where the
       head\_mask is pointing to}
472   \hyperlink{classibitstream_a48cd41991b6c29ea5120b53873a72a70}{head\_mask} >>= 1; \textcolor{comment}{// go one bit to the right}
473   \hyperlink{classibitstream_a7b96359ac1534a5565e6e9b0cc53a0b3}{head\_place} --;
474   \textcolor{comment}{//cerr << " read bit " << ans << endl;}
475   \textcolor{keywordflow}{return} ans;
476 \}
\end{DoxyCode}
\mbox{\Hypertarget{classibitstream_a2fdcaecf10fefa6942dcd5286a2696e0}\label{classibitstream_a2fdcaecf10fefa6942dcd5286a2696e0}} 
\index{ibitstream@{ibitstream}!read\+\_\+bits@{read\+\_\+bits}}
\index{read\+\_\+bits@{read\+\_\+bits}!ibitstream@{ibitstream}}
\subsubsection{\texorpdfstring{read\+\_\+bits()}{read\_bits()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily unsigned int ibitstream\+::read\+\_\+bits (\begin{DoxyParamCaption}\item[{unsigned int}]{k }\end{DoxyParamCaption})}



read k bits from the input, interpret it as integer (first bit read is M\+SB) and return its value. Here, k must be in the range 1 $<$= k $<$= B\+I\+T\+\_\+\+I\+NT 


\begin{DoxyCode}
272                                                 \{
273 
274   \textcolor{comment}{//cerr << " read bits with k = " << k << endl;}
275   \textcolor{keywordflow}{if} (k < 1 or k > \hyperlink{bitstream_8h_afcadf5aa65c5159bfb96c4d82ebc0a5d}{BIT\_INT})\{
276     cerr << \textcolor{stringliteral}{"ERROR: ibitstream::read\_bits called with k out of range, k = "} << k << endl;
277   \}
278   \textcolor{keywordflow}{if} (\hyperlink{classibitstream_a7b96359ac1534a5565e6e9b0cc53a0b3}{head\_place} == 0)\textcolor{comment}{// no bits left}
279     \hyperlink{classibitstream_ac62c26004436d83f337f4aeba0895e20}{read\_chunk}();
280   \textcolor{keywordflow}{if} (\hyperlink{classibitstream_a7b96359ac1534a5565e6e9b0cc53a0b3}{head\_place} >= k)\{ \textcolor{comment}{// head\_place is effectively the number of unread bits remaining in the
       buffer}
281     \textcolor{comment}{//cerr << " head\_place >= k head\_mask = " << head\_mask << " head\_place = " << head\_place << endl;}
282     \textcolor{comment}{// there are enough number of bits in the current buffer to read}
283     \textcolor{comment}{// mask the input}
284     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} mask = \hyperlink{bitstream_8cpp_a6364b017a9400a38f7a994376bb3ebee}{mask\_gen}(k); \textcolor{comment}{// k ones}
285     \textcolor{comment}{// now we should shift mask to start at head\_place}
286     mask <<= (\hyperlink{classibitstream_a7b96359ac1534a5565e6e9b0cc53a0b3}{head\_place} - k);
287     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} ans = \hyperlink{classibitstream_a73f0b24d3d4402369f1abbb43f7f70ef}{buffer} & mask; \textcolor{comment}{// mask out the corresponding bits}
288     ans >>= (\hyperlink{classibitstream_a7b96359ac1534a5565e6e9b0cc53a0b3}{head\_place} - k); \textcolor{comment}{// bring it back to LSB}
289 
290     \textcolor{comment}{// we need to shift head k bits to the right}
291     \textcolor{comment}{// in some compilers, >>= 32 does strange things, in fact it does nothing. To avoid that, I shift k - 1
       bits and then an extra 1 bit}
292     \hyperlink{classibitstream_a48cd41991b6c29ea5120b53873a72a70}{head\_mask} >>= k - 1;
293     \hyperlink{classibitstream_a48cd41991b6c29ea5120b53873a72a70}{head\_mask} >>= 1;
294     \hyperlink{classibitstream_a7b96359ac1534a5565e6e9b0cc53a0b3}{head\_place} -= k;
295     \textcolor{comment}{//cerr << " after head\_mask " << head\_mask << " head\_place = " << head\_place << endl;}
296     \textcolor{keywordflow}{return} ans;
297   \}\textcolor{keywordflow}{else}\{
298     \textcolor{comment}{// there is not enough bits in the current buffer.}
299     \textcolor{comment}{// So we should read head\_place many bits from the current buffer}
300     \textcolor{comment}{// then read another chunk from input file}
301     \textcolor{comment}{// and then read k - head\_place bits from the new buffer}
302     \textcolor{comment}{// we do these two steps recursively}
303     \textcolor{comment}{// but first need to store the number of bits we will have to read in the future, since these variables
       will be modified later:}
304     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} future\_bits = k - \hyperlink{classibitstream_a7b96359ac1534a5565e6e9b0cc53a0b3}{head\_place};
305     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} a = \hyperlink{classibitstream_a2fdcaecf10fefa6942dcd5286a2696e0}{read\_bits}(head\_place); \textcolor{comment}{// the bits from the current buffer}
306     \hyperlink{classibitstream_ac62c26004436d83f337f4aeba0895e20}{read\_chunk}();
307     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} b = \hyperlink{classibitstream_a2fdcaecf10fefa6942dcd5286a2696e0}{read\_bits}(future\_bits); \textcolor{comment}{// bits from the next buffer}
308     \textcolor{comment}{// now we need to combine these}
309     \textcolor{comment}{// in order to do so, we need to shift a to the left and combine with b}
310     \textcolor{comment}{// but the number of bits we need to shift a is exactly future bits}
311     a <<= future\_bits;
312     \textcolor{keywordflow}{return} a | b;
313   \}
314 \}
\end{DoxyCode}
\mbox{\Hypertarget{classibitstream_a4bb7a698ab44c1e2fe21b4daa880bd6c}\label{classibitstream_a4bb7a698ab44c1e2fe21b4daa880bd6c}} 
\index{ibitstream@{ibitstream}!read\+\_\+bits@{read\+\_\+bits}}
\index{read\+\_\+bits@{read\+\_\+bits}!ibitstream@{ibitstream}}
\subsubsection{\texorpdfstring{read\+\_\+bits()}{read\_bits()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void ibitstream\+::read\+\_\+bits (\begin{DoxyParamCaption}\item[{int}]{k,  }\item[{\hyperlink{classbit__pipe}{bit\+\_\+pipe} \&}]{B }\end{DoxyParamCaption})}



reads k bits from input and stores in the given \hyperlink{classbit__pipe}{bit\+\_\+pipe}. $k \geq 1$ is arbitrary. The bits are stored in the \hyperlink{classbit__pipe}{bit\+\_\+pipe} so that can be interpreted as integer (e.\+g. mpz\+\_\+class) so the L\+SB is located in the rightmost bit of the rightmost chunk (unlike the usual \hyperlink{classbit__pipe}{bit\+\_\+pipe} situation). We assume that the B given here is an empty \hyperlink{classbit__pipe}{bit\+\_\+pipe} 


\begin{DoxyCode}
364                                             \{
365   \textcolor{comment}{//cerr << " read\_bits " << k << endl;}
366   \textcolor{comment}{// assumption: B is empty bit\_pipe}
367   \textcolor{keywordflow}{if} (B.\hyperlink{classbit__pipe_a86f38af1e9736b053728033490476b50}{bits}.size() != 0 or B.\hyperlink{classbit__pipe_a0f3e84b02751803adaab499b5dad86fe}{last\_bits} != 0)\{
368     cerr << \textcolor{stringliteral}{" ERROR: ibitstream::read\_bits(int k, bit\_pipe& B) must be called with an empty bit\_pipe, a
       nonempty bitpipe is given with B.bits.size() = "} << B.\hyperlink{classbit__pipe_a86f38af1e9736b053728033490476b50}{bits}.size() << endl;
369   \}
370   \hyperlink{classibitstream_acec2e9efa21551ce8db784f5b0bbd1b5}{read\_bits\_append}(k, B);
371   \textcolor{comment}{// there might be a few zero chunks at the beginning of B which are redundant, we remove them here}
372   \textcolor{comment}{// the number of nonzero chunks is exactly the floor of k / BIT\_INT}
373   \textcolor{keywordtype}{int} nonzero\_chunks = k / \hyperlink{bitstream_8h_afcadf5aa65c5159bfb96c4d82ebc0a5d}{BIT\_INT};
374   \textcolor{keywordflow}{if} (k % \hyperlink{bitstream_8h_afcadf5aa65c5159bfb96c4d82ebc0a5d}{BIT\_INT} != 0)
375     nonzero\_chunks ++; \textcolor{comment}{// take the floor}
376   \textcolor{comment}{//cerr << " nonzero\_chunks " << nonzero\_chunks << endl;}
377   \textcolor{keywordflow}{if} (nonzero\_chunks < B.\hyperlink{classbit__pipe_a86f38af1e9736b053728033490476b50}{bits}.size())
378     B.\hyperlink{classbit__pipe_a86f38af1e9736b053728033490476b50}{bits}.erase(B.\hyperlink{classbit__pipe_a86f38af1e9736b053728033490476b50}{bits}.begin(), B.\hyperlink{classbit__pipe_a86f38af1e9736b053728033490476b50}{bits}.begin() + B.\hyperlink{classbit__pipe_a86f38af1e9736b053728033490476b50}{bits}.size() - nonzero\_chunks);
379 \}
\end{DoxyCode}
\mbox{\Hypertarget{classibitstream_acec2e9efa21551ce8db784f5b0bbd1b5}\label{classibitstream_acec2e9efa21551ce8db784f5b0bbd1b5}} 
\index{ibitstream@{ibitstream}!read\+\_\+bits\+\_\+append@{read\+\_\+bits\+\_\+append}}
\index{read\+\_\+bits\+\_\+append@{read\+\_\+bits\+\_\+append}!ibitstream@{ibitstream}}
\subsubsection{\texorpdfstring{read\+\_\+bits\+\_\+append()}{read\_bits\_append()}}
{\footnotesize\ttfamily void ibitstream\+::read\+\_\+bits\+\_\+append (\begin{DoxyParamCaption}\item[{int}]{k,  }\item[{\hyperlink{classbit__pipe}{bit\+\_\+pipe} \&}]{B }\end{DoxyParamCaption})}



similar to read\+\_\+bits, but B does not have to be empty and the result will be appended to B (this is used in order to recursively implement read\+\_\+bits) 


\begin{DoxyCode}
316                                                    \{
317   \textcolor{comment}{//cout << " read\_bits called k = " << k << " head\_place = " << head\_place << endl;}
318   \textcolor{comment}{// by assumption, when calling this function, B has full chunks (last\_bits is either zero so BIT\_INT)}
319   \textcolor{keywordflow}{if} (k == 0)
320     \textcolor{keywordflow}{return}; \textcolor{comment}{// nothing remains to be done}
321   \textcolor{keywordflow}{if} (\hyperlink{classibitstream_a7b96359ac1534a5565e6e9b0cc53a0b3}{head\_place} == 0)\{
322     \textcolor{comment}{// we are over with the current bits in the buffer}
323     \textcolor{comment}{// so we need to load a few chunks from the input}
324     \textcolor{comment}{// we should append k / BIT\_INT full chunks to B and then k % BIT\_INT bits from the next chunk}
325     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} full\_chunks = k / \hyperlink{bitstream_8h_afcadf5aa65c5159bfb96c4d82ebc0a5d}{BIT\_INT};
326     \textcolor{keywordflow}{if} (full\_chunks > 0)\{
327       B.\hyperlink{classbit__pipe_a86f38af1e9736b053728033490476b50}{bits}.resize(B.\hyperlink{classbit__pipe_a86f38af1e9736b053728033490476b50}{bits}.size() + full\_chunks);
328       fread(&B.\hyperlink{classbit__pipe_a86f38af1e9736b053728033490476b50}{bits}[B.\hyperlink{classbit__pipe_a86f38af1e9736b053728033490476b50}{bits}.size() - full\_chunks], \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{unsigned} int), full\_chunks, 
      \hyperlink{classibitstream_a3ea2cdd0cf97820f0e1520c42e364308}{f}); \textcolor{comment}{// read full\_chunks many chunks}
329       B.\hyperlink{classbit__pipe_a0f3e84b02751803adaab499b5dad86fe}{last\_bits} = \hyperlink{bitstream_8h_afcadf5aa65c5159bfb96c4d82ebc0a5d}{BIT\_INT}; \textcolor{comment}{// the last chunk contains full bits }
330     \}
331     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} res\_bits = k % \hyperlink{bitstream_8h_afcadf5aa65c5159bfb96c4d82ebc0a5d}{BIT\_INT}; \textcolor{comment}{// the remaining bits to be read}
332     \textcolor{keywordflow}{if} (res\_bits > 0)\{
333       \textcolor{comment}{// we need to read an extra res bits}
334       \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} res = \hyperlink{classibitstream_a2fdcaecf10fefa6942dcd5286a2696e0}{read\_bits} (res\_bits); \textcolor{comment}{// read res many bits}
335       \textcolor{comment}{// we should shift res\_bits so that its MSB is the leftmost bits of the chunk}
336       res <<= (\hyperlink{bitstream_8h_afcadf5aa65c5159bfb96c4d82ebc0a5d}{BIT\_INT} - res\_bits);
337       B.\hyperlink{classbit__pipe_a86f38af1e9736b053728033490476b50}{bits}.push\_back(res);
338       B.\hyperlink{classbit__pipe_a0f3e84b02751803adaab499b5dad86fe}{last\_bits} = res\_bits;
339     \}
340   \}\textcolor{keywordflow}{else}\{
341     \textcolor{keywordflow}{if} (k <= \hyperlink{classibitstream_a7b96359ac1534a5565e6e9b0cc53a0b3}{head\_place})\{
342       \textcolor{comment}{// there are enough bits to read}
343       \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} a = \hyperlink{classibitstream_a2fdcaecf10fefa6942dcd5286a2696e0}{read\_bits}(k);
344       \textcolor{comment}{// no need to shift a since we need LSB of a to be in the rightmost bit}
345       B.\hyperlink{classbit__pipe_a86f38af1e9736b053728033490476b50}{bits}.push\_back(a);
346       B.\hyperlink{classbit__pipe_a0f3e84b02751803adaab499b5dad86fe}{last\_bits} = \hyperlink{bitstream_8h_afcadf5aa65c5159bfb96c4d82ebc0a5d}{BIT\_INT};
347     \}\textcolor{keywordflow}{else}\{
348       \textcolor{comment}{// read head\_place bits and call again}
349       \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} future\_read; \textcolor{comment}{// number of bits to read in future after calling the read\_bits function
       below}
350       future\_read = k - \hyperlink{classibitstream_a7b96359ac1534a5565e6e9b0cc53a0b3}{head\_place}; 
351       \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} a = \hyperlink{classibitstream_a2fdcaecf10fefa6942dcd5286a2696e0}{read\_bits}(head\_place);
352       B.\hyperlink{classbit__pipe_a86f38af1e9736b053728033490476b50}{bits}.push\_back(a);
353       B.\hyperlink{classbit__pipe_a0f3e84b02751803adaab499b5dad86fe}{last\_bits} = \hyperlink{bitstream_8h_afcadf5aa65c5159bfb96c4d82ebc0a5d}{BIT\_INT};
354       \hyperlink{classibitstream_acec2e9efa21551ce8db784f5b0bbd1b5}{read\_bits\_append}(future\_read, B); \textcolor{comment}{// read the remaining bits }
355     \}
356   \}
357 
358   B.\hyperlink{classbit__pipe_a341a1f62d728a67f730503ca722a7770}{shift\_right}(\hyperlink{bitstream_8h_afcadf5aa65c5159bfb96c4d82ebc0a5d}{BIT\_INT} - B.\hyperlink{classbit__pipe_a0f3e84b02751803adaab499b5dad86fe}{last\_bits}); \textcolor{comment}{// so that LSB of B is the rightmost bit
       of the lats chunk.}
359 
360   \textcolor{comment}{// this is important to make sure that B is correctly representing an integer and can be converted to
       mpz\_class}
361   \textcolor{comment}{// TODO issue of 2^k - 1 correct}
362 \}
\end{DoxyCode}
\mbox{\Hypertarget{classibitstream_ac62c26004436d83f337f4aeba0895e20}\label{classibitstream_ac62c26004436d83f337f4aeba0895e20}} 
\index{ibitstream@{ibitstream}!read\+\_\+chunk@{read\+\_\+chunk}}
\index{read\+\_\+chunk@{read\+\_\+chunk}!ibitstream@{ibitstream}}
\subsubsection{\texorpdfstring{read\+\_\+chunk()}{read\_chunk()}}
{\footnotesize\ttfamily void ibitstream\+::read\+\_\+chunk (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



reads one chunk (4 bytes) from the input file and stores it in buffer 


\begin{DoxyCode}
264                            \{
265   fread(&\hyperlink{classibitstream_a73f0b24d3d4402369f1abbb43f7f70ef}{buffer}, \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}), 1, \hyperlink{classibitstream_a3ea2cdd0cf97820f0e1520c42e364308}{f});
266   \textcolor{comment}{//cout << " in read chunk  buffer = " << bitset<32>(buffer) << endl;}
267   \hyperlink{classibitstream_a48cd41991b6c29ea5120b53873a72a70}{head\_mask} = 1 << (\hyperlink{bitstream_8h_afcadf5aa65c5159bfb96c4d82ebc0a5d}{BIT\_INT} - 1); \textcolor{comment}{// pointing to the MSB which is the first bit to consider}
268   \hyperlink{classibitstream_a7b96359ac1534a5565e6e9b0cc53a0b3}{head\_place} = \hyperlink{bitstream_8h_afcadf5aa65c5159bfb96c4d82ebc0a5d}{BIT\_INT};
269 \}
\end{DoxyCode}


\subsection{Member Data Documentation}
\mbox{\Hypertarget{classibitstream_a73f0b24d3d4402369f1abbb43f7f70ef}\label{classibitstream_a73f0b24d3d4402369f1abbb43f7f70ef}} 
\index{ibitstream@{ibitstream}!buffer@{buffer}}
\index{buffer@{buffer}!ibitstream@{ibitstream}}
\subsubsection{\texorpdfstring{buffer}{buffer}}
{\footnotesize\ttfamily unsigned int ibitstream\+::buffer\hspace{0.3cm}{\ttfamily [private]}}



the last chunk read from the input 

\mbox{\Hypertarget{classibitstream_a3ea2cdd0cf97820f0e1520c42e364308}\label{classibitstream_a3ea2cdd0cf97820f0e1520c42e364308}} 
\index{ibitstream@{ibitstream}!f@{f}}
\index{f@{f}!ibitstream@{ibitstream}}
\subsubsection{\texorpdfstring{f}{f}}
{\footnotesize\ttfamily F\+I\+LE$\ast$ ibitstream\+::f\hspace{0.3cm}{\ttfamily [private]}}



pointer to input binary file 

\mbox{\Hypertarget{classibitstream_a48cd41991b6c29ea5120b53873a72a70}\label{classibitstream_a48cd41991b6c29ea5120b53873a72a70}} 
\index{ibitstream@{ibitstream}!head\+\_\+mask@{head\+\_\+mask}}
\index{head\+\_\+mask@{head\+\_\+mask}!ibitstream@{ibitstream}}
\subsubsection{\texorpdfstring{head\+\_\+mask}{head\_mask}}
{\footnotesize\ttfamily unsigned int ibitstream\+::head\+\_\+mask\hspace{0.3cm}{\ttfamily [private]}}



the place of the head bit in buffer, represented in terms of mask. So if we are in the L\+SB, head\+\_\+mask is one, if we are in two bit left of L\+SB, this is 4 so on. When this is zero, it means the buffer is expired and we should probably read one more chunk from the input file 

\mbox{\Hypertarget{classibitstream_a7b96359ac1534a5565e6e9b0cc53a0b3}\label{classibitstream_a7b96359ac1534a5565e6e9b0cc53a0b3}} 
\index{ibitstream@{ibitstream}!head\+\_\+place@{head\+\_\+place}}
\index{head\+\_\+place@{head\+\_\+place}!ibitstream@{ibitstream}}
\subsubsection{\texorpdfstring{head\+\_\+place}{head\_place}}
{\footnotesize\ttfamily unsigned int ibitstream\+::head\+\_\+place\hspace{0.3cm}{\ttfamily [private]}}



the place of head represented in terms of integer, L\+SB is 1, left of L\+SB is 2, 2 left of L\+SB is 3 and so on. head\+\_\+place is effectively the number of unread bits remaining in the buffer. 



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
\hyperlink{bitstream_8h}{bitstream.\+h}\item 
\hyperlink{bitstream_8cpp}{bitstream.\+cpp}\end{DoxyCompactItemize}
