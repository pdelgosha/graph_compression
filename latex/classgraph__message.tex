\hypertarget{classgraph__message}{}\section{graph\+\_\+message Class Reference}
\label{classgraph__message}\index{graph\+\_\+message@{graph\+\_\+message}}


this class takes care of message passing on marked graphs.  




{\ttfamily \#include $<$graph\+\_\+message.\+h$>$}

\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classgraph__message_a792e738b94a19f914e5495c416defe4d}{graph\+\_\+message} (const \hyperlink{classmarked__graph}{marked\+\_\+graph} \&\hyperlink{classgraph}{graph}, int depth, int max\+\_\+degree)
\begin{DoxyCompactList}\small\item\em constructor, given reference to a graph \end{DoxyCompactList}\item 
\hyperlink{classgraph__message_aa21140453eb0e1de98a2ddfcf2832aeb}{graph\+\_\+message} ()
\begin{DoxyCompactList}\small\item\em default constructor \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Public Attributes}
\begin{DoxyCompactItemize}
\item 
vector$<$ vector$<$ int $>$ $>$ \hyperlink{classgraph__message_af680c8a1755cf8d4aba389c1a3d6634e}{messages}
\begin{DoxyCompactList}\small\item\em messages\mbox{[}v\mbox{]}\mbox{[}i\mbox{]} is the integer version of the message from vertex v towards its ith neighbor (in the order given by adj\+\_\+list of vertex i in graph G). The message is at any given step that update\+\_\+messages is running, so after finishing update\+\_\+message, the messages are at step (depth) h-\/1. \end{DoxyCompactList}\item 
unordered\+\_\+map$<$ vector$<$ int $>$, int, \hyperlink{structvint__hash}{vint\+\_\+hash} $>$ \hyperlink{classgraph__message_a557473b726dc5d80618055a6b843670f}{message\+\_\+dict}
\begin{DoxyCompactList}\small\item\em message\+\_\+dict is the message dictionary at any step that update\+\_\+messages is running, which maps each message to its corresponding index in the dictionary. When update\+\_\+messages is over, this corresponds to step (depth) h-\/1 \end{DoxyCompactList}\item 
vector$<$ int $>$ \hyperlink{classgraph__message_a49d9af5150daf0599c29fe18cb032fa5}{message\+\_\+mark}
\begin{DoxyCompactList}\small\item\em for an integer message $m$, message\+\_\+mark\mbox{[}m\mbox{]} is the mark component associated to the message m at any step that update\+\_\+messages is working. This is basically the last index in the vector message associate to m. When update\+\_\+messages is over, this corresponds to step (depth) h-\/1. \end{DoxyCompactList}\item 
vector$<$ bool $>$ \hyperlink{classgraph__message_a55ff5531a0043106369e84a7bc45e22d}{is\+\_\+star\+\_\+message}
\begin{DoxyCompactList}\small\item\em for an integer message $m$, is\+\_\+star\+\_\+message\mbox{[}m\mbox{]} is true if m is a star message and false otherwise. Note that m is star type iff the first index in the vector message corresponding to m is -\/1. This is updated at step of update\+\_\+messages, so when it is over, it corresponds to step (depth) h-\/1. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classgraph__message_a40dadc59d582b290202e79bc4a9e896c}{update\+\_\+messages} (const \hyperlink{classmarked__graph}{marked\+\_\+graph} \&)
\begin{DoxyCompactList}\small\item\em performs the message passing algorithm and updates the messages array accordingly \end{DoxyCompactList}\item 
void \hyperlink{classgraph__message_aa76d1d5420a12477fa1dddd878d78c8f}{send\+\_\+message} (const vector$<$ int $>$ \&m, int v, int i)
\begin{DoxyCompactList}\small\item\em update message\+\_\+dict and message\+\_\+list \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
int \hyperlink{classgraph__message_a934d63ed7275c211e13c6fb68824ed46}{h}
\begin{DoxyCompactList}\small\item\em the depth up to which we do message passing (the type of edges go through depth h-\/1) \end{DoxyCompactList}\item 
int \hyperlink{classgraph__message_a45dfd061b7bc73572e5132fbf66efd55}{Delta}
\begin{DoxyCompactList}\small\item\em the maximum degree threshold \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
this class takes care of message passing on marked graphs. 

This graph has a reference to a \hyperlink{classmarked__graph}{marked\+\_\+graph} object for which we perform message passing to find edge types. The edge types are discovered up to depth h-\/1, and with degree parameter Delta, where h and Delta are member objects. Star type messages (which roughly speaking corresponds to places where there is a vertex in the h neighborhood has degree more than delta) are vectors of size 2, first coordinate being -\/1, and the second being the edge mark component (towards the \textquotesingle{}me\textquotesingle{} vertex).

{\itshape Sample Usage}


\begin{DoxyCode}
\hyperlink{classmarked__graph}{marked\_graph} G;
... \textcolor{comment}{//define G}
\textcolor{keywordtype}{int} h = 10;
\textcolor{keywordtype}{int} Delta = 5; 
\hyperlink{classgraph__message}{graph\_message} M(G, h, Delta);
\end{DoxyCode}
 

\subsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classgraph__message_a792e738b94a19f914e5495c416defe4d}\label{classgraph__message_a792e738b94a19f914e5495c416defe4d}} 
\index{graph\+\_\+message@{graph\+\_\+message}!graph\+\_\+message@{graph\+\_\+message}}
\index{graph\+\_\+message@{graph\+\_\+message}!graph\+\_\+message@{graph\+\_\+message}}
\subsubsection{\texorpdfstring{graph\+\_\+message()}{graph\_message()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily graph\+\_\+message\+::graph\+\_\+message (\begin{DoxyParamCaption}\item[{const \hyperlink{classmarked__graph}{marked\+\_\+graph} \&}]{graph,  }\item[{int}]{depth,  }\item[{int}]{max\+\_\+degree }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



constructor, given reference to a graph 


\begin{DoxyCode}
69                                                                      \{
70     \hyperlink{classgraph__message_a934d63ed7275c211e13c6fb68824ed46}{h} = depth;
71     \hyperlink{classgraph__message_a45dfd061b7bc73572e5132fbf66efd55}{Delta} = max\_degree;
72     \hyperlink{classgraph__message_a40dadc59d582b290202e79bc4a9e896c}{update\_messages}(graph); \textcolor{comment}{// do message passing}
73   \}
\end{DoxyCode}
\mbox{\Hypertarget{classgraph__message_aa21140453eb0e1de98a2ddfcf2832aeb}\label{classgraph__message_aa21140453eb0e1de98a2ddfcf2832aeb}} 
\index{graph\+\_\+message@{graph\+\_\+message}!graph\+\_\+message@{graph\+\_\+message}}
\index{graph\+\_\+message@{graph\+\_\+message}!graph\+\_\+message@{graph\+\_\+message}}
\subsubsection{\texorpdfstring{graph\+\_\+message()}{graph\_message()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily graph\+\_\+message\+::graph\+\_\+message (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



default constructor 


\begin{DoxyCode}
76 \{\}
\end{DoxyCode}


\subsection{Member Function Documentation}
\mbox{\Hypertarget{classgraph__message_aa76d1d5420a12477fa1dddd878d78c8f}\label{classgraph__message_aa76d1d5420a12477fa1dddd878d78c8f}} 
\index{graph\+\_\+message@{graph\+\_\+message}!send\+\_\+message@{send\+\_\+message}}
\index{send\+\_\+message@{send\+\_\+message}!graph\+\_\+message@{graph\+\_\+message}}
\subsubsection{\texorpdfstring{send\+\_\+message()}{send\_message()}}
{\footnotesize\ttfamily void graph\+\_\+message\+::send\+\_\+message (\begin{DoxyParamCaption}\item[{const vector$<$ int $>$ \&}]{m,  }\item[{int}]{v,  }\item[{int}]{i }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [private]}}



update message\+\_\+dict and message\+\_\+list 

send the message m from vertex v towards its ith neighbor. Updates message\+\_\+dict, message\+\_\+mark and is\+\_\+message\+\_\+star

sends a message by setting messages, and puts it in the message hash table message\+\_\+dict. It also updates message\+\_\+mark and is\+\_\+star\+\_\+message corresponding to step s and the input message.


\begin{DoxyParams}{Parameters}
{\em m} & the message to be sent \\
\hline
{\em v} & the vertex from which the message is originated \\
\hline
{\em i} & the message is sent to the ith neighbor of v \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
479                                                                          \{
480   unordered\_map<vector<int>, int, \hyperlink{structvint__hash}{vint\_hash}>::iterator it;
481   \textcolor{comment}{/*}
482 \textcolor{comment}{  cerr << " send message (";}
483 \textcolor{comment}{  for (int k=0;k<m.size();k++)\{}
484 \textcolor{comment}{    cerr << m[k];}
485 \textcolor{comment}{    if (k<m.size()-1)}
486 \textcolor{comment}{      cerr << ", ";}
487 \textcolor{comment}{   \}}
488 \textcolor{comment}{  cerr << "): " << v << " -> " << i;}
489 \textcolor{comment}{  */}
490 
491   it = \hyperlink{classgraph__message_a557473b726dc5d80618055a6b843670f}{message\_dict}.find(m);
492   \textcolor{keywordflow}{if} (it == \hyperlink{classgraph__message_a557473b726dc5d80618055a6b843670f}{message\_dict}.end())\{
493     \textcolor{comment}{// this is a new message}
494     \hyperlink{classgraph__message_a557473b726dc5d80618055a6b843670f}{message\_dict}.insert(pair<vector<int>, \textcolor{keywordtype}{int}> (m, \hyperlink{classgraph__message_a49d9af5150daf0599c29fe18cb032fa5}{message\_mark}.size())); \textcolor{comment}{// insert
       the message into the hash table, message\_mark[s].size() is in fact the number of registered marks at step s}
495     \hyperlink{classgraph__message_af680c8a1755cf8d4aba389c1a3d6634e}{messages}[v][i] = \hyperlink{classgraph__message_a49d9af5150daf0599c29fe18cb032fa5}{message\_mark}.size(); \textcolor{comment}{// set the message}
496     \hyperlink{classgraph__message_a49d9af5150daf0599c29fe18cb032fa5}{message\_mark}.push\_back(m.back()); \textcolor{comment}{// register m by adding its mark component (which is
       m.back() the last element in m) to the list of marks at step s}
497     \hyperlink{classgraph__message_a55ff5531a0043106369e84a7bc45e22d}{is\_star\_message}.push\_back(m[0]==-1); \textcolor{comment}{// check if m is star type, and add this
       information to the list}
498   \}\textcolor{keywordflow}{else}\{
499     \textcolor{comment}{// the message already exists, just use the registered integer value corresponding to m and send the
       message}
500     \hyperlink{classgraph__message_af680c8a1755cf8d4aba389c1a3d6634e}{messages}[v][i] = it->second;
501   \}
502   \textcolor{comment}{//cerr << " message = " << messages[v][i] << endl;}
503 \}
\end{DoxyCode}
\mbox{\Hypertarget{classgraph__message_a40dadc59d582b290202e79bc4a9e896c}\label{classgraph__message_a40dadc59d582b290202e79bc4a9e896c}} 
\index{graph\+\_\+message@{graph\+\_\+message}!update\+\_\+messages@{update\+\_\+messages}}
\index{update\+\_\+messages@{update\+\_\+messages}!graph\+\_\+message@{graph\+\_\+message}}
\subsubsection{\texorpdfstring{update\+\_\+messages()}{update\_messages()}}
{\footnotesize\ttfamily void graph\+\_\+message\+::update\+\_\+messages (\begin{DoxyParamCaption}\item[{const \hyperlink{classmarked__graph}{marked\+\_\+graph} \&}]{G }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



performs the message passing algorithm and updates the messages array accordingly 

The structure of messages is as follows. To simplify the notation, we use $M_k(v,w)$ to denote the message sent from $v$ towards $w$ at time step $k$, this is in fact messages\mbox{[}v\mbox{]}\mbox{[}i\mbox{]}\mbox{[}t\mbox{]} where i is the index of $w$ among neighbors of $v$.


\begin{DoxyItemize}
\item For $k = 0$, we have $M_0(v,w) = (\tau_G(v), 0,\xi_G(w,v))$ where $\tau_G(v)$ is the mark of vertex $v$ and $\xi_G(w,v)$ denotes the mark of the edge between $v$ and $w$ towards $v$.
\item For $k > 0$, if the degree of $v$ is bigger than Delta, we have $M_k(v,w) = (-1,\xi_G(w,v))$.
\item Otherwise, we form the list $(s_u: u \sim_G v, u \neq w)$, where for $u \sim_G v, u \neq w$, we set $s_u = (M_{k-1}(u,v), \xi_G(u,v))$.
\item If for some $u \sim_G v, u \neq w$, the sequence $s_u$ starts with a -\/1, we set $M_k(v,w) = (-1,\xi_G(w,v))$.
\item Otherwise, we sort the sequences $s_u$ nondecreasingly with respect to the lexicographic order and set $s$ to be the concatenation of the sorted list. Finally, we set $M_k(v,w) = (\tau_G(v), \deg_G(v) -1, s, \xi_G(w,v))$. 
\end{DoxyItemize}
\begin{DoxyCode}
24 \{
25   \hyperlink{classlogger_a9d29b49bd318a719a8e85b59eac54fe0}{logger::current\_depth}++;
26   \hyperlink{classlogger_a710163deb17bc81f70d53d285b8ac9ac}{logger::add\_entry}(\textcolor{stringliteral}{"graph\_message::update\_message init"}, \textcolor{stringliteral}{""});
27   \textcolor{keywordtype}{int} nu\_vertices = G.\hyperlink{classmarked__graph_acf79c6aeb8f32614cb14a5baaa6c9f9b}{nu\_vertices};
28   \textcolor{keywordtype}{int} w;
29   \textcolor{keywordtype}{int} my\_location;
30   \hyperlink{classgraph__message_af680c8a1755cf8d4aba389c1a3d6634e}{messages}.resize(nu\_vertices);
31   \textcolor{comment}{//inward\_message.resize(nu\_vertices);}
32   \textcolor{comment}{//message\_dict.resize(h);}
33   \textcolor{comment}{//message\_list.resize(h);}
34   \textcolor{comment}{//message\_mark.resize(h);}
35   \textcolor{comment}{//is\_star\_message.resize(h);}
36 
37   
38   \textcolor{comment}{// initialize the messages}
39 
40   \hyperlink{classlogger_a710163deb17bc81f70d53d285b8ac9ac}{logger::add\_entry}(\textcolor{stringliteral}{"resizing messages"}, \textcolor{stringliteral}{""});
41   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} v=0;v<nu\_vertices;v++)\{
42     \hyperlink{classgraph__message_af680c8a1755cf8d4aba389c1a3d6634e}{messages}[v].resize(G.\hyperlink{classmarked__graph_a1a0bf7ca413a278763f7c878b3b6fd6f}{adj\_list}[v].size());
43     \textcolor{comment}{//inward\_messages[v].resize(G.adj\_list[v].size());}
44     \textcolor{comment}{//for (int i=0;i<G.adj\_list[v].size();i++)\{}
45     \textcolor{comment}{//messages[v][i].resize(h);}
46       \textcolor{comment}{//inward\_messages[v][i].resize(h);}
47     \textcolor{comment}{//\}}
48   \}
49 
50   \hyperlink{classlogger_a710163deb17bc81f70d53d285b8ac9ac}{logger::add\_entry}(\textcolor{stringliteral}{"initializing messages"},\textcolor{stringliteral}{""});
51   vector<int> m(3);
52   unordered\_map<vector<int>, int, \hyperlink{structvint__hash}{vint\_hash}>::iterator it;
53   \textcolor{comment}{//map<vector<int>, int>::iterator it;}
54 
55   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} v=0;v<nu\_vertices;v++)\{
56 
57     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0;i<G.\hyperlink{classmarked__graph_a1a0bf7ca413a278763f7c878b3b6fd6f}{adj\_list}[v].size();i++)\{
58       \textcolor{comment}{// the message from v towards the ith neighbor (lets call is w) at time 0 has a mark component which
       is \(\backslash\)xi(v,w) and a subtree component which is a single root with mark \(\backslash\)tau(v). This is encoded as a message
       vector with size 3 of the form (\(\backslash\)tau(v), 0,\(\backslash\)xi(v,w)) where the last 0 indicates that there is no offspring.}
59 
60 
61       \textcolor{comment}{//vector<int> m;}
62       \textcolor{comment}{//m.clear();}
63       \textcolor{comment}{//m.push\_back(G.ver\_mark[v]);}
64       \textcolor{comment}{//m.push\_back(0);}
65       \textcolor{comment}{//m.push\_back(G.adj\_list[v][i].second.first);}
66 
67       m[0] = G.\hyperlink{classmarked__graph_ac83e9377dd4d8bb95be1ac949b127296}{ver\_mark}[v];
68       m[1] = 0;
69       m[2] = G.\hyperlink{classmarked__graph_a1a0bf7ca413a278763f7c878b3b6fd6f}{adj\_list}[v][i].second.first;
70       \hyperlink{classgraph__message_aa76d1d5420a12477fa1dddd878d78c8f}{send\_message}(m, v, i);
71 
72       \textcolor{comment}{// adding this message to the message dictionary}
73       \textcolor{comment}{//it = message\_dict[0].find(m);}
74       \textcolor{comment}{//w = G.adj\_list[v][i].first;}
75 
76       \textcolor{comment}{/*}
77 \textcolor{comment}{      if (it == message\_dict[0].end())\{}
78 \textcolor{comment}{        message\_dict[0][m] = message\_list[0].size();}
79 \textcolor{comment}{        messages[v][i][0] = message\_list[0].size();}
80 \textcolor{comment}{        message\_list[0].push\_back(m);}
81 \textcolor{comment}{}
82 \textcolor{comment}{      \}else\{}
83 \textcolor{comment}{        messages[v][i][0] = it->second;}
84 \textcolor{comment}{      \}}
85 \textcolor{comment}{      */}
86       \textcolor{comment}{//messages[v][i][0] = message\_dict[0][m]; // the message at time 0}
87     \}
88   \}
89 
90   \textcolor{comment}{// these are copies of message\_dict, message\_mark and is\_star\_message at the previous step, which are
       used to update messages at the current step.}
91 
92   \textcolor{comment}{//unordered\_map<vector<int>, int, vint\_hash> message\_dict\_old;}
93   \textcolor{comment}{//vector<int> message\_mark\_old;}
94   vector<bool> is\_star\_message\_old;
95   vector<vector<int> > messages\_old;
96 
97   \textcolor{comment}{// updating messages}
98   \hyperlink{classlogger_a710163deb17bc81f70d53d285b8ac9ac}{logger::add\_entry}(\textcolor{stringliteral}{"updating messages"}, \textcolor{stringliteral}{""});
99   m.reserve(5+ 2 * \hyperlink{classgraph__message_a45dfd061b7bc73572e5132fbf66efd55}{Delta});
100   vector<int> m2;
101   m2.reserve(5 + 2*\hyperlink{classgraph__message_a45dfd061b7bc73572e5132fbf66efd55}{Delta}); \textcolor{comment}{// an auxiliary message when we need to work with two types of messages
       simultaneously }
102   duration<float> diff;
103   high\_resolution\_clock::time\_point t1, t2; 
104   \textcolor{keywordtype}{float} agg\_search = 0;
105   \textcolor{keywordtype}{float} agg\_insert = 0;
106   \textcolor{keywordtype}{float} agg\_m = 0;
107   \textcolor{keywordtype}{float} agg\_sort = 0;
108   \textcolor{keywordtype}{float} agg\_neigh\_message = 0;
109 
110   vector<pair<pair<int, int>, \textcolor{keywordtype}{int}> > neighbor\_messages; \textcolor{comment}{// the first component is the message and the
       second is the name of the neighbor}
111   \textcolor{comment}{// the second component is stored so that after sorting, we know the owner of the message}
112   neighbor\_messages.reserve(5+2*\hyperlink{classgraph__message_a45dfd061b7bc73572e5132fbf66efd55}{Delta});
113 
114   \textcolor{keywordtype}{int} nu\_star\_neigh; \textcolor{comment}{// number of star neighbors, i.e. neighbors of a vertex v whose message towards v are
       star type}
115   \textcolor{keywordtype}{int} star\_neigh\_index; \textcolor{comment}{// the index of the star neighbor of v, this is only useful when there is one star
       neighbor, if there are more than one star neighbor, then the message sent from v towards all other neighbors
       are star typed}
116   \textcolor{keywordtype}{int} star\_neigh; \textcolor{comment}{// the label of the star neighbor, i.e. star\_neigh =
       G.adj\_list[v][star\_neigh\_index].first;}
117   \textcolor{keywordtype}{int} previous\_message; \textcolor{comment}{// the message from the previous step}
118   \textcolor{keywordtype}{int} mark\_to\_v; \textcolor{comment}{// mark towards the current vertex directed from its neighbor}
119   vector<int> neighbors\_list; \textcolor{comment}{// the list of neighbors of a vertex in the order after sorting with respect
       to their corresponding messages}
120   neighbors\_list.reserve(\hyperlink{classgraph__message_a45dfd061b7bc73572e5132fbf66efd55}{Delta} + 3);
121   \textcolor{keywordtype}{int} deg\_v; \textcolor{comment}{// the degree of vertex v }
122 
123 
124 
125   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} s=1; s<\hyperlink{classgraph__message_a934d63ed7275c211e13c6fb68824ed46}{h};s++)\{ \textcolor{comment}{// s stands for step}
126     \textcolor{comment}{//cerr << endl << endl<< " depth " << s << endl;}
127     \textcolor{comment}{// store variables corresponding to the previous step in their old version, and clearing the variables
       for this step:}
128     \textcolor{comment}{//message\_dict\_old = message\_dict;}
129     messages\_old = \hyperlink{classgraph__message_af680c8a1755cf8d4aba389c1a3d6634e}{messages};
130     \textcolor{comment}{//message\_mark\_old = message\_mark;}
131     is\_star\_message\_old = \hyperlink{classgraph__message_a55ff5531a0043106369e84a7bc45e22d}{is\_star\_message};
132     \hyperlink{classgraph__message_a557473b726dc5d80618055a6b843670f}{message\_dict}.clear();
133     \hyperlink{classgraph__message_a49d9af5150daf0599c29fe18cb032fa5}{message\_mark}.clear();
134     \hyperlink{classgraph__message_a55ff5531a0043106369e84a7bc45e22d}{is\_star\_message}.clear();
135     \textcolor{comment}{// we do not clear messages since we need its size to be the same, and we only modify its content}
136     
137 
138     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} v=0;v<nu\_vertices;v++)\{
139       deg\_v = G.\hyperlink{classmarked__graph_a1a0bf7ca413a278763f7c878b3b6fd6f}{adj\_list}[v].size();
140       \textcolor{keywordflow}{if} (deg\_v==1)\{
141         \textcolor{comment}{// no need to collect messages, there is only one message towards the one neighbor, which is known }
142         m.resize(3); \textcolor{comment}{// there is only one message which is of the form \(\backslash\)f$(\(\backslash\)theta, 0, x)\(\backslash\)f$, where
       \(\backslash\)f$\(\backslash\)theta\(\backslash\)f$ is the mark of v, and \(\backslash\)f$x = \(\backslash\)xi\_G(w,v)\(\backslash\)f$  where \(\backslash\)f$w\(\backslash\)f$ is the only neighbor of v}
143         m[0] = G.\hyperlink{classmarked__graph_ac83e9377dd4d8bb95be1ac949b127296}{ver\_mark}[v];
144         m[1] = 0;
145         m[2] = G.\hyperlink{classmarked__graph_a1a0bf7ca413a278763f7c878b3b6fd6f}{adj\_list}[v][0].second.first;
146         \hyperlink{classgraph__message_aa76d1d5420a12477fa1dddd878d78c8f}{send\_message}(m, v, 0);
147       \}\textcolor{keywordflow}{else}\{
148         \textcolor{keywordflow}{if} (deg\_v <= \hyperlink{classgraph__message_a45dfd061b7bc73572e5132fbf66efd55}{Delta})\{
149           neighbor\_messages.clear();
150           nu\_star\_neigh = 0;
151           \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0;i<deg\_v;i++)\{
152             w = G.\hyperlink{classmarked__graph_a1a0bf7ca413a278763f7c878b3b6fd6f}{adj\_list}[v][i].first; \textcolor{comment}{// neighbor label}
153             my\_location = G.\hyperlink{classmarked__graph_aee10b537408de42476609c1e45c075d0}{index\_in\_neighbor}[v][i];
154             previous\_message = messages\_old[w][my\_location]; \textcolor{comment}{// the message sent from this neighbor towards
       v at time t-1}
155             \textcolor{comment}{// check if previous message is star}
156             \textcolor{keywordflow}{if} (is\_star\_message\_old[previous\_message])\{
157               nu\_star\_neigh ++;
158               star\_neigh\_index = i;
159               star\_neigh = w;
160             \}
161             \textcolor{keywordflow}{if} (nu\_star\_neigh >= 2)
162               \textcolor{keywordflow}{break}; \textcolor{comment}{// then message towards all neighbors will be star, no need to collect messages}
163             mark\_to\_v = G.\hyperlink{classmarked__graph_a1a0bf7ca413a278763f7c878b3b6fd6f}{adj\_list}[v][i].second.first;
164             neighbor\_messages.push\_back(pair<pair<int, int> , \textcolor{keywordtype}{int}> (pair<int,int>(previous\_message, 
      mark\_to\_v), i));
165           \}
166           \textcolor{keywordflow}{if} (nu\_star\_neigh == 2)\{
167             \textcolor{comment}{// message towards all the neighbors will be star}
168             m.resize(2);
169             m[0] = -1;
170             \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0;i<G.\hyperlink{classmarked__graph_a1a0bf7ca413a278763f7c878b3b6fd6f}{adj\_list}[v].size();i++)\{
171               m[1] = G.\hyperlink{classmarked__graph_a1a0bf7ca413a278763f7c878b3b6fd6f}{adj\_list}[v][i].second.first; 
172               \hyperlink{classgraph__message_aa76d1d5420a12477fa1dddd878d78c8f}{send\_message}(m, v, i); \textcolor{comment}{// send message m from v towards its ith neighbor at step
       s}
173             \}
174           \}
175           \textcolor{keywordflow}{if} (nu\_star\_neigh == 1)\{
176             \textcolor{comment}{// the message towards all the neighbors except for that star neighbor is star}
177             \textcolor{comment}{// let m be the message towards that neighbor and m2 be the star messages}
178 
179             \textcolor{comment}{// sorting neighbor messages}
180             sort(neighbor\_messages.begin(), neighbor\_messages.end());
181 
182             \textcolor{comment}{// preparing m }
183             m.resize(0);
184             m.push\_back(G.\hyperlink{classmarked__graph_ac83e9377dd4d8bb95be1ac949b127296}{ver\_mark}[v]);
185             m.push\_back(G.\hyperlink{classmarked__graph_a1a0bf7ca413a278763f7c878b3b6fd6f}{adj\_list}[v].size()-1);
186 
187             
188 
189             \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0;i<neighbor\_messages.size();i++)\{
190               \textcolor{keywordflow}{if} (neighbor\_messages[i].second != star\_neigh\_index)\{
191                 \textcolor{comment}{// collect the messages of non star neighbors}
192                 m.push\_back(neighbor\_messages[i].first.first);
193                 m.push\_back(neighbor\_messages[i].first.second);
194               \}
195             \}
196             \textcolor{comment}{// finalize m by inserting its mark component}
197             m.push\_back(G.\hyperlink{classmarked__graph_a1a0bf7ca413a278763f7c878b3b6fd6f}{adj\_list}[v][star\_neigh\_index].second.first);
198 
199             \textcolor{comment}{// prepare star messages}
200             m2.resize(2);
201             m2[0] = -1;
202             \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0;i<deg\_v;i++)\{
203               \textcolor{keywordflow}{if} (i==star\_neigh\_index)\{
204                 \textcolor{comment}{// send the prepared message m}
205                 \hyperlink{classgraph__message_aa76d1d5420a12477fa1dddd878d78c8f}{send\_message}(m, v, i);
206               \}\textcolor{keywordflow}{else}\{
207                 \textcolor{comment}{// prepare a star message and send it}
208                 m2[1] = G.\hyperlink{classmarked__graph_a1a0bf7ca413a278763f7c878b3b6fd6f}{adj\_list}[v][i].second.first;
209                 \hyperlink{classgraph__message_aa76d1d5420a12477fa1dddd878d78c8f}{send\_message}(m2, v, i);
210               \}
211             \}
212           \}
213 
214           \textcolor{keywordflow}{if} (nu\_star\_neigh == 0)\{
215             \textcolor{comment}{// no star neighbor, so we can prepare messages to all neighbors comfortably as none of them
       are star type}
216             \textcolor{comment}{// we do this by a masking technique}
217             \textcolor{comment}{// sorting neighbor messages}
218             sort(neighbor\_messages.begin(), neighbor\_messages.end());
219             \textcolor{keywordflow}{if} (neighbor\_messages.size() != deg\_v)\{
220               cerr << \textcolor{stringliteral}{" Error: no star messages and yet neighbor\_messages does not have a size equal to the
       deg of v, step "} << s << \textcolor{stringliteral}{" v= "} << v <<  \textcolor{stringliteral}{" deg\_v= "} << deg\_v << \textcolor{stringliteral}{" neighbor\_messages.size() "} << 
      neighbor\_messages.size() << endl;
221             \}
222             m.resize(1 + 1 + 2*(G.\hyperlink{classmarked__graph_a1a0bf7ca413a278763f7c878b3b6fd6f}{adj\_list}[v].size()-1) +1); \textcolor{comment}{// 1 for vertex mark, 1 for deg -1,
       for (deg-1) many neighbors, each we have 2 values, and finally 1 for the mark component}
223             m[0] = G.\hyperlink{classmarked__graph_ac83e9377dd4d8bb95be1ac949b127296}{ver\_mark}[v];
224             m[1] = G.\hyperlink{classmarked__graph_a1a0bf7ca413a278763f7c878b3b6fd6f}{adj\_list}[v].size()-1;
225             neighbors\_list.resize(deg\_v);
226             \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0;i<neighbor\_messages.size();i++)\{
227               m[2*(i+1)]   = neighbor\_messages[i].first.first;
228               m[2*(i+1)+1] = neighbor\_messages[i].first.second;
229               neighbors\_list[i] = neighbor\_messages[i].second;
230             \}
231             \textcolor{comment}{// swapping the last message so that its mark component comes first, so that we can treat m as
       a valid message in our standard}
232             swap(m[2*deg\_v], m[2*deg\_v+1]);
233 
234             \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=neighbor\_messages.size()-1;i>=0;i--)\{
235               \textcolor{keywordflow}{if} (i < neighbor\_messages.size()-1)\{
236                 swap(m[2*deg\_v], m[2*(i+1)+1]);
237                 swap(m[2*deg\_v+1], m[2*(i+1)]);
238                 swap(neighbors\_list[deg\_v-1], neighbors\_list[i]);
239               \}
240               \hyperlink{classgraph__message_aa76d1d5420a12477fa1dddd878d78c8f}{send\_message}(m,v,neighbors\_list[deg\_v-1]);
241             \}
242           \}
243         \}
244         \textcolor{keywordflow}{if} (deg\_v > \hyperlink{classgraph__message_a45dfd061b7bc73572e5132fbf66efd55}{Delta})\{ \textcolor{comment}{// the message towards all neighbors is star}
245           m.resize(2);
246           m[0] = -1;
247           \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0;i<deg\_v;i++)\{
248             m[1] = G.\hyperlink{classmarked__graph_a1a0bf7ca413a278763f7c878b3b6fd6f}{adj\_list}[v][i].second.first;
249             \hyperlink{classgraph__message_aa76d1d5420a12477fa1dddd878d78c8f}{send\_message}(m,v,i);
250           \}
251         \}
252       \}
253     \}
254   \}
255 
256 
257   \hyperlink{classlogger_a710163deb17bc81f70d53d285b8ac9ac}{logger::add\_entry}(\textcolor{stringliteral}{"* symmetrizing"}, \textcolor{stringliteral}{""});
258   \textcolor{keywordtype}{bool} star1, star2;
259   m.resize(2); \textcolor{comment}{// prepare for star message}
260   m[0] = -1;
261   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} v=0;v<nu\_vertices;v++)\{
262     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0;i<G.\hyperlink{classmarked__graph_a1a0bf7ca413a278763f7c878b3b6fd6f}{adj\_list}[v].size();i++)\{
263       w = G.\hyperlink{classmarked__graph_a1a0bf7ca413a278763f7c878b3b6fd6f}{adj\_list}[v][i].first;
264       my\_location = G.\hyperlink{classmarked__graph_aee10b537408de42476609c1e45c075d0}{index\_in\_neighbor}[v][i];
265       \textcolor{keywordflow}{if} (w > v)\{ \textcolor{comment}{// to avoid going over edges twice }
266         star1 = \hyperlink{classgraph__message_a55ff5531a0043106369e84a7bc45e22d}{is\_star\_message}[\hyperlink{classgraph__message_af680c8a1755cf8d4aba389c1a3d6634e}{messages}[v][i]];
267         star2 = \hyperlink{classgraph__message_a55ff5531a0043106369e84a7bc45e22d}{is\_star\_message}[messages[w][my\_location]];
268         \textcolor{keywordflow}{if} (star1 and !star2)\{
269           \textcolor{comment}{// message[w][my\_location] should be star}
270           m[1] = G.\hyperlink{classmarked__graph_a1a0bf7ca413a278763f7c878b3b6fd6f}{adj\_list}[v][i].second.second;
271           \hyperlink{classgraph__message_aa76d1d5420a12477fa1dddd878d78c8f}{send\_message}(m,w,my\_location);
272         \}
273         \textcolor{keywordflow}{if} (!star1 and star2)\{
274           \textcolor{comment}{// messages[v][i] should also become star}
275           m[1] = G.\hyperlink{classmarked__graph_a1a0bf7ca413a278763f7c878b3b6fd6f}{adj\_list}[v][i].second.first;
276           \hyperlink{classgraph__message_aa76d1d5420a12477fa1dddd878d78c8f}{send\_message}(m,v,i);
277         \}
278       \}
279     \}
280   \}
281   \hyperlink{classlogger_a9d29b49bd318a719a8e85b59eac54fe0}{logger::current\_depth}--;
282 
283 
284 
285 
286   \textcolor{comment}{// ==================================================}
287   \textcolor{comment}{// ==================================================}
288   \textcolor{comment}{// ==================================================}
289   \textcolor{comment}{// ==================================================}
290   \textcolor{comment}{// ==================================================}
291   \textcolor{comment}{// ==================================================}
292   \textcolor{comment}{// ==================================================}
293   \textcolor{comment}{// ==================================================}
294 
295   \textcolor{comment}{/*}
296 \textcolor{comment}{  for (int t=1;t<h;t++)\{}
297 \textcolor{comment}{    for (int v=0;v<nu\_vertices;v++)\{}
298 \textcolor{comment}{      //cerr << " vertex " << v << endl;}
299 \textcolor{comment}{      if (G.adj\_list[v].size() <= Delta)\{}
300 \textcolor{comment}{        // the degree of v is no more than Delta}
301 \textcolor{comment}{        // do the standard message passing by aggregating messages from neighbors}
302 \textcolor{comment}{        // stacking all the messages from neighbors of v towards v}
303 \textcolor{comment}{        neighbor\_messages.clear();}
304 \textcolor{comment}{}
305 \textcolor{comment}{        // the message from each neighbor of v, say w,  towards v is considered, the mark of the edge
       between w and v towards v is added to it, and then all these objects are stacked in neighbor\_messages to be
       sorted and used afterwards}
306 \textcolor{comment}{        //t1 = high\_resolution\_clock::now();}
307 \textcolor{comment}{        for (int i=0;i<G.adj\_list[v].size();i++)\{}
308 \textcolor{comment}{          w = G.adj\_list[v][i].first; // what is the name of the neighbor I am looking at now, which is the
       ith neighbor of vertex v }
309 \textcolor{comment}{          //my\_location = G.adj\_location[w].at(v); <--- the inefficient way}
310 \textcolor{comment}{          my\_location = G.index\_in\_neighbor[v][i];}
311 \textcolor{comment}{          // where is the place of node v among the list of neighbors of the ith neighbor of v}
312 \textcolor{comment}{          int previous\_message = messages[w][my\_location][t-1]; // the message sent from this neighbor
       towards v at time t-1}
313 \textcolor{comment}{          int mark\_to\_v = G.adj\_list[v][i].second.first;}
314 \textcolor{comment}{          neighbor\_messages.push\_back(pair<pair<int, int> , int> (pair<int,int>(previous\_message,
       mark\_to\_v), w));}
315 \textcolor{comment}{        \}}
316 \textcolor{comment}{        //t2 = high\_resolution\_clock::now();}
317 \textcolor{comment}{        //diff = t2 - t1;}
318 \textcolor{comment}{        //agg\_neigh\_message += diff.count();}
319 \textcolor{comment}{}
320 \textcolor{comment}{        //t1 = high\_resolution\_clock::now();}
321 \textcolor{comment}{        sort(neighbor\_messages.begin(), neighbor\_messages.end()); // sorts lexicographically}
322 \textcolor{comment}{        //t2 = high\_resolution\_clock::now();}
323 \textcolor{comment}{        //diff = t2 - t1;}
324 \textcolor{comment}{        //agg\_sort += diff.count();}
325 \textcolor{comment}{}
326 \textcolor{comment}{        for (int i=0;i<G.adj\_list[v].size();i++)\{}
327 \textcolor{comment}{          // let w be the current ith neighbor of v}
328 \textcolor{comment}{          int w = G.adj\_list[v][i].first;}
329 \textcolor{comment}{          // first, start with the mark of v and the number of offsprings in the subgraph component of the
       message}
330 \textcolor{comment}{          //vector<int> m; // the message that v is going to send to w}
331 \textcolor{comment}{          //t1 = high\_resolution\_clock::now();}
332 \textcolor{comment}{          m.clear();}
333 \textcolor{comment}{          m.push\_back(G.ver\_mark[v]); // mark of v}
334 \textcolor{comment}{          m.push\_back(G.adj\_list[v].size()-1); // the number of offsprings in the subgraph component of the
       message}
335 \textcolor{comment}{          //t2 = high\_resolution\_clock::now();}
336 \textcolor{comment}{          //diff = t2 - t1;}
337 \textcolor{comment}{          //agg\_m += diff.count();}
338 \textcolor{comment}{}
339 \textcolor{comment}{          // stacking messages from all neighbors of v expect for w towards v at time t-1}
340 \textcolor{comment}{          for (int j=0;j<G.adj\_list[v].size();j++)\{}
341 \textcolor{comment}{            if (neighbor\_messages[j].second != w)\{}
342 \textcolor{comment}{              if (message\_list[t-1][neighbor\_messages[j].first.first][0] == -1)\{}
343 \textcolor{comment}{                // this means that one of the messages that should be aggregated is * typed, therefore the
       outgoing messages should also be * typed}
344 \textcolor{comment}{                // i.e. the message has only two entries: (-1, \(\backslash\)xi(w,v)) where \(\backslash\)xi(w,v) is the mark of the
       edge between v and w towards v}
345 \textcolor{comment}{                // since after this loop, the mark \(\backslash\)xi(w,v) is added to the message (after the comment
       starting with 'finally'), we only add the initial -1 part}
346 \textcolor{comment}{                //t1 = high\_resolution\_clock::now();}
347 \textcolor{comment}{                m.resize(0);}
348 \textcolor{comment}{                m.push\_back(-1);}
349 \textcolor{comment}{                //t2 = high\_resolution\_clock::now();}
350 \textcolor{comment}{                //diff = t2 - t1;}
351 \textcolor{comment}{                //agg\_m += diff.count();}
352 \textcolor{comment}{                break; // the message is decided, we do not need to go over any of the other neighbor
       messages, hence break}
353 \textcolor{comment}{              \}}
354 \textcolor{comment}{              // this message should be added to the list of messages}
355 \textcolor{comment}{              //t1 = high\_resolution\_clock::now();}
356 \textcolor{comment}{              m.push\_back(neighbor\_messages[j].first.first); // message part}
357 \textcolor{comment}{              m.push\_back(neighbor\_messages[j].first.second); // mark part towards v}
358 \textcolor{comment}{              //t2 = high\_resolution\_clock::now();}
359 \textcolor{comment}{              //diff = t2 - t1;}
360 \textcolor{comment}{              //agg\_m += diff.count();}
361 \textcolor{comment}{}
362 \textcolor{comment}{            \}}
363 \textcolor{comment}{          \}}
364 \textcolor{comment}{          // if we break, we reach at this point and message is (-1), otherwise the message is of the form
       (\(\backslash\)tau(v), \(\backslash\)deg(v) - 1, ...) where ... is the list of all neighbor messages towards v except for w. }
365 \textcolor{comment}{          // finally, the mark of the edge between v and w towards v, \(\backslash\)xi(w,v), should be added to this
       list}
366 \textcolor{comment}{          //t1 = high\_resolution\_clock::now();}
367 \textcolor{comment}{          m.push\_back(G.adj\_list[v][i].second.first);}
368 \textcolor{comment}{          //t2 = high\_resolution\_clock::now();}
369 \textcolor{comment}{          //diff = t2 - t1;}
370 \textcolor{comment}{          //agg\_m += diff.count();}
371 \textcolor{comment}{}
372 \textcolor{comment}{          // set the current message}
373 \textcolor{comment}{          //t1 = high\_resolution\_clock::now();}
374 \textcolor{comment}{          it = message\_dict[t].find(m);}
375 \textcolor{comment}{          //t2 = high\_resolution\_clock::now();}
376 \textcolor{comment}{          //diff = t2 - t1;}
377 \textcolor{comment}{          //agg\_search += diff.count();}
378 \textcolor{comment}{}
379 \textcolor{comment}{          if (it == message\_dict[t].end())\{}
380 \textcolor{comment}{            //t1 = high\_resolution\_clock::now();}
381 \textcolor{comment}{            //message\_dict[t][m] = message\_list[t].size();}
382 \textcolor{comment}{            message\_dict[t].insert(pair<vector<int>, int> (m, message\_list[t].size()));}
383 \textcolor{comment}{            //t2 = high\_resolution\_clock::now();}
384 \textcolor{comment}{            //diff = t2 - t1;}
385 \textcolor{comment}{            //agg\_insert += diff.count();}
386 \textcolor{comment}{}
387 \textcolor{comment}{            messages[v][i][t] = message\_list[t].size();}
388 \textcolor{comment}{            message\_list[t].push\_back(m);}
389 \textcolor{comment}{          \}else\{}
390 \textcolor{comment}{            messages[v][i][t] = it->second;}
391 \textcolor{comment}{          \}}
392 \textcolor{comment}{        \}}
393 \textcolor{comment}{      \}else\{}
394 \textcolor{comment}{        // if the degree of v is bigger than Delta, the message towards all neighbors is of the form *}
395 \textcolor{comment}{        // i.e. message of v towards a neighbor w is of the form (-1, \(\backslash\)xi(w,v)) where \(\backslash\)xi(w,v) is the mark
       of the edge between v and w towards v}
396 \textcolor{comment}{        for (int i=0;i<G.adj\_list[v].size();i++)\{}
397 \textcolor{comment}{          //vector<int> m; // the current message from v to ith neighbor}
398 \textcolor{comment}{          //t1 = high\_resolution\_clock::now();}
399 \textcolor{comment}{          m.clear();}
400 \textcolor{comment}{          m.resize(2);}
401 \textcolor{comment}{          m[0] = -1;}
402 \textcolor{comment}{          m[1] = G.adj\_list[v][i].second.first;}
403 \textcolor{comment}{          //t2 = high\_resolution\_clock::now();}
404 \textcolor{comment}{          //diff = t2 - t1;}
405 \textcolor{comment}{          //agg\_m += diff.count();}
406 \textcolor{comment}{}
407 \textcolor{comment}{          // set the current message}
408 \textcolor{comment}{          //t1 = high\_resolution\_clock::now();}
409 \textcolor{comment}{          it = message\_dict[t].find(m);}
410 \textcolor{comment}{          //t2 = high\_resolution\_clock::now();}
411 \textcolor{comment}{          //diff = t2 - t1;}
412 \textcolor{comment}{          //agg\_search += diff.count();}
413 \textcolor{comment}{}
414 \textcolor{comment}{          if (it == message\_dict[t].end())\{}
415 \textcolor{comment}{            //t1 = high\_resolution\_clock::now();}
416 \textcolor{comment}{            //message\_dict[t][m] = message\_list[t].size();}
417 \textcolor{comment}{            message\_dict[t].insert(pair<vector<int>, int> (m, message\_list[t].size()));}
418 \textcolor{comment}{            //t2 = high\_resolution\_clock::now();}
419 \textcolor{comment}{            //diff = t2 - t1;}
420 \textcolor{comment}{            //agg\_insert += diff.count();}
421 \textcolor{comment}{            messages[v][i][t] = message\_list[t].size();}
422 \textcolor{comment}{            message\_list[t].push\_back(m);}
423 \textcolor{comment}{          \}else\{}
424 \textcolor{comment}{            messages[v][i][t] = it->second;}
425 \textcolor{comment}{          \}}
426 \textcolor{comment}{        \}}
427 \textcolor{comment}{      \}}
428 \textcolor{comment}{    \}}
429 \textcolor{comment}{  \}}
430 \textcolor{comment}{  cerr << " total time to search in hash table: " << agg\_search << endl;}
431 \textcolor{comment}{  cerr << " total time to insert in hash table: " << agg\_insert << endl;}
432 \textcolor{comment}{  cerr << " total time to modify vector m  " << agg\_m << endl;}
433 \textcolor{comment}{  cerr << " total time to sort  " << agg\_sort << endl;}
434 \textcolor{comment}{  cerr << " total time to collect neighbor messages " <<  agg\_neigh\_message << endl;}
435 \textcolor{comment}{  // now, we should update messages at time h-1 so that if the message from v to w is *, i.e. is of the
       form (-1,x), then the message from w to v is also of the similar form, i.e. it is (-1,x') where x' = \(\backslash\)xi(v,w)}
436 \textcolor{comment}{  logger::add\_entry("* symmetrizing", "");}
437 \textcolor{comment}{  for (int v=0;v<nu\_vertices;v++)\{}
438 \textcolor{comment}{    for (int i=0;i<G.adj\_list[v].size();i++)\{}
439 \textcolor{comment}{      if (message\_list[h-1][messages[v][i][h-1]][0] == -1)\{}
440 \textcolor{comment}{        // it is of the form *}
441 \textcolor{comment}{        w = G.adj\_list[v][i].first; // the other endpoint of the edge}
442 \textcolor{comment}{        //my\_location = G.adj\_location[w].at(v); // so that adj\_list[w][my\_location].first = v}
443 \textcolor{comment}{        my\_location = G.index\_in\_neighbor[v][i];}
444 \textcolor{comment}{}
445 \textcolor{comment}{        //vector<int> m;}
446 \textcolor{comment}{        m.clear();}
447 \textcolor{comment}{        m.resize(2);}
448 \textcolor{comment}{        m[0] = -1;}
449 \textcolor{comment}{        m[1] = G.adj\_list[v][i].second.second; // the mark towards w}
450 \textcolor{comment}{        if (message\_dict[h-1].find(m) == message\_dict[h-1].end())\{}
451 \textcolor{comment}{          message\_dict[h-1][m] = message\_list[h-1].size();}
452 \textcolor{comment}{          message\_list[h-1].push\_back(m);}
453 \textcolor{comment}{        \}}
454 \textcolor{comment}{        messages[w][my\_location][h-1] = message\_dict[h-1][m];}
455 \textcolor{comment}{      \}}
456 \textcolor{comment}{    \}}
457 \textcolor{comment}{  \}}
458 \textcolor{comment}{}
459 \textcolor{comment}{  // setting message\_mark and is\_star\_message}
460 \textcolor{comment}{  logger::add\_entry("setting message\_mark and is\_star\_message", "");}
461 \textcolor{comment}{  message\_mark.resize(message\_list[h-1].size());}
462 \textcolor{comment}{  is\_star\_message.resize(message\_list[h-1].size());}
463 \textcolor{comment}{  for (int i=0;i<message\_list[h-1].size();i++)\{}
464 \textcolor{comment}{    message\_mark[i] = message\_list[h-1][i].back(); // the last element is the mark component}
465 \textcolor{comment}{    is\_star\_message[i] = (message\_list[h-1][i][0] == -1); // message is star type when the first element is
       -1}
466 \textcolor{comment}{  \}}
467 \textcolor{comment}{  logger::current\_depth--;}
468 \textcolor{comment}{  */}
469 \}
\end{DoxyCode}


\subsection{Member Data Documentation}
\mbox{\Hypertarget{classgraph__message_a45dfd061b7bc73572e5132fbf66efd55}\label{classgraph__message_a45dfd061b7bc73572e5132fbf66efd55}} 
\index{graph\+\_\+message@{graph\+\_\+message}!Delta@{Delta}}
\index{Delta@{Delta}!graph\+\_\+message@{graph\+\_\+message}}
\subsubsection{\texorpdfstring{Delta}{Delta}}
{\footnotesize\ttfamily int graph\+\_\+message\+::\+Delta\hspace{0.3cm}{\ttfamily [private]}}



the maximum degree threshold 

\mbox{\Hypertarget{classgraph__message_a934d63ed7275c211e13c6fb68824ed46}\label{classgraph__message_a934d63ed7275c211e13c6fb68824ed46}} 
\index{graph\+\_\+message@{graph\+\_\+message}!h@{h}}
\index{h@{h}!graph\+\_\+message@{graph\+\_\+message}}
\subsubsection{\texorpdfstring{h}{h}}
{\footnotesize\ttfamily int graph\+\_\+message\+::h\hspace{0.3cm}{\ttfamily [private]}}



the depth up to which we do message passing (the type of edges go through depth h-\/1) 

\mbox{\Hypertarget{classgraph__message_a55ff5531a0043106369e84a7bc45e22d}\label{classgraph__message_a55ff5531a0043106369e84a7bc45e22d}} 
\index{graph\+\_\+message@{graph\+\_\+message}!is\+\_\+star\+\_\+message@{is\+\_\+star\+\_\+message}}
\index{is\+\_\+star\+\_\+message@{is\+\_\+star\+\_\+message}!graph\+\_\+message@{graph\+\_\+message}}
\subsubsection{\texorpdfstring{is\+\_\+star\+\_\+message}{is\_star\_message}}
{\footnotesize\ttfamily vector$<$bool$>$ graph\+\_\+message\+::is\+\_\+star\+\_\+message}



for an integer message $m$, is\+\_\+star\+\_\+message\mbox{[}m\mbox{]} is true if m is a star message and false otherwise. Note that m is star type iff the first index in the vector message corresponding to m is -\/1. This is updated at step of update\+\_\+messages, so when it is over, it corresponds to step (depth) h-\/1. 

\mbox{\Hypertarget{classgraph__message_a557473b726dc5d80618055a6b843670f}\label{classgraph__message_a557473b726dc5d80618055a6b843670f}} 
\index{graph\+\_\+message@{graph\+\_\+message}!message\+\_\+dict@{message\+\_\+dict}}
\index{message\+\_\+dict@{message\+\_\+dict}!graph\+\_\+message@{graph\+\_\+message}}
\subsubsection{\texorpdfstring{message\+\_\+dict}{message\_dict}}
{\footnotesize\ttfamily unordered\+\_\+map$<$vector$<$int$>$, int, \hyperlink{structvint__hash}{vint\+\_\+hash}$>$ graph\+\_\+message\+::message\+\_\+dict}



message\+\_\+dict is the message dictionary at any step that update\+\_\+messages is running, which maps each message to its corresponding index in the dictionary. When update\+\_\+messages is over, this corresponds to step (depth) h-\/1 

\mbox{\Hypertarget{classgraph__message_a49d9af5150daf0599c29fe18cb032fa5}\label{classgraph__message_a49d9af5150daf0599c29fe18cb032fa5}} 
\index{graph\+\_\+message@{graph\+\_\+message}!message\+\_\+mark@{message\+\_\+mark}}
\index{message\+\_\+mark@{message\+\_\+mark}!graph\+\_\+message@{graph\+\_\+message}}
\subsubsection{\texorpdfstring{message\+\_\+mark}{message\_mark}}
{\footnotesize\ttfamily vector$<$int$>$ graph\+\_\+message\+::message\+\_\+mark}



for an integer message $m$, message\+\_\+mark\mbox{[}m\mbox{]} is the mark component associated to the message m at any step that update\+\_\+messages is working. This is basically the last index in the vector message associate to m. When update\+\_\+messages is over, this corresponds to step (depth) h-\/1. 

\mbox{\Hypertarget{classgraph__message_af680c8a1755cf8d4aba389c1a3d6634e}\label{classgraph__message_af680c8a1755cf8d4aba389c1a3d6634e}} 
\index{graph\+\_\+message@{graph\+\_\+message}!messages@{messages}}
\index{messages@{messages}!graph\+\_\+message@{graph\+\_\+message}}
\subsubsection{\texorpdfstring{messages}{messages}}
{\footnotesize\ttfamily vector$<$vector$<$int $>$ $>$ graph\+\_\+message\+::messages}



messages\mbox{[}v\mbox{]}\mbox{[}i\mbox{]} is the integer version of the message from vertex v towards its ith neighbor (in the order given by adj\+\_\+list of vertex i in graph G). The message is at any given step that update\+\_\+messages is running, so after finishing update\+\_\+message, the messages are at step (depth) h-\/1. 



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
\hyperlink{graph__message_8h}{graph\+\_\+message.\+h}\item 
\hyperlink{graph__message_8cpp}{graph\+\_\+message.\+cpp}\end{DoxyCompactItemize}
