\hypertarget{compression__helper_8cpp}{}\section{compression\+\_\+helper.\+cpp File Reference}
\label{compression__helper_8cpp}\index{compression\+\_\+helper.\+cpp@{compression\+\_\+helper.\+cpp}}
{\ttfamily \#include \char`\"{}compression\+\_\+helper.\+h\char`\"{}}\newline
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
mpz\+\_\+class \hyperlink{compression__helper_8cpp_a4e5c8137a0b072800c7a8f0a80978468}{compute\+\_\+product\+\_\+old} (int N, int k, int s)
\begin{DoxyCompactList}\small\item\em This function computes the product of consecutive integers separated by a given iteration. This is the old version which uses standard recursion. \end{DoxyCompactList}\item 
mpz\+\_\+class \hyperlink{compression__helper_8cpp_ae2afb43aabe50f7d42aae8f82b5a35f4}{compute\+\_\+product} (int N, int k, int s)
\begin{DoxyCompactList}\small\item\em This function computes the product of consecutive integers separated by a given iteration. This is the new version which implements recursion via stack. \end{DoxyCompactList}\item 
mpz\+\_\+class \hyperlink{compression__helper_8cpp_acecca9cb279d3b3d82915a07d67818cf}{binomial} (const int n, const int m)
\begin{DoxyCompactList}\small\item\em computes the binomial coefficient n choose m = n! / m! (n-\/m)! \end{DoxyCompactList}\item 
mpz\+\_\+class \hyperlink{compression__helper_8cpp_a86d8a20e022dc06b23df3b08ac10b7d1}{prod\+\_\+factorial} (const vector$<$ int $>$ \&a, int i, int j)
\begin{DoxyCompactList}\small\item\em computes the product of factorials in a vector given a range \end{DoxyCompactList}\item 
void \hyperlink{compression__helper_8cpp_accfebfd921b967c2f09e8c11569eb832}{bit\+\_\+string\+\_\+write} (F\+I\+LE $\ast$f, const string \&s)
\begin{DoxyCompactList}\small\item\em Write a string containing 0 and 1 to a binary file, treating the string as a bit sequence. \end{DoxyCompactList}\item 
string \hyperlink{compression__helper_8cpp_a40e8dcbc036f96b28e003e882c4890b7}{bit\+\_\+string\+\_\+read} (F\+I\+LE $\ast$f)
\begin{DoxyCompactList}\small\item\em Reads a bit sequence from a binary file, assuming the bit sequence was generated by the {\ttfamily bit\+\_\+string\+\_\+write} function. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Function Documentation}
\mbox{\Hypertarget{compression__helper_8cpp_acecca9cb279d3b3d82915a07d67818cf}\label{compression__helper_8cpp_acecca9cb279d3b3d82915a07d67818cf}} 
\index{compression\+\_\+helper.\+cpp@{compression\+\_\+helper.\+cpp}!binomial@{binomial}}
\index{binomial@{binomial}!compression\+\_\+helper.\+cpp@{compression\+\_\+helper.\+cpp}}
\subsubsection{\texorpdfstring{binomial()}{binomial()}}
{\footnotesize\ttfamily mpz\+\_\+class binomial (\begin{DoxyParamCaption}\item[{const int}]{n,  }\item[{const int}]{m }\end{DoxyParamCaption})}



computes the binomial coefficient n choose m = n! / m! (n-\/m)! 


\begin{DoxyParams}{Parameters}
{\em n} & integer \\
\hline
{\em m} & integer \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the binomial coefficient n! / m! (n-\/m)!. If n $<$= 0, or m $>$ n, or m $<$= 0, returns 0 
\end{DoxyReturn}

\begin{DoxyCode}
144 \{
145   \textcolor{keywordflow}{if} (n <= 0 or m > n or m <= 0)
146     \textcolor{keywordflow}{return} 0;
147   \textcolor{keywordflow}{return} \hyperlink{compression__helper_8cpp_ae2afb43aabe50f7d42aae8f82b5a35f4}{compute\_product}(n, m, 1) / \hyperlink{compression__helper_8cpp_ae2afb43aabe50f7d42aae8f82b5a35f4}{compute\_product}(m, m, 1);
148 \}
\end{DoxyCode}
\mbox{\Hypertarget{compression__helper_8cpp_a40e8dcbc036f96b28e003e882c4890b7}\label{compression__helper_8cpp_a40e8dcbc036f96b28e003e882c4890b7}} 
\index{compression\+\_\+helper.\+cpp@{compression\+\_\+helper.\+cpp}!bit\+\_\+string\+\_\+read@{bit\+\_\+string\+\_\+read}}
\index{bit\+\_\+string\+\_\+read@{bit\+\_\+string\+\_\+read}!compression\+\_\+helper.\+cpp@{compression\+\_\+helper.\+cpp}}
\subsubsection{\texorpdfstring{bit\+\_\+string\+\_\+read()}{bit\_string\_read()}}
{\footnotesize\ttfamily string bit\+\_\+string\+\_\+read (\begin{DoxyParamCaption}\item[{F\+I\+LE $\ast$}]{f }\end{DoxyParamCaption})}



Reads a bit sequence from a binary file, assuming the bit sequence was generated by the {\ttfamily bit\+\_\+string\+\_\+write} function. 


\begin{DoxyParams}{Parameters}
{\em f} & a file pointer \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a string of zeros and ones. 
\end{DoxyReturn}

\begin{DoxyCode}
186                                \{
187   \textcolor{keywordtype}{int} nu\_bytes;
188   \textcolor{keywordtype}{int} ssize;
189   \textcolor{comment}{// read the number of bytes to read}
190   fread(&ssize, \textcolor{keyword}{sizeof}(ssize), 1, f);
191   \textcolor{comment}{//cerr << " ssize " << ssize << endl;}
192   nu\_bytes = ssize / 8;
193   \textcolor{keywordflow}{if} (ssize % 8 != 0)
194     nu\_bytes ++;
195 
196   \textcolor{keywordtype}{int} last\_byte\_size = ssize % 8;
197   \textcolor{keywordflow}{if} (last\_byte\_size == 0)
198     last\_byte\_size  = 8;
199 
200   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} c;
201   bitset<8> B;
202   \textcolor{keywordtype}{string} s; 
203   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0;i<nu\_bytes;i++)\{
204     fread(&c, \textcolor{keyword}{sizeof}(c), 1, f);
205     B = c;
206     \textcolor{comment}{//cout << B << endl;}
207     \textcolor{keywordflow}{if} (i < nu\_bytes -1)\{
208       s += B.to\_string();
209     \}\textcolor{keywordflow}{else}\{
210       s += B.to\_string().substr(8-last\_byte\_size, last\_byte\_size);
211     \}
212   \}
213   \textcolor{keywordflow}{return} s;
214 \}
\end{DoxyCode}
\mbox{\Hypertarget{compression__helper_8cpp_accfebfd921b967c2f09e8c11569eb832}\label{compression__helper_8cpp_accfebfd921b967c2f09e8c11569eb832}} 
\index{compression\+\_\+helper.\+cpp@{compression\+\_\+helper.\+cpp}!bit\+\_\+string\+\_\+write@{bit\+\_\+string\+\_\+write}}
\index{bit\+\_\+string\+\_\+write@{bit\+\_\+string\+\_\+write}!compression\+\_\+helper.\+cpp@{compression\+\_\+helper.\+cpp}}
\subsubsection{\texorpdfstring{bit\+\_\+string\+\_\+write()}{bit\_string\_write()}}
{\footnotesize\ttfamily void bit\+\_\+string\+\_\+write (\begin{DoxyParamCaption}\item[{F\+I\+LE $\ast$}]{f,  }\item[{const string \&}]{s }\end{DoxyParamCaption})}



Write a string containing 0 and 1 to a binary file, treating the string as a bit sequence. 

First, the size of the bit sequence is written to the output, then the input is split into 8 bit chunks, perhaps with some leftover, which are written to the output file as bytes. 
\begin{DoxyParams}{Parameters}
{\em f} & a file pointer \\
\hline
{\em s} & a string where each character is either 0 or 1 \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
164                                                \{
165   \textcolor{comment}{// find out the number of bytes}
166   \textcolor{keywordtype}{int} ssize = s.size();
167   \textcolor{keywordtype}{int} nu\_bytes = ssize / 8;
168 
169   \textcolor{keywordflow}{if} (ssize % 8 != 0) \textcolor{comment}{// an incomplete byte is required}
170     nu\_bytes++;
171 
172   fwrite(&ssize, \textcolor{keyword}{sizeof}(ssize), 1, f); \textcolor{comment}{// first, write down how many bytes are coming.}
173 
174   stringstream ss;
175   ss << s;
176 
177   bitset<8> B;
178   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} c; 
179   \textcolor{keywordflow}{while} (ss >> B)\{
180     c = B.to\_ulong();
181     fwrite(&c, \textcolor{keyword}{sizeof}(c), 1, f);
182   \}
183 \}
\end{DoxyCode}
\mbox{\Hypertarget{compression__helper_8cpp_ae2afb43aabe50f7d42aae8f82b5a35f4}\label{compression__helper_8cpp_ae2afb43aabe50f7d42aae8f82b5a35f4}} 
\index{compression\+\_\+helper.\+cpp@{compression\+\_\+helper.\+cpp}!compute\+\_\+product@{compute\+\_\+product}}
\index{compute\+\_\+product@{compute\+\_\+product}!compression\+\_\+helper.\+cpp@{compression\+\_\+helper.\+cpp}}
\subsubsection{\texorpdfstring{compute\+\_\+product()}{compute\_product()}}
{\footnotesize\ttfamily mpz\+\_\+class compute\+\_\+product (\begin{DoxyParamCaption}\item[{int}]{N,  }\item[{int}]{k,  }\item[{int}]{s }\end{DoxyParamCaption})}



This function computes the product of consecutive integers separated by a given iteration. This is the new version which implements recursion via stack. 


\begin{DoxyParams}{Parameters}
{\em N} & The first term in the product \\
\hline
{\em k} & the number of terms in the product \\
\hline
{\em s} & the iteration \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the product N $ N \times (N-s) \times (N-2s) \times \dots \times (N-(k-1)s) $ 
\end{DoxyReturn}

\begin{DoxyCode}
34                                               \{
35   \textcolor{keywordflow}{if} (k==1)
36     \textcolor{keywordflow}{return} N;
37   \textcolor{keywordflow}{if} (k == 0) \textcolor{comment}{// TO CHECK because there are no terms to compute product}
38     \textcolor{keywordflow}{return} 1;
39 
40   \textcolor{keywordflow}{if} (k < 0)\{
41     cerr << \textcolor{stringliteral}{" WARNING: compute\_product called for k < 0, returning 1, N  "} << N << \textcolor{stringliteral}{" k "} << k << \textcolor{stringliteral}{" s "} << s
       << endl;
42     \textcolor{keywordflow}{return} 1;
43   \}
44   \textcolor{keywordflow}{if} (N - (k-1) * s <= 0)\{ \textcolor{comment}{// the terms go negative}
45     \textcolor{comment}{//cerr << " WARNING: compute\_product called for N - (k-1) * s <= 0 " << endl;}
46     \textcolor{keywordflow}{return} 0;
47   \}
48 
49   \textcolor{keywordflow}{if} (k == 2)
50     \textcolor{keywordflow}{return} N * (N-s);
51 
52   \textcolor{keywordtype}{int} k\_bits = 0; \textcolor{comment}{// roughly , the number of bits in k, the depth of the stack during run time}
53   \textcolor{keywordtype}{int} k\_copy = k;
54   \textcolor{keywordflow}{while} (k\_copy > 0)\{
55     k\_bits ++;
56     k\_copy >>= 1;
57   \}
58   k\_bits += 2; 
59   vector<pair<int, int> > call\_stack(2 * k\_bits);
60   \textcolor{comment}{//cout << " 2 * k\_bits " << 2 * k\_bits << endl; }
61   \textcolor{keywordtype}{int} call\_pointer = 0; \textcolor{comment}{// size of the call pointer, so the top index is call\_pointer - 1}
62   vector<int> status\_stack(2 * k\_bits); \textcolor{comment}{// 0: first meet, 1: to return }
63   vector<mpz\_class> return\_stack(2 * k\_bits);
64   \textcolor{keywordtype}{int} return\_pointer = 0;
65 
66   call\_stack[call\_pointer] = pair<int, int> (N, k);
67   status\_stack[call\_pointer] = 0;
68   call\_pointer ++;
69 
70   \textcolor{keywordtype}{int} m;
71   \textcolor{keywordtype}{int} N\_now, k\_now; \textcolor{comment}{// N and k for the current stack element}
72   
73   \textcolor{keywordflow}{while} (call\_pointer > 0)\{
74     N\_now = call\_stack[call\_pointer-1].first;
75     k\_now = call\_stack[call\_pointer-1].second;
76     \textcolor{comment}{//cout << "call\_pointer = " << call\_pointer << " N = " << N\_now << " k = " << k\_now << " stat = " <<
       status\_stack[call\_pointer-1] << endl;}
77     \textcolor{comment}{//cout << " the whole stack " << endl;}
78     \textcolor{comment}{//for (int i=0;i<call\_pointer; i++)\{}
79     \textcolor{comment}{//  cout << call\_stack[i].first << " , " << call\_stack[i].second << " " << status\_stack[i] << endl;}
80     \textcolor{comment}{//\}}
81     \textcolor{keywordflow}{if} (status\_stack[call\_pointer-1] == 1)\{ \textcolor{comment}{// we should multiply two top elements in the return stack}
82       \textcolor{comment}{// to collect two top elements in return stack and multiply them}
83       return\_stack[return\_pointer-2] = return\_stack[return\_pointer-2] * return\_stack[return\_pointer-1];
84       return\_pointer--; \textcolor{comment}{// remove two items, add one item}
85       call\_pointer --;
86     \}\textcolor{keywordflow}{else}\{
87       \textcolor{comment}{//cout << " else " << endl;}
88       \textcolor{keywordflow}{if}(k\_now == 1)\{
89         \textcolor{comment}{// to return the corresponding N}
90         return\_stack[return\_pointer++] = call\_stack[call\_pointer-1].first;
91         call\_pointer --; \textcolor{comment}{// pop this element}
92       \}
93       \textcolor{keywordflow}{if} (k\_now == 2)\{
94         return\_stack[return\_pointer++] = N\_now * (N\_now - s);
95         call\_pointer --; 
96       \}
97       \textcolor{keywordflow}{if} (k\_now > 2)\{
98         m = k\_now / 2;
99         status\_stack[call\_pointer-1] = 1; \textcolor{comment}{// when return to this state, we know that we should aggregate }
100         call\_stack[call\_pointer] = pair<int, int>(N\_now, m);
101         status\_stack[call\_pointer] = 0; \textcolor{comment}{// just added}
102         call\_stack[call\_pointer+1] = pair<int, int>(N\_now - m*s, k\_now - m );
103         status\_stack[call\_pointer+1]  = 0;
104         call\_pointer += 2; 
105       \}
106     \}
107   \}
108   \textcolor{comment}{// make sure there is exactly one element in return stack}
109   \textcolor{keywordflow}{if} (return\_pointer != 1)\{
110     cerr << \textcolor{stringliteral}{" return pointer is not zero"};
111   \}
112   \textcolor{keywordflow}{return} return\_stack[0]; \textcolor{comment}{// the top element remaining in the return stack }
113 \}
\end{DoxyCode}
\mbox{\Hypertarget{compression__helper_8cpp_a4e5c8137a0b072800c7a8f0a80978468}\label{compression__helper_8cpp_a4e5c8137a0b072800c7a8f0a80978468}} 
\index{compression\+\_\+helper.\+cpp@{compression\+\_\+helper.\+cpp}!compute\+\_\+product\+\_\+old@{compute\+\_\+product\+\_\+old}}
\index{compute\+\_\+product\+\_\+old@{compute\+\_\+product\+\_\+old}!compression\+\_\+helper.\+cpp@{compression\+\_\+helper.\+cpp}}
\subsubsection{\texorpdfstring{compute\+\_\+product\+\_\+old()}{compute\_product\_old()}}
{\footnotesize\ttfamily mpz\+\_\+class compute\+\_\+product\+\_\+old (\begin{DoxyParamCaption}\item[{int}]{N,  }\item[{int}]{k,  }\item[{int}]{s }\end{DoxyParamCaption})}



This function computes the product of consecutive integers separated by a given iteration. This is the old version which uses standard recursion. 


\begin{DoxyParams}{Parameters}
{\em N} & The first term in the product \\
\hline
{\em k} & the number of terms in the product \\
\hline
{\em s} & the iteration \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the product N $ N \times (N-s) \times (N-2s) \times \dots \times (N-(k-1)s) $ 
\end{DoxyReturn}

\begin{DoxyCode}
4                                                   \{
5   \textcolor{comment}{//cerr << " compute\_product  N " << N << " k " << k << " s " << s << endl;}
6 
7   \textcolor{keywordflow}{if} (k==1)
8     \textcolor{keywordflow}{return} N;
9   \textcolor{keywordflow}{if} (k == 0) \textcolor{comment}{// TO CHECK because there are no terms to compute product}
10     \textcolor{keywordflow}{return} 1;
11 
12   \textcolor{keywordflow}{if} (k < 0)\{
13     cerr << \textcolor{stringliteral}{" WARNING: compute\_product called for k < 0, returning 1, N  "} << N << \textcolor{stringliteral}{" k "} << k << \textcolor{stringliteral}{" s "} << s
       << endl;
14     \textcolor{keywordflow}{return} 1;
15   \}
16   \textcolor{keywordflow}{if} (N - (k-1) * s <= 0)\{ \textcolor{comment}{// the terms go negative}
17     \textcolor{comment}{//cerr << " WARNING: compute\_product called for N - (k-1) * s <= 0 " << endl;}
18     \textcolor{keywordflow}{return} 0;
19   \}
20 
21   \textcolor{keywordflow}{if} (k == 2)
22     \textcolor{keywordflow}{return} N * (N-s);
23   \textcolor{comment}{// we do this by dividing the terms into two parts}
24   \textcolor{keywordtype}{int} m = k / 2; \textcolor{comment}{// the middle point}
25   mpz\_class left, right; \textcolor{comment}{// each of the half products }
26   left = \hyperlink{compression__helper_8cpp_ae2afb43aabe50f7d42aae8f82b5a35f4}{compute\_product}(N, m, s);
27   right = \hyperlink{compression__helper_8cpp_ae2afb43aabe50f7d42aae8f82b5a35f4}{compute\_product}(N-m * s, k-m, s);
28   \textcolor{comment}{//logger::item\_start("cp\_mul");}
29   mpz\_class ans = left*right;
30   \textcolor{comment}{//logger::item\_stop("cp\_mul");}
31   \textcolor{keywordflow}{return} ans;
32 \}
\end{DoxyCode}
\mbox{\Hypertarget{compression__helper_8cpp_a86d8a20e022dc06b23df3b08ac10b7d1}\label{compression__helper_8cpp_a86d8a20e022dc06b23df3b08ac10b7d1}} 
\index{compression\+\_\+helper.\+cpp@{compression\+\_\+helper.\+cpp}!prod\+\_\+factorial@{prod\+\_\+factorial}}
\index{prod\+\_\+factorial@{prod\+\_\+factorial}!compression\+\_\+helper.\+cpp@{compression\+\_\+helper.\+cpp}}
\subsubsection{\texorpdfstring{prod\+\_\+factorial()}{prod\_factorial()}}
{\footnotesize\ttfamily mpz\+\_\+class prod\+\_\+factorial (\begin{DoxyParamCaption}\item[{const vector$<$ int $>$ \&}]{a,  }\item[{int}]{i,  }\item[{int}]{j }\end{DoxyParamCaption})}



computes the product of factorials in a vector given a range 


\begin{DoxyParams}{Parameters}
{\em a} & vector of integers \\
\hline
{\em i,j} & endpoints of the interval \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
$\prod_{v = i}^j a_v ! $ 
\end{DoxyReturn}

\begin{DoxyCode}
152 \{
153   \textcolor{keywordflow}{if} (i == j)\{
154     \textcolor{keywordflow}{return} \hyperlink{compression__helper_8cpp_ae2afb43aabe50f7d42aae8f82b5a35f4}{compute\_product}(a[i], a[i], 1);
155   \}\textcolor{keywordflow}{else}\{
156     \textcolor{keywordtype}{int} k = (i+j)/2;
157     mpz\_class x = \hyperlink{compression__helper_8cpp_a86d8a20e022dc06b23df3b08ac10b7d1}{prod\_factorial}(a, i, k);
158     mpz\_class y = \hyperlink{compression__helper_8cpp_a86d8a20e022dc06b23df3b08ac10b7d1}{prod\_factorial}(a, k+1, j);
159     \textcolor{keywordflow}{return} x * y;
160   \}
161 \}
\end{DoxyCode}
