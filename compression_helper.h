#ifndef __COMPRESSION_HELPER__
#define __COMPRESSION_HELPER__

#include <iostream>
#include <gmpxx.h>
#include <vector>
#include <stdio.h>
#include <bitset>
#include <sstream>
#include "logger.h"

using namespace std;

namespace helper_vars{
  extern mpz_class mul_1, mul_2; //!< helper variables in order to avoid initialization
  extern vector<mpz_class> return_stack;
  extern vector<mpz_class> mpz_vec;
  extern vector<mpz_class> mpz_vec2;
};


//! This function computes the product of consecutive integers separated by a given iteration. This is the old version which uses standard recursion. 
/*!
  \param N The first term in the product
  \param k the number of terms in the product
  \param s the iteration
  \return the product N \f$ N \times (N-s) \times (N-2s) \times \dots \times (N-(k-1)s) \f$
*/
//mpz_class compute_product(mpz_class N, mpz_class k, int s);
mpz_class compute_product_old(int N, int k, int s);

//! This function computes the product of consecutive integers separated by a given iteration. This is the new version which implements recursion via stack. 
/*!
  \param N The first term in the product
  \param k the number of terms in the product
  \param s the iteration
  \return the product N \f$ N \times (N-s) \times (N-2s) \times \dots \times (N-(k-1)s) \f$
*/
mpz_class compute_product_stack(int N, int k, int s);
mpz_class compute_product(int N, int k, int s);
void compute_product_void(int N, int k, int s);

//! computes the product of elements in vector a by inline multiplication of adjacent elements recursively. The results will be in a[0].
void compute_array_product(vector<mpz_class>& a);

//! computes the binomial coefficient n choose m = n! / m! (n-m)!
/*!
  \param n integer
  \param m integer
  \return the binomial coefficient n! / m! (n-m)!. If n <= 0, or  m > n, or m <= 0, returns 0
*/
mpz_class binomial(const int n, const int m);


//! computes the product of factorials in a vector given a range
/*!
  \param a vector of integers
  \param i,j endpoints of the interval
  \return \f$\prod_{v = i}^j a_v ! \f$
*/
mpz_class prod_factorial_old(const vector<int>& a, int i, int j);

mpz_class prod_factorial(const vector<int>& a, int i, int j);

//! Write a string containing 0 and 1 to a binary file, treating the string as a bit sequence. 
/*!
  First, the size of the bit sequence is written to the output, then the input is split into 8 bit chunks, perhaps with some leftover, which are written to the output file as bytes. 
  \param f: a file pointer
  \param s: a string where each character is either 0 or 1
*/
void bit_string_write(FILE* f, const string& s);

//! Reads a bit sequence from a binary file, assuming the bit sequence was generated by the `bit_string_write` function.
/*!
  \param f: a file pointer
  \returns a string of zeros and ones. 
*/
string bit_string_read(FILE* f);


#endif
