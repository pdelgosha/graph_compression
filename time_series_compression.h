#ifndef __TIME_SERIES_COPMRESSION__
#define __TIME_SERIES_COPMRESSION__

#include <vector>
#include "bipartite_graph.h"
#include "bipartite_graph_compression.h"
using namespace std;

//! encodes a time series which is basically an array of arbitrary nonnegative integers
/*!
  This class is capable of compressing arrays of nonnegative integers with size n. Upon construction, n must be given. But later, the object is capable of compressing any sequence with this size, universally. The output of the compression is an object of type `pair<vector<int>, mpz_class>`.

  __Usage Example__

  ~~~~~~~~~{.cpp}
  vector<int> a = {0,2,3,1,2,1,0,1,0,2,1,0,0,2,1,3,4,5,0};
  int n = a.size();
  time_series_encoder E(n);
  pair<vector<int>, mpz_class > ans = E.encode(a);
  ~~~~~~~~~

  See `time_series_decoder` for decoding.
 */
class time_series_encoder{
  int n; //!< length of the series is assumed to be known 
  int alph_size; //!< the number of distinct integers showing up in the sequence. Therefore, the sequence would consists of integers in the range [0,alph_size-1].
  vector<int> freq; //!< the frequency of symbols, so has size alph_size
  b_graph G; //!< the bipartite graph version of the sequence, which has n left vertices and alph_size right sequence. Left vertex v is connected to right vertex w if the value of the time series in coordinate v is w. This way, each vertex on the left has degree 1, and the degree of a right vertex w is the frequency of w.


  //! initializes the alphabet size, i.e. the variable init_alph_size
  void init_alph_size(const vector<int>& x);

  //! initializes the freq vector
  void init_freq(const vector<int>& x);

  //! initializes the auxiliary bipartite graph G
  void init_G(const vector<int>& x);



 public:
  //! constructor
 time_series_encoder(int n_): n(n_) {}

  //! Encodes a `vector<int>` with size n
  /*!
    \param x const reference to the array to be compressed.
    \return an object of type `pair<vector<int>, mpz_class>`. The first part is the corresponding frequency array (`freq` member), and the second is the compressed form of the bipartite graph G
   */
  pair<vector<int>, mpz_class> encode(const vector<int>& x);
};



//==================================================
//         time_series_decoder
//==================================================




//! decodes a time series which is basically an array of arbitrary nonnegative integers
/*!
  This class is capable of decompressing arrays of nonnegative integers with size n. Upon construction, n must be given. But later, the object is capable of decompressing any sequence with this size, universally. The input would be the output of `time_series_decoder` class.

  __Usage Example__

  ~~~~~~~~~{.cpp}
  vector<int> a = {0,2,3,1,2,1,0,1,0,2,1,0,0,2,1,3,4,5,0};
  int n = a.size();
  time_series_encoder E(n);
  pair<vector<int>, mpz_class > ans = E.encode(a);

  time_series_decoder D(n);
  vector<int> ahat = D.decode(ans);
  if (ahat == a)
     cout << " successfully decoded the original time series! " << endl;
  ~~~~~~~~~
*/
class time_series_decoder
{
  int n; //!< the length
  int alph_size; //!< the number of distinct integers showing up in the sequence after decoding. Therefore, the sequence would consists of integers in the range [0,alph_size-1].
  vector<int> freq; //!< the frequency of symbols after decoding, so has size alph_size
  b_graph G; //!< the decoded bipartite graph as in `time_series_encoder`

 public:
  //! constructor
 time_series_decoder(int n_): n(n_) {}

  //! inputs an object of type `pair<vector<int>, mpz_class>` generated by `time_series_encoder` and returns the decoded array.
  vector<int> decode(pair<vector<int>, mpz_class>);
};



#endif
